{
  "index.html": {
    "href": "index.html",
    "title": "Altseed2 | Altseed2",
    "keywords": ""
  },
  "Manual/CLITool.html": {
    "href": "Manual/CLITool.html",
    "title": "Altseed2.Tools (.NETツール) | Altseed2",
    "keywords": "Altseed2.Tools (.NETツール) Altseed2で使えるツールをまとめたものです。 # globalの場合 dotnet tool install -g Altseed2.Tools # localの場合 dotnet new tool-manifeset dotnet tool install Altseed2.Tools でインストールして、 dotnet altseed2 <subcommand> コマンドで実行できます。 利用可能なコマンド file ファイルパッケージを作成するコマンドです。 dotnet altseed2 file -s {リソースフォルダ} -o {出力先ファイル名} [-p {パスワード}] font 静的フォントを作成するコマンドです。 dotnet altseed2 font -s {フォントファイル} -o {出力先a2f名} -c {使用したい文字列} [--size {サンプリングサイズ}] gui ファイルパッケージの生成や静的フォントファイルの生成をGUI上で行うことができます。 dotnet altseed2 gui"
  },
  "Manual/Engine/Engine.html": {
    "href": "Manual/Engine/Engine.html",
    "title": "エンジン | Altseed2",
    "keywords": "エンジン Engine は Altseed2 の基本的な機能を提供します。初期化・終了をはじめとする、Altseed2 のほとんどの機能は Engine を通して使用します。 エンジンでできること Engine は次の機能を提供します。 Altseed2 の初期化・更新処理・終了処理 Node の登録・削除・更新 各モジュール Sound ：サウンドの再生 基本的な実行手順 Altseed2 を使用するプログラムの基本構造は次のようになります。 using Altseed2; class Empty { static void Main(string[] args) { // Altseed2 を起動する前にいくつかの設定ができます。 var config = new Configuration() { // 垂直同期信号を待つかどうかを取得または設定します。 WaitVSync = true, }; // Altseed2 を初期化します。 Engine.Initialize(\"Empty\", 640, 480, config); // ここで画像などのデータを読み込んだりノードツリーを作成したりすることができます。 // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // ここに挙動をべた書きすることも可能です。 // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } Caution Initialize 、 Terminate 、 DoEvents 、 Update のメソッドはこのサンプルのように必ず使用します。 また Altseed2 のすべての機能は Initialize してから Terminate するまでの間に実行されるようにしてください。 Initialize の前や、 Terminate の後で、Altseed2 の機能を使用すると予期せぬエラーが発生することがあります。 Configuration について Altseed2 の一部機能は、初期化時に Initialize の引数として渡す Configuration を用いて設定します。 設定項目の詳細については Configuration のリファレンス をご覧ください。 ポーズ（一時停止） ゲームのプレイ中に、ゲームを一時中断して設定を変更したり休憩したりすることがあります。このような機能を実装するときは、各 Node の毎フレームの更新を停止する必要があります。しかし、一部のメニューやアニメーションなどは停止せず、更新し続ける必要があります。 Altseed2 では、ゲームの一時停止は Pause メソッドで、ゲームの再開は Resume メソッドによって実現できます。 なお、 Pause メソッドの引数にメニュー画面などの Node を渡すことにより、その Node を一時停止の対象から除外することができます。 Note 初代 Altseed では、ゲームのシーンにメニュー画面のレイヤーを追加したうえで、メニュー画面のレイヤー以外のすべてのレイヤーの IsUpdated プロパティを false にすることで実現していました。Altseed2 では上記のような方法でゲームのポーズ（一時停止）を実現します。 フレームレート Altseed2 は固定フレームレート、可変フレームレート両方に対応しています。初期値では可変フレームレートに設定されています。どちらの場合でも、1秒間の更新回数は TargetFPS で指定されている値に近づくように調整されます。 Node の OnUpdate メソッドの実行や描画処理などの更新処理は、毎秒およそこの値の回数実行されます。 <!-- TODO:残り書く --> Caution ホ ン マ か ？ ？"
  },
  "Manual/File/file.html": {
    "href": "Manual/File/file.html",
    "title": "ファイル | Altseed2",
    "keywords": "ファイル ファイル操作に関する機能を提供します。 Engine.File では、ファイルを読み込む先のディレクトリ・パッケージの指定やディレクトリのパッケージ化が可能です。 そして、ファイルを読み込むことができ、 StaticFile.Create メソッドを用いて StaticFile インスタンスを作成するか、 StreamFile.Create メソッドを用いて StreamFile インスタンスを作成する方法の2種類があります。 Engine.File Engine.File.AddRootDirectory メソッドでファイルを読み込む時のルートを指定します。 一切ルートを指定していないと、カレントディレクトリから相対的にファイルを読み込みます。 ルートディレクトリが指定されていると、ルートディレクトリから相対的にファイルを読み込みます。 また、 Engine.File.AddRootPackage メソッドで複数のファイルを1つにまとめたパッケージをルートに指定することが可能で、パッケージ内からファイルを読み込みます。 パスワード付きのパッケージをルートに指定する場合、 Engine.File.AddRootPackageWithPassword メソッドを使用してください。 StaticFile StaticFile は、ファイルを一括で全て読み込むクラスです。 ファイルを読み込んで StaticFile インスタンスを生成するには Create メソッドを使います。 読み込んだファイルの内容は、 Buffer で、Byte配列として得られます。 Tip 一度、 Create するとキャッシュされます。 よって、同じパスでファイルを Create した場合、キャッシュから読み込まれるため、読み込み時間が小さくなります。 StreamFile StreamFile は、ファイルを部分的に読み込むクラスです。 ファイルを読み込んで StreamFile インスタンスを生成するには Create メソッドを使います。 Read メソッドによって、指定されたサイズの分だけ、ファイルに格納されているデータを読み込みます。 読み込んだ内容は、 TempBuffer で、Byte配列として得られます。 また、現在読み込まれているデータのサイズは、 TempBufferSize で得られます。 サンプル StaticFileによるファイル読み込み using System; using System.Text; using Altseed2; namespace Sample { class FileStaticFile { [STAThread] static void Main(string[] args) { // Altseed2 を初期化します。 if (!Engine.Initialize(\"StaticFile\", 640, 480)) return; // ファイルを読み込みます。 var staticFile = StaticFile.Create(@\"TestData/IO/test.txt\"); // バイト配列をUTF8として、string型に変換します。 var text = Encoding.UTF8.GetString(staticFile.Buffer); // コンソールに出力します。 Console.WriteLine(text); // Altseed の終了処理をします。 Engine.Terminate(); } } } StreamFileによるファイル読み込み using System; using System.Text; using Altseed2; namespace Sample { class FileStreamFile { [STAThread] static void Main(string[] args) { // Altseed2 を初期化します。 if (!Engine.Initialize(\"StaticFile\", 640, 480)) return; // ファイルを読み込みます。 var streamFile = StreamFile.Create(@\"TestData/IO/test.txt\"); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseedを更新します。 Engine.Update(); // 1バイト読み込む var size = streamFile.Read(1); // バイト配列をUTF8として、string型に変換します。 var text = Encoding.UTF8.GetString(streamFile.TempBuffer); // コンソールに出力します。 Console.WriteLine(text); // 新たに読み込んだデータが0なら終了させます。 if (size == 0) break; } // Altseed の終了処理をします。 Engine.Terminate(); } } }"
  },
  "Manual/File/Package.html": {
    "href": "Manual/File/Package.html",
    "title": "ファイルパッケージ | Altseed2",
    "keywords": "ファイルパッケージ ファイルパッケージングとは、Altseed2で使用するファイルを一つのファイルにまとめる機能を指します。 この機能を使用することで、Altseed2で使用するリソースデータを、ユーザから簡単に見られないようにすることができます。 パッケージの作り方 ツールを利用して生成する（推奨） Altseed2.Tools (.NETツール) を利用して、CLIコマンドまたはGUIを用いてパッケージを作成することができます。 ソースコード上から生成する Altseed2を用いてソースコード上から生成する方法を説明します。 パッケージの作成は、 Engine.File.Pack メソッドで、パッケージ化するディレクトリとパッケージのパスを指定することでできます。 また、 Engine.File.PackWithPassword メソッドによって、パスワード付きでパッケージ化することが可能です。 パスワード付きのパッケージにすることで、パッケージ化されたリソースデータをユーザから抽出されるのを防ぐことができます。 パッケージの使い方 Engine.File.AddRootPackage メソッドでパッケージをルートに指定することが可能で、パッケージ内からファイルを読み込みます。 そして、ルートディレクトリやパッケージは複数指定できます。 ファイルを読み込む時に複数のファイルが見つかった時、後から追加されたルートディレクトリやパッケージから読み込みます。 絶対パスを指定した場合、ルートの指定関係なく絶対パスで指定された先を読み込みます。 パスワード付きのパッケージをルートに指定する場合、 Engine.File.AddRootPackageWithPassword メソッドを使用してください。 Tip 複数のパッケージを読み込んだ時の優先順位を利用することでアップデートパッチを容易に実装できます。 例えば、製品の最初でパッケージXに格納されているファイルAがあるとします。ファイルAに不具合が存在することが発覚し、ファイルAを差し替えることになりました。 このとき、更新した新しいファイルAをパッケージYに格納します。そして、プログラム側ではパッケージX, パッケージYの順に追加するようにしておきます。 すると同じ名前のファイルAを読み込むときにパッケージXからでなく、後から追加したパッケージYから読み込むようになります。 このように更新したファイルのみを別のパッケージにまとめることで、 実際に読み込む際のファイルのパス指定を変更することなく容易にファイルの更新を行えます。 Note Altseed2のパッケージング機能の内部実装は、Zip圧縮になっています。 したがって、任意のZipファイルをパッケージとして読み込むことができます。 サンプル パッケージの作成・読み込み using System; using Altseed2; namespace Sample { class Package { [STAThread] static void Main(string[] args) { // Altseed を初期化します。 if (!Engine.Initialize(\"SpriteNode\", 640, 480)) return; // TestData ディレクトリからファイルパッケージを生成します。 Engine.File.Pack(\"TestData\", \"Package.pack\"); // Package.pack をルートパッケージにします。 Engine.File.AddRootPackage(\"Package.pack\"); // パッケージに含まれる画像データをロードします。 var texture = Texture2D.Load(@\"TestData/IO/AltseedPink256.png\"); // 画像を描画するノードを生成・登録します。 var node = new SpriteNode(); node.Texture = texture; Engine.AddNode(node); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } } パスワード付きパッケージの作成・読み込み using System; using Altseed2; namespace Sample { class PackageWithPassword { [STAThread] static void Main(string[] args) { // Altseed を初期化します。 if (!Engine.Initialize(\"SpriteNode\", 640, 480)) return; // TestData ディレクトリからファイルパッケージを生成します。 // パスワードを ALTSEED とします。 Engine.File.PackWithPassword(\"TestData\", \"Package.pack\", \"ALTSEED\"); // Package.pack をルートパッケージにします。 Engine.File.AddRootPackageWithPassword(\"Package.pack\", \"ALTSEED\"); // パッケージに含まれる画像データをロードします。 var texture = Texture2D.Load(@\"TestData/IO/AltseedPink256.png\"); // 画像を描画するノードを生成・登録します。 var node = new SpriteNode(); node.Texture = texture; Engine.AddNode(node); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } } Zipファイルをパッケージとして読み込み using System; using Altseed2; namespace Sample { class PackageFromZip { [STAThread] static void Main(string[] args) { // Altseed を初期化します。 if (!Engine.Initialize(\"SpriteNode\", 640, 480)) return; // Package.zip をルートパッケージにします。 Engine.File.AddRootPackage(\"Package.zip\"); // パッケージに含まれる画像データをロードします。 var texture = Texture2D.Load(@\"TestData/IO/AltseedPink256.png\"); // 画像を描画するノードを生成・登録します。 var node = new SpriteNode(); node.Texture = texture; Engine.AddNode(node); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } }"
  },
  "Manual/Graphics/Camera.html": {
    "href": "Manual/Graphics/Camera.html",
    "title": "カメラ | Altseed2",
    "keywords": "カメラ CameraNode は指定の領域の描画結果を写し撮るノードです。既定では写し撮った領域は画面に描画されます。 CameraNode が撮影する領域は Angle 、 CenterPosition 、 Position 、 Scale プロパティを用いることで設定できます。 Note 既定では、 CameraNode が撮影する領域は、点 (0, 0) を左上とする、 ウインドウサイズ と同じ大きさ（ TargetTexture を設定した場合はその 大きさ ）の長方形の領域です。上記の各種プロパティを設定してこの長方形を変形することで、撮影する領域を調整すると考えるとよいです。 描画結果を RenderTexure として取り出して再利用することもできます。 Material などを付けて再描画することができます。 Important エンジンにカメラが一つも登録されていない場合は、暗黙的に存在するデフォルトカメラによって登録されている描画できる全てのノードが描画されます。しかし エンジンにカメラが一つでも登録した場合は、デフォルトカメラが無効化されるため、下記の CameraGroup プロパティを適切に設定していないノードは描画されません。 クリア IsColorCleared プロパティを設定することで、 CameraNode が描画を開始する前、描画領域をクリアすることができます。その際の色は ClearColor プロパティで設定できます。クリアを行わないと、前のフレームの描画結果に上書きして描画した結果が得られます。 Note 複数のカメラの描画結果を画面に出力する場合、透明な色でクリアすることによって、より下に（先に）出力されるカメラの描画結果も表示することができます。 グループ SpriteNode や PostEffectNode のような描画できるノードが持っている CameraGroup プロパティは、どのカメラの描画によって描画されるかを指定するものです。 描画の対象となる CameraGroup は、 CameraNode クラスが持つ Group プロパティと、 CameraGroup プロパティの AND 演算の結果が 0 以外である場合、描画します。 Note CameraNode は Group プロパティの値に従い 降順 に描画結果を生成します。これはペイントソフトなどにおけるレイヤーの重ね順のように機能します。 Important 上記の通り、画面もしくは RenderTexure への描画は Group プロパティの値に従い 降順 に行われます。 RenderTexure への描画結果を SpriteNode などで再利用する場合、その SpriteNode は RenderTexure への描画を行った CameraGroup よりも Group プロパティの値がより大きい CameraGroup によって撮影する場合のみ正常に描画されます。 Group プロパティの値が同じか、より小さい CameraNode によって撮影しようとした場合、 RenderTexure への描画がその時点でまだ行われていないため、何も描画されていないか1フレーム前の描画結果を使用して描画が行われます。 サンプル カメラ using System; using Altseed2; namespace Sample { class Camera { [STAThread] static void Main(string[] args) { const ulong cameraGroup = 0b1; // Altseed2 を初期化します。 if (!Engine.Initialize(\"Camera\", 640, 480)) return; // SpriteNode を作成します。 // 詳しくは SpriteNode のサンプルを参照してください。 var sprite = new SpriteNode(); // テクスチャを設定します。 sprite.Texture = Texture2D.Load(@\"TestData/IO/AltseedPink256.png\"); sprite.CameraGroup = cameraGroup; Engine.AddNode(sprite); // sprite の座標を設定します。 sprite.Position = new Vector2F(100, 100); // カメラノードを作成します。 var camera = new CameraNode(); // カメラが映す対象とするグループを設定します。 camera.Group = cameraGroup; // カメラが映す箇所の座標を設定します。 camera.Position = new Vector2F(100, 100); // カメラノードを登録します。 Engine.AddNode(camera); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } } RenderTexture using System; using Altseed2; namespace Sample { class Camera_RenderTexture { [STAThread] static void Main(string[] args) { const ulong cameraGroup = 0b1; const ulong cameraGroup2 = 0b10; // Altseed2 を初期化します。 if (!Engine.Initialize(\"RenderTexture\", 640, 480)) return; // SpriteNode を作成します。 // 詳しくは SpriteNode のサンプルを参照してください。 var sprite = new SpriteNode(); sprite.Texture = Texture2D.Load(@\"TestData/IO/AltseedPink256.png\"); sprite.CameraGroup = cameraGroup; sprite.Scale = new Vector2F(200, 200) / sprite.Texture.Size; Engine.AddNode(sprite); // スクリーンのように描画先にできるテクスチャを作成します。 var renderTexture = RenderTexture.Create(new Vector2I(200, 200), TextureFormat.R8G8B8A8_UNORM); // sprite を写してrenderTexture に出力する CameraNode を作成します。 // 詳しくは CameraNode のサンプルを参照してください。 var camera = new CameraNode(); camera.Group = cameraGroup; Engine.AddNode(camera); // カメラの描画先を設定します。 // null のとき出力先はスクリーンになります。 camera.TargetTexture = renderTexture; // 描画する前に TargetTexture を指定色で塗りつぶすかどうかを設定します。 camera.IsColorCleared = true; // 塗りつぶす色を設定します。 camera.ClearColor = new Color(100, 100, 100); // renderTexture をスクリーンに描画するための SpriteNode を作成します。 var sprite2 = new SpriteNode(); sprite2.Texture = renderTexture; sprite2.CameraGroup = cameraGroup2; Engine.AddNode(sprite2); // sprite2 を写してスクリーンに出力するカメラを作成します。 var camera2 = new CameraNode(); camera2.Group = cameraGroup2; Engine.AddNode(camera2); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } }"
  },
  "Manual/Graphics/Material.html": {
    "href": "Manual/Graphics/Material.html",
    "title": "マテリアル | Altseed2",
    "keywords": "マテリアル Altseed2では描画方法をマテリアルにより拡張できます。 例えば、画像をそのまま表示するのではなく、反転させたり合成されたりスクロールしたりして表示できます。 マテリアルを使用するためには、シェーダーを先に用意する必要があります。 シェーダーはHLSLというプログラミング言語で描画方法を記述して、そのソースコードを元に生成します。 HLSLには制約があります。 頂点シェーダーとピクセルシェーダー間のデータ受け渡し用の構造体の定義は完全に一致する必要があります。 サンプラーとテクスチャは隙間なく敷き詰める必要があります。 頂点シェーダーでテクスチャを使用する場合、ピクセルシェーダーでも同じテクスチャとサンプラーの定義を書く必要があります。 includeはファイルからシェーダーのソースコードを読み込んだ場合のみ有効です。 シェーダーを作成し、マテリアルに設定します。 そうすると、設定されたシェーダーをマテリアルで使用して描画します。 作成したマテリアルは様々なクラスに割り当てられます。 シェーダーは、直接Altseed2が動いているプログラミング言語の文字列をソースコードとして作成する方法と、テキストファイルを読み込んで作成する方法の2種類があります。 テキストファイルを作成する手間はありますが、includeを使用できるメリットがあります。 マテリアルにはアルファブレンドを設定できます。 描画される先と描画する画像の間で、画像同士をどのように合成するかを指定できます。 下図の画像は、標準で提供されているOpacity, Normal, Add, Subtract, Multiplyの合成結果です。 これら以外にも自由に合成方法を指定できます。 using System; using Altseed2; namespace Sample { public class MaterialSample { const string _HlslCode = @\" struct PS_INPUT { float4 Position : SV_POSITION; float4 Color : COLOR0; float2 UV1 : UV0; float2 UV2 : UV1; }; Texture2D mainTex : register(t0); SamplerState mainSamp : register(s0); float4 main(PS_INPUT input) : SV_TARGET { // 入力画像のUV画像に対応するピクセルの色を取得します。 float4 color = mainTex.Sample(mainSamp, input.UV1); // RGBの値を反転します。 color.xyz = float3(1.0) - color.xyz; // 算出した値を返します。 return color; } \"; [STAThread] static void Main(string[] args) { // Altseed2 を初期化します。 if (!Engine.Initialize(\"TextNode\", 640, 480)) return; // テクスチャを読み込みます。 var texture = Texture2D.Load(@\"TestData/IO/AltseedPink256.png\"); // マテリアルを作成します。 var material = Material.Create(); // マテリアルに使用するシェーダを作成します。 var shader = Shader.Create(\"Negative\", _HlslCode, ShaderStage.Pixel); // マテリアルにシェーダを割り当てます。 material.SetShader(shader); // 必要な場合、アルファブレンドの種類を割り当てます。 material.AlphaBlend = AlphaBlend.Normal; // スプライトを描画するノードを作成します。 var node = new SpriteNode(); // テクスチャを設定します。 node.Texture = texture; // マテリアルを設定します。 node.Material = material; // ノードを登録します。 Engine.AddNode(node); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } }"
  },
  "Manual/Graphics/PostEffect.html": {
    "href": "Manual/Graphics/PostEffect.html",
    "title": "ポストエフェクト | Altseed2",
    "keywords": "ポストエフェクト PostEffectNode は画面やカメラに対し何らかの効果を加えて表示される映像を変化させるノードです。 組み込みポストエフェクト グレースケール PostEffectGrayScaleNode は画面をグレースケール化するポストエフェクトです。 using System; using Altseed2; namespace Sample { public class PostEffectGrayScale { [STAThread] static void Main(string[] args) { // Altseed2 を初期化します。 if (!Engine.Initialize(\"PostEffect - GrayScale\", 640, 480)) return; // 画像を表示するノードを作成して登録します。 // 詳しくはSpriteのサンプルを参照してください。 var node = new SpriteNode { Texture = Texture2D.Load(@\"TestData/Graphics/flower.png\"), Scale = new Vector2F(0.5f, 0.5f) }; Engine.AddNode(node); // グレースケールを適用するポストエフェクトを作成して登録します。 var postEffect = new PostEffectGrayScaleNode(); Engine.AddNode(postEffect); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } } セピアカラー PostEffectSepiaNode は画面をセピア調にするポストエフェクトです。 using System; using Altseed2; namespace Sample { public class PostEffectSepia { [STAThread] static void Main(string[] args) { // Altseed2 を初期化します。 if (!Engine.Initialize(\"PostEffect - Sepia\", 640, 480)) return; // 画像を表示するノードを作成して登録します。 // 詳しくはSpriteのサンプルを参照してください。 var node = new SpriteNode { Texture = Texture2D.Load(@\"TestData/Graphics/flower.png\"), Scale = new Vector2F(0.5f, 0.5f) }; Engine.AddNode(node); // セピアを適用するポストエフェクトを作成して登録します。 var postEffect = new PostEffectSepiaNode(); Engine.AddNode(postEffect); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } } ガウスぼかし PostEffectGaussianBlurNode は画面にぼかしを書けるポストエフェクトです。画面が一様にぼけます。 using System; using Altseed2; namespace Sample { public class PostEffectGaussianBlur { [STAThread] static void Main(string[] args) { // Altseed2 を初期化します。 if (!Engine.Initialize(\"PostEffect - GaussianBur\", 640, 480)) return; // 画像を表示するノードを作成して登録します。 // 詳しくはSpriteのサンプルを参照してください。 var node = new SpriteNode { Texture = Texture2D.Load(@\"TestData/Graphics/flower.png\"), Scale = new Vector2F(0.5f, 0.5f) }; Engine.AddNode(node); // ガウスぼかしを適用するポストエフェクトを作成して登録します。 var postEffect = new PostEffectGaussianBlurNode { // ガウスぼかしの強さを設定します。 Intensity = 3.0f }; Engine.AddNode(postEffect); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } } ライトブルーム PostEffectLightBloomNode は画面で一定以上明るい画素をぼかして加算することで、光が溢れているような表現を与えるポストエフェクトです。 具体的な処理としては元の画像から閾値を超えた画素を抽出し、閾値を超えた分の輝度をぼかして元の画像に加算しています。 using System; using Altseed2; namespace Sample { public class PostEffectLightBloom { [STAThread] static void Main(string[] args) { // Altseed2 を初期化します。 if (!Engine.Initialize(\"PostEffect - LightBloom\", 640, 480)) return; // 画像を表示するノードを作成して登録します。 // 詳しくはSpriteのサンプルを参照してください。 var node = new SpriteNode { Texture = Texture2D.Load(@\"TestData/Graphics/flower.png\"), Scale = new Vector2F(0.5f, 0.5f) }; Engine.AddNode(node); // ライトブルームを適用するポストエフェクトを作成して登録します。 var postEffect = new PostEffectLightBloomNode { // ライトブルームの強さを設定します。 Intensity = 5.0f, Threshold = 0.5f }; Engine.AddNode(postEffect); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } } 自作ポストエフェクト PostEffectNode , Shader , Material のクラスを使用して、自作ポストエフェクトを実装できます。下記のサンプルでは、階調を反転させています。 HLSLのコードを記述すれば、Altseedが内部で適切に変換するため、自動的にマルチプラットフォーム対応になります。 using System; using Altseed2; namespace Sample { public class CustomPostEffect { [STAThread] static void Main(string[] args) { // Altseed2 を初期化します。 if (!Engine.Initialize(\"PostEffect - Custom\", 640, 480)) return; // 画像を表示するノードを作成して登録します。 // 詳しくはSpriteのサンプルを参照してください。 var node = new SpriteNode { Texture = Texture2D.Load(@\"TestData/Graphics/flower.png\"), Scale = new Vector2F(0.5f, 0.5f) }; Engine.AddNode(node); // 自作のポストエフェクトを描画するノードを作成して登録します。 var postEffect = new MyPostEffectNode(); Engine.AddNode(postEffect); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } class MyPostEffectNode : PostEffectNode { const string _HlslCode = @\" struct PS_INPUT { float4 Position : SV_POSITION; float4 Color : COLOR0; float2 UV1 : UV0; float2 UV2 : UV1; }; Texture2D mainTex : register(t0); SamplerState mainSamp : register(s0); float4 main(PS_INPUT input) : SV_TARGET { // 入力画像のUV画像に対応するピクセルの色を取得します。 float4 color = mainTex.Sample(mainSamp, input.UV1); // RGBの値を反転します。 color.xyz = float3(1.0, 1.0, 1.0) - color.xyz; // 算出した値を返します。 return color; }\"; // ポストエフェクトに使用するマテリアル private readonly Material _Material; public MyPostEffectNode() { // マテリアルに使用するシェーダを作成します。 var shader = Shader.Create(\"Negative\", _HlslCode, ShaderStage.Pixel); // スプライトを描画するノードを作成します。 _Material = Material.Create(); // マテリアルにシェーダを割り当てます。 _Material.SetShader(shader); } protected override void Draw(RenderTexture src, Color clearColor) { // マテリアルを入力画像を設定します。 _Material.SetTexture(\"mainTex\", src); // マテリアルを適用します。 Engine.Graphics.CommandList.RenderToRenderTarget(_Material); } } } }"
  },
  "Manual/Graphics/Sprite.html": {
    "href": "Manual/Graphics/Sprite.html",
    "title": "画像 | Altseed2",
    "keywords": "画像 画像を描画するには、 画像を格納する Texture2D Texture2Dを描画する SpriteNode を使用します。 Texture2D 画像情報を格納するクラスです。 Load メソッドを用いて画像ファイルを読み込み Texture2D インスタンスを作成します。 現在、読み込み可能なフォーマットは、以下の通りです。 JPEG PNG TGA BMP PSD GIF HDR PIC PNM Tip フォーマットによっては、アルファチャンネルに対応していない場合があります。 また、 LoadAsync メソッドを用いて、非同期的に画像を読み込むことができます。 非同期読み込みによって、読み込みを待たずに描画処理を行うことができます。 SpriteNode 描画するテクスチャやそれに適用するオプションを設定可能にしたノードです。描画するテクスチャ、そのテクスチャの切り出し範囲、反転描画のフラグなどを設定することができます。 サンプル 画像の描画 using System; using Altseed2; namespace Sample { class Sprite { [STAThread] static void Main(string[] args) { // Altseed2 を初期化します。 if (!Engine.Initialize(\"SpriteNode\", 640, 480)) return; // テクスチャを読み込みます。 var texture = Texture2D.Load(@\"TestData/IO/AltseedPink256.png\"); // スプライトを描画するノードを作成します。 var node = new SpriteNode(); // テクスチャを設定します。 node.Texture = texture; // ノードを登録します。 Engine.AddNode(node); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } }"
  },
  "Manual/Graphics/Text.html": {
    "href": "Manual/Graphics/Text.html",
    "title": "文字 | Altseed2",
    "keywords": "文字 文字を描画するには、 フォントデータを格納する Font Fontを使って文字列を描画する TextNode を使用します。 Font フォント情報を格納するクラスです。 実行時にフォント情報を作成する動的フォントと、事前にフォント情報を作成する静的フォントの二種類があります。 動的フォント メリット 事前に使用する文字を指定せず、必要に応じて文字情報をフォントファイルから読み込んで追加できる。 デメリット 新しい文字を読み込む際に負荷が発生する。 フォントの規約によってはゲームに直接フォントファイルを同梱できない場合が多い。 静的フォント メリット 文字を読み込む負荷が発生しない。 フォントファイルを事前に画像に変換するため、フォントファイルを直接同梱する必要がない。 デメリット 事前に使用したい文字を指定して静的フォントファイルを生成する必要がある。 フォントのサイズ Altseed2 では、フォントの描画に MSDF を利用しています。 Altseed 初代では利用したいフォントサイズごとに Font クラスのインスタンスを作成する必要がありましたが、Altseed2 では読み込み時のサンプリングサイズをある程度大きく指定すれば、好きなサイズでの文字列の描画に利用することができます。 サンプリングサイズとしては、通常は 64 程度、複雑な形状の文字を利用する場合にはそれ以上の値を指定すると良さそうです。 対応フォーマット Freetypeが対応している以下のフォーマットを利用することができます。 TrueType fonts (TTF) and TrueType collections (TTC) CFF fonts WOFF fonts OpenType fonts (OTF, both TrueType and CFF variants) and OpenType collections (OTC) Type 1 fonts (PFA and PFB) CID-keyed Type 1 fonts SFNT-based bitmap fonts, including color Emoji X11 PCF fonts Windows FNT fonts BDF fonts (including anti-aliased ones) PFR fonts Type 42 fonts (limited support) https://www.freetype.org/freetype2/docs/index.html 動的フォント LoadDynamicFont 静的メソッドを用いてフォントファイルを読み込み Font インスタンスを作成します。 // 動的フォントを読み込む (デフォルトのサンプリングサイズは64) var font = Font.LoadDynamicFont(\"path/to/dynamicfont.ttf\"); // サンプリングサイズを指定してフォントファイルを読み込む var fontWithSamplingSize = Font.LoadDynamicFont(\"path/to/dynamicfont.otf\", 96); 静的フォント 静的フォントを使用する場合は、事前にa2fファイルを作成する必要があります。 ツールを利用して生成する（推奨） Altseed2.Tools (.NETツール) を利用して、CLIコマンドまたはGUIを用いて静的フォントを作成することができます。 ソースコード上から生成する Altseed2 から直接呼び出したい場合は、 GenerateFontFile 静的メソッドを利用して、a2fファイルを生成することができます。 その後、 LoadStaticFont 静的メソッドを用いてa2fファイルを読み込み Font インスタンスを作成します。 // 事前に生成したa2fファイルから静的フォントを読み込む var font = Font.LoadStaticFont(\"path/to/staticfont.a2f\"); // コード上から静的フォントを生成したい場合 Font.GenerateFontFile(\"font.ttf\", \"font.a2f\", \"使いたい文字を指定\"); // コード上から静的フォントを生成したい場合（サンプリングサイズの指定） Font.GenerateFontFile(\"font.ttf\", \"font96.a2f\", \"使いたい文字を指定\", 96); a2fファイル font.a2f を出力先として指定した場合、以下のようなファイルとフォルダが生成されます。 font.a2f font/ ├── Texture0.png ├── Texture1.png ├── ... └── TextureN.png このa2fファイルを使いたい場合は、この相対位置を保って font.a2f ファイルと font フォルダを同じフォルダに配置する必要があります。 TextNode 描画する文字列やそれに適用するオプションなどを設定可能にしたノードです。 描画する文字列、文字列の大きさなどを設定することができます。 サンプル 文字の描画 using System; using Altseed2; namespace Sample { public class TextSample { [STAThread] static void Main(string[] args) { // Altseed2 を初期化します。 if (!Engine.Initialize(\"TextNode\", 640, 480)) return; // フォントファイルを読み込みます。 var font = Font.LoadDynamicFont(@\"TestData/Font/mplus-1m-regular.ttf\", 64); // テキストを描画するノードを作成します。 var node = new TextNode(); // フォントを設定します。 node.Font = font; // フォントサイズ node.FontSize = 48; // 描画する文字列を設定します。 node.Text = \"Hello World!\"; // ノードを登録します。 Engine.AddNode(node); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } }"
  },
  "Manual/index.html": {
    "href": "Manual/index.html",
    "title": "Altseed2 機能解説 | Altseed2",
    "keywords": "Altseed2 機能解説"
  },
  "Manual/Input/Cursor.html": {
    "href": "Manual/Input/Cursor.html",
    "title": "カーソル | Altseed2",
    "keywords": "カーソル Cursor は カーソルの画像を設定するためのクラスです。 基本的な使い方 Altseed2の Create を呼び出し、カーソルインスタンスを生成します。 生成したカーソルインスタンスを、Mouseの Create に入れてカーソルをセットすると、カーソル画像が変更されます。 Note ホットスポットとは、カーソルのクリック判定の出る座標のことです。 座標は画像の中の相対座標で指定してください。 画像はホットスポットが中心となります。 Create サンプル using System; using Altseed2; namespace Sample { class MouseCursor { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"MouseCursor\", 640, 480); // まず、カーソルオブジェクトを生成します。画像の読み込みに失敗するとnullが返ります。 // 引数は、string(png画像のパス), Altseed2.Vector2I(クリック判定の相対座標) です。 var cursor = Cursor.Create(\"../../Core/TestData/Input/altseed_logo.png\", new Vector2I(16, 16)); if (cursor != null) { // マウスにカーソルをセットします。 Engine.Mouse.CursorImage = cursor; } while (Engine.DoEvents()) { Engine.Update(); } Engine.Terminate(); } } } カーソルインスタンスを生成するメソッドです。 第一引数にカーソルの画像、第二引数にホットスポットを指定します。 戻り値は ButtonState です。 画像のロードに失敗したときは null を返します。"
  },
  "Manual/Input/Joystick.html": {
    "href": "Manual/Input/Joystick.html",
    "title": "ジョイスティック | Altseed2",
    "keywords": "ジョイスティック Joystick クラスはジョイスティックコントローラーについての機能を提供します。 コントローラーの検出やコントローラー情報の取得、ボタンやスティックの入力の取得が可能です。 SDL GameControllerDB に対応しているコントローラー（およそ数百種類）では、 JoystickButton や JoystickAxis を利用して抽象化されたコントローラーへのアクセスが可能です。 基本的な呼び出し手順 Altseed2の Initialize を呼び出した後、 Engine.Joystick という形でJoystickの各種メソッドを呼び出してください。 Joystickを接続・取り外しした際には、自動的にインデックスが更新されます。 ジョイスティックの情報の取得 Engine.Joystick.GetJoystickInfo(int joystickIndex) を利用して、指定したインデックスのジョイスティックの情報を取得できます。 返り値は JoystickInfo です。 ジョイスティックが接続されていない場合は null を返します。 JoystickInfo を通して、ジョイスティックの情報を取得できます。 IsGamepad : ジョイスティックがGameControllerDBに登録された製品かどうかを取得できます。 GamepadName : IsGamepad が true の場合にのみ使えます。GameControllerDBに登録された、わかりやすい名前を取得できます。 Name : IsGamepad が false の場合はこちらを利用してください。 また、 Engine.Joystick.IsPresent(int joystickIndex) を利用しても、指定したインデックスにジョイスティックが接続されているかどうかを取得できます。 ボタン入力の取得 ボタンの取得は以下のメソッドを用いて行います。 第一引数に取得したいジョイスティックコントローラーのインデックスを指定します。 戻り値は ButtonState です。 GetButtonState(int joystickIndex, JoystickButton button) 第2引数に JoystickButton を指定します。 JoystickInfo の IsGamepad が true の時のみ利用できます。 GetButtonState(int joystickIndex, int buttonIndex) 第2引数にボタンのインデックスを指定します。 using System; using Altseed2; using System.Linq; namespace Sample { class JoystickButtonSample { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"JoystickButton\", 640, 480); // 状態を出力するための TextNode を作成します。 // 詳細は TextNode のサンプルを参照してください。 var font = Font.LoadDynamicFont(\"./mplus-1m-regular.ttf\", 64); var textNode = new TextNode(); textNode.Font = font; textNode.FontSize = 20; Engine.AddNode(textNode); while (Engine.DoEvents()) { var displayText = \"\"; var info = Engine.Joystick.GetJoystickInfo(0); // 指定したインデックスのジョイスティックが接続しているかどうかを確認します。 // Joystick.IsPresentも利用できます。(こちらの方が高速) if (info is null) { displayText = \"コントローラーが接続されていません。\\n\"; } else { displayText += $\"コントローラー名: {info.Name}\\n\"; displayText += $\"プロダクトID: {info.Product}\\n\"; displayText += $\"ベンダーID: {info.Vendor}\\n\"; if (info.IsGamepad) { // ゲームパッドとして登録されているJoystickの場合 // Nameよりもわかりやすい名前を取得可能です。 displayText += $\"ゲームパッド名: {info.GamepadName}\\n\"; foreach (var buttonType in Enum.GetValues(typeof(JoystickButton)).Cast<JoystickButton>()) { // ジョイスティックコントローラーのボタン入力を取得します。 // ジョイスティックのインデックスと確認したいジョイスティックボタンを指定します。 // 第一引数: ジョイスティックのインデックス // 第二引数: ジョイスティックボタンの種類(対応しているコントローラーでのみ利用可能) var state = Engine.Joystick.GetButtonState(0, buttonType); var buttonName = buttonType.ToString(); displayText += state switch { ButtonState.Free => $\"{buttonName}が離されています\\n\", ButtonState.Hold => $\"{buttonName}が押されています\\n\", ButtonState.Release => $\"{buttonName}が離されました！\\n\", ButtonState.Push => $\"{buttonName}が押されました！\\n\", _ => $\"{buttonName}が想定されていない状態({(int)state})です\\n\", }; } } else { // ゲームパッドとして登録されていないJoystickの場合 displayText += $\"ゲームパッドとして登録されていません。\\n\"; for (int buttonIndex = 0; buttonIndex < info.ButtonCount; buttonIndex++) { // ジョイスティックコントローラーのボタン入力を取得します。 // ジョイスティックのインデックスと確認したいボタンインデックスを指定します。 // 第一引数: ジョイスティックのインデックス // 第二引数: ジョイスティックのボタンのインデックス var state = Engine.Joystick.GetButtonState(0, buttonIndex); displayText += state switch { ButtonState.Free => $\"{buttonIndex}番目のボタンが離されています\\n\", ButtonState.Hold => $\"{buttonIndex}番目のボタンが押されています\\n\", ButtonState.Release => $\"{buttonIndex}番目のボタンが離されました！\\n\", ButtonState.Push => $\"{buttonIndex}番目のボタンが押されました！\\n\", _ => $\"{buttonIndex}番目のボタンが想定されていない状態({(int)state})です\\n\", }; } } } textNode.Text = displayText; // Altseed2 の各種更新処理を行います。 Engine.Update(); } // Altseedの終了処理をします。 Engine.Terminate(); } } } スティック入力の取得 スティックの取得には以下のメソッドを用います。 第一引数に取得したいジョイスティックコントローラーのインデックスを指定します。 戻り値は-1から1の間のfloatです。 取得できる値は、左右スティックの水平方向(LeftX, RightX), 垂直方向(LeftY, RightY)、左右のトリガー(LeftTrigger, RightTrigger)です。 GetAxisState(int joystickIndex, JoystickAxis axis) 第２引数に JoystickAxis を指定します。 JoystickInfo の IsGamepad が true の時のみ利用できます。 GetAxisState(int joystickIndex, int axisIndex) 第２引数にスティックのインデックスを指定します。 using System; using Altseed2; using System.Linq; namespace Sample { class JoystickAxisSample { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"JoystickAxis\", 640, 480); // 状態を出力するための TextNode を作成します。 // 詳細は TextNode のサンプルを参照してください。 var font = Font.LoadDynamicFont(\"./mplus-1m-regular.ttf\", 64); var textNode = new TextNode(); textNode.Font = font; textNode.FontSize = 30; Engine.AddNode(textNode); // ゲームのメインループ while (Engine.DoEvents()) { var displayText = \"\"; var info = Engine.Joystick.GetJoystickInfo(0); if (info is null) { displayText = \"コントローラーが接続されていません。\\n\"; } else { displayText += $\"コントローラー名: {info.Name}\\n\"; displayText += $\"プロダクトID: {info.Product}\\n\"; displayText += $\"ベンダーID: {info.Vendor}\\n\"; if (info.IsGamepad) { // ゲームパッドとして登録されているJoystickの場合 displayText += $\"ゲームパッド名: {info.GamepadName}\\n\"; foreach (var axisType in Enum.GetValues(typeof(JoystickAxis)).Cast<JoystickAxis>()) { // ジョイスティックコントローラーの軸入力を取得します。 // ジョイスティックのインデックスと確認したい軸の種類を指定します。 // 第一引数: ジョイスティックのインデックス // 第二引数: ジョイスティック軸の種類(対応しているコントローラーでのみ利用可能) var state = Engine.Joystick.GetAxisState(0, axisType); displayText += $\"{axisType} : {state} \\n\"; } } else { // ゲームパッドとして登録されていないJoystickの場合 displayText += $\"ゲームパッドとして登録されていません。\\n\"; for (int axisIndex = 0; axisIndex < info.AxisCount; axisIndex++) { // ジョイスティックコントローラーの軸入力を取得します。 // ジョイスティックのインデックスと確認したい軸のインデックスを指定します。 // 第一引数: ジョイスティックのインデックス // 第二引数: ジョイスティックの軸のインデックス var state = Engine.Joystick.GetAxisState(0, axisIndex); displayText += $\"{axisIndex}番目のスティック : {state} \\n\"; } } } textNode.Text = displayText; // Altseed2 の各種更新処理を行います。 Engine.Update(); } // Altseedの終了処理をします。 Engine.Terminate(); } } } <!-- ## 振動 サンプル [!code-csharp[Main](../../Src/Samples/Input/JoystickVibrate.cs)] ジョイスティックコントローラーを振動させるには以下のメソッドを使用します。 * [Vibrate](xref:Altseed2.Joystick.Vibrate(System.Int32,System.Single,System.Single)) 第1引数は振動させたいジョイスティックコントローラーのインデックスです。 第2引数では振動の周波数を指定します。(40.0 ~ 1252.0) 第3引数では振動の振幅を指定します。(0.0 ~ 1.0) 一度このメソッドを実行すると、5秒程度コントローラーが振動します。 > [!TIP] > 振動をキャンセルしたい場合は、振幅に0を指定してこのメソッドを実行してください。 [!CAUTION] * 周波数は 40.0 から 1252.0 の間に収めてください。これを超える範囲の値は、前述の範囲内の一番近い値に書き換えられます。 * 振幅は 0.0 から 1.0 の範囲内に収めてください。これを超える範囲の値は、前述の範囲内に一番近い値に書き換えられます。 -->"
  },
  "Manual/Input/Keyboard.html": {
    "href": "Manual/Input/Keyboard.html",
    "title": "キーボード | Altseed2",
    "keywords": "キーボード Keyboard は キーボード入力に関する機能を提供します。 Keyboard Keyboard では次の機能を提供します。 キーボード入力の取得 基本的な呼び出し手順 Altseed2の Initialize を呼び出した後、Engine.Keyboard という形でKeyboardの各種メソッドを呼び出してください。 キー入力 サンプル using System; using Altseed2; namespace Sample { class Keyboard { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"Keyboard\", 640, 480); // 状態を出力するための TextNode を作成します。 // 詳細は TextNode のサンプルを参照してください。 var font = Font.LoadDynamicFont(\"./mplus-1m-regular.ttf\", 64); var textNode = new TextNode(); textNode.Font = font; textNode.FontSize = 40; while (Engine.DoEvents()) { var zState = Engine.Keyboard.GetKeyState(Key.Z); // Zキーが押されているかどうかを取得します。 if (zState == ButtonState.Free) { textNode.Text = \"Zキーを離しています。\"; } else if (zState == ButtonState.Hold) { textNode.Text = \"Zキーを押しています。\"; } else if (zState == ButtonState.Push) { textNode.Text = \"Zキーを押しました！\"; } else if (zState == ButtonState.Release) { textNode.Text = \"Zキーを離しました！\"; } Engine.Update(); } Engine.Terminate(); } } } カーソルの座標の取得・設定は以下のプロパティを通して行います。 GetKeyState 戻り値は ButtonState です。 CursorMode Normal ... デフォルト値 Hidden ... カーソル非表示の状態 Disable ... カーソルの入力が無効の状態。カーソルがウィンドウ中央にロックされます。"
  },
  "Manual/Input/Mouse.html": {
    "href": "Manual/Input/Mouse.html",
    "title": "マウス | Altseed2",
    "keywords": "マウス Mouse は マウス入力に関する基本的な機能を提供します。 Mouse Mouse では次の機能を提供します。 マウスカーソルの座標を取得・設定 マウスボタンの状態を取得 マウスホイールの回転量を取得を取得 カーソルモードの取得または設定 基本的な呼び出し手順 Altseed2の Initialize を呼び出した後、Engine.Mouse という形でMouseの各種メソッドを呼び出してください。 Note MouseButton や ButtonState は Mouseには含まれていません。 カーソル座標 サンプル using System; using Altseed2; namespace Sample { class Mouse { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"Mouse\", 640, 480); // 状態を出力するための TextNode を作成します。 // 詳細は TextNode のサンプルを参照してください。 var font = Font.LoadDynamicFont(\"./mplus-1m-regular.ttf\", 64); var textNode = new TextNode(); textNode.Font = font; textNode.FontSize = 40; Engine.AddNode(textNode); while (Engine.DoEvents()) { // マウスの左ボタンが押されているかどうかを取得します。 if (Engine.Mouse.GetMouseButtonState(MouseButton.ButtonLeft) == ButtonState.Hold) { textNode.Text = \"左ボタンが押されています。\"; } else { textNode.Text = \"左ボタンが押されていません。\"; } // マウスの座標を取得します。 Vector2F position = Engine.Mouse.Position; textNode.Text += $\"\\nポジション(x/y): {position.X} / {position.Y}\"; // マウスホイールの値を取得します。 textNode.Text += $\"\\nホイール : {Engine.Mouse.Wheel}\"; // マウスモードを取得します。 textNode.Text += $\"\\nモード : {Engine.Mouse.CursorMode}\"; Engine.Update(); } Engine.Terminate(); } } } カーソルの座標の取得・設定は以下のプロパティを通して行います。 [Position](xref:Altseed2.Mouse.Position 戻り値は Vector2F です。 マウスボタン サンプル using System; using Altseed2; namespace Sample { class Mouse { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"Mouse\", 640, 480); // 状態を出力するための TextNode を作成します。 // 詳細は TextNode のサンプルを参照してください。 var font = Font.LoadDynamicFont(\"./mplus-1m-regular.ttf\", 64); var textNode = new TextNode(); textNode.Font = font; textNode.FontSize = 40; Engine.AddNode(textNode); while (Engine.DoEvents()) { // マウスの左ボタンが押されているかどうかを取得します。 if (Engine.Mouse.GetMouseButtonState(MouseButton.ButtonLeft) == ButtonState.Hold) { textNode.Text = \"左ボタンが押されています。\"; } else { textNode.Text = \"左ボタンが押されていません。\"; } // マウスの座標を取得します。 Vector2F position = Engine.Mouse.Position; textNode.Text += $\"\\nポジション(x/y): {position.X} / {position.Y}\"; // マウスホイールの値を取得します。 textNode.Text += $\"\\nホイール : {Engine.Mouse.Wheel}\"; // マウスモードを取得します。 textNode.Text += $\"\\nモード : {Engine.Mouse.CursorMode}\"; Engine.Update(); } Engine.Terminate(); } } } スティックの取得には以下のメソッドを用います。 GetMouseButtonState 戻り値は ButtonState です。 マウスホイール サンプル using System; using Altseed2; namespace Sample { class Mouse { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"Mouse\", 640, 480); // 状態を出力するための TextNode を作成します。 // 詳細は TextNode のサンプルを参照してください。 var font = Font.LoadDynamicFont(\"./mplus-1m-regular.ttf\", 64); var textNode = new TextNode(); textNode.Font = font; textNode.FontSize = 40; Engine.AddNode(textNode); while (Engine.DoEvents()) { // マウスの左ボタンが押されているかどうかを取得します。 if (Engine.Mouse.GetMouseButtonState(MouseButton.ButtonLeft) == ButtonState.Hold) { textNode.Text = \"左ボタンが押されています。\"; } else { textNode.Text = \"左ボタンが押されていません。\"; } // マウスの座標を取得します。 Vector2F position = Engine.Mouse.Position; textNode.Text += $\"\\nポジション(x/y): {position.X} / {position.Y}\"; // マウスホイールの値を取得します。 textNode.Text += $\"\\nホイール : {Engine.Mouse.Wheel}\"; // マウスモードを取得します。 textNode.Text += $\"\\nモード : {Engine.Mouse.CursorMode}\"; Engine.Update(); } Engine.Terminate(); } } } マウスホイールの回転量を取得するには以下のプロパティを使用します。 Wheel 戻り値は-1~1の範囲の float です。 カーソルモード CursorModeを取得・設定するには、以下のプロパティを使用します。 CursorMode カーソルモードの設定は CursorMode の中から行ってください。 CursorMode Normal ... デフォルト値 Hidden ... カーソル非表示の状態 Disable ... カーソルの入力が無効の状態。カーソルがウィンドウ中央にロックされます。 カーソル画像 カーソル画像を指定するには、以下のメソッドを使います。 SetCursorImage 第一引数に、設定したい画像を読み込んだ カーソル オブジェクトを渡します。"
  },
  "Manual/Log/Log.html": {
    "href": "Manual/Log/Log.html",
    "title": "ログ | Altseed2",
    "keywords": "ログ Log クラスは、コンソールやファイルにログを出力する機能です。 Altseedの内部で発生したエラーなどはこの機能でコンソールやファイルへ出力されます。 以下のように記述して使用します。 Engine.Debug(LogCategory.User, \"\"); LogLevel 列挙体の名前に応じたメソッドが用意されています。 Log クラスの SetLevel メソッドを利用して、 LogCategory 別にログを出力時の最低レベルを指定することができます。 コンソールへのログやファイルへのログを有効化するには、 Engine の初期化時に渡す Configuration のプロパティを指定します。 ConsoleLoggingEnabled : コンソールへのログ出力を有効にするかどうか FileLoggingEnabled : ファイルへのログ出力を有効にするかどうか LogFileName : ログ出力する際のファイル名"
  },
  "Manual/Media/MediaPlayer.html": {
    "href": "Manual/Media/MediaPlayer.html",
    "title": "MediaPlayer | Altseed2",
    "keywords": "MediaPlayer MediaPlayer クラスは、映像を再生する機能です。 h264の映像を読み込み、テクスチャに出力します。 パッケージ機能には対応しておらず、映像はパッケージの外に置く必要があります。 以下のように記述して映像を出力します。 using System; using Altseed2; namespace Sample { class Movie { [STAThread] static void Main(string[] args) { // Altseed2 を初期化します。 if (!Engine.Initialize(\"Movie\", 640, 480)) return; // 空のテクスチャを作成します。 var texture = Texture2D.Create(new Vector2I(640, 480)); // 映像を読み込みます。 var mediaPlayer = MediaPlayer.Load(@\"TestData/Movie/Test1.mp4\"); // 映像を再生します。 mediaPlayer.Play(false); // スプライトを描画するノードを作成します。 var node = new SpriteNode(); // テクスチャを設定します。 node.Texture = texture; // ノードを登録します。 Engine.AddNode(node); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // 現在の映像を画像に書き込みます。 mediaPlayer.WriteToTexture2D(texture); // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } }"
  },
  "Manual/Node.html": {
    "href": "Manual/Node.html",
    "title": "ノード | Altseed2",
    "keywords": "ノード Altseed2では、ゲームに登場する キャラクター等のオブジェクト 、及び オブジェクトが持つ機能 等をノードとして管理します。 例えばゲームに画像を表示する際には、描画機能を持ったノード( SpriteNode )をエンジンに追加します。 ノードは親子関係の階層構造を持ちます。また、ノードはエンジンに実装されているものを使うだけでなく、独自に継承・拡張して利用することができます。 Note 初代Altseedにおけるシーンやレイヤーはノード機能にまとめられました。 同様の感覚で利用したい場合、Nodeクラスを継承したSceneクラスやLayerクラスを自作すると良いでしょう。 また、Unity等でも用いられているコンポーネントの機能もノードによって実現できます。 Tip 便宜上ノードの追加・削除という表現をしていますが、ノードインスタンスの作成・削除とは直接関係が有りません。 必要に応じて、登録・登録解除と読み替えてください。 Node Node は全てのノードの基本です。全てのノードはこのNodeを継承する必要があります（もちろん SpriteNode 等のNodeを継承したクラスをさらに継承しても構いません）。 使い道は主に以下の二つです。 ノードを自作する場合に、継承して使う。 複数のノードをまとめて管理したい場合に、親ノードとして利用する。 エンジンへの追加は Engine.AddNode メソッドを使います。逆に削除したい場合は、 Engine.RemoveNode メソッドを使います。 親子関係の追加・削除も同様に、 AddChildNode メソッド、 RemoveChildNode メソッドを使います。 Important ノードは作成だけしても、エンジンに登録されていなければ 更新されません 。 また、親ノードがエンジンに追加されている場合、子ノードも自動的に更新対象になります。 Note Nodeを新たに追加しても、親子構造が反映されるのは次の更新処理時（＝1フレーム後）になります。 サンプル Nodeの作成と親子関係の構築 <!-- [!code-csharp[Main](../../Src/Samples/CreatingNode.cs)] -->"
  },
  "Manual/Physics/Collision.html": {
    "href": "Manual/Physics/Collision.html",
    "title": "衝突判定 | Altseed2",
    "keywords": "衝突判定 Altseed2では物理演算を用いて，2Dの衝突判定を行う機構が備わっています。 Collider クラス Collider クラスは自身のメンバの情報をもとに他 Collider のインスタンスとの衝突の有無を判定します。 Collider と衝突判定の種類は以下の通りです。 Collider 衝突判定のタイプ 使用するメンバ CircleCollider 円形 中心 ， 半径 PolygonCollider 多角形 各頂点の座標 RectangleCollider 短形 左上の座標 ， サイズ(縦・横) EdgeCollider 線分 端点1 ， 端点2 Collider との衝突判定は GetIsCollidedWith(Collider) メソッドを使用します。 指定したコライダと衝突していたらtrue，衝突していなかったらfalseを返します。 ColliderNode クラスと CollisionManagerNode クラス この2つのクラスによって，コライダの衝突判定を自動で行う事が出来ます。 ColliderNode クラス このクラスは Collider クラスを内部に持っています。 また，この派生クラスに CircleColliderNode ， PolygonColliderNode ， RectangleColliderNode , EdgeColliderNode クラスがあり，それぞれ CircleCollider ， PolygonCollider ， RectangleCollider , EdgeCollider クラスのインスタンスを内部に持っています。 これらのクラスのプロパティを通して，内部コライダのメンバの操作を行う事が出来ます。 Important このクラスは，衝突判定を行いたいノード(シューティングゲームで言う自機や弾となるノード)の 子ノードとして 使用される必要があります。 CollisionManagerNode クラス このクラスでは ColliderNode クラスのインスタンスが自動的に登録され， GetIsCollidedWith(Collider) メソッドを自動的に実行します。 Tip GetIsCollidedWith(Collider) メソッドによる衝突判定は，同じ ColliderNode の組み合わせに対して1フレームにつき1度しか行われません。 Important このクラスは衝突判定を行いたいノードの 親ノードの子として 使用される必要があります。 また，1つのノードに対して， CollisionManagerNode クラスのインスタンスは1つしか子として持つ事が出来ません。(登録しようとした場合は例外がスローされます。) 実装の形式 ColliderNode クラスと CollisionManagerNode クラスはそれぞれ以下の図のような関係でなければなりません。 Caution ColliderNode の自動登録には，シーンとなるノードに対して， CollisionManagerNode が子ノードであり，かつ ColliderNode が孫ノードである 事が重要です。 それ以外の場合における ColliderNode の自動的な追加/削除は発生しません。 Note 衝突判定を行うノードが ICollisionEventReceiver インターフェイスを実装している場合， 衝突の開始 衝突の継続 衝突の終了 においてそれぞれ対応したメソッドが呼び出されます。 以上の点を踏まえた実装は以下のサンプルコードの通りです。 using Altseed2; using System; namespace Sample { class Collision { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"Collision\", 640, 480); // 衝突判定が行われるノードの親ノードを作成します。 var scene = new Node(); // コライダを自動処理するノードをシーンに登録します。 scene.AddChildNode(new CollisionManagerNode()); // 衝突判定を持つスプライトノードを生成します。 var node1 = new CollidableSprite() { Position = new Vector2F(0, 100) }; // 衝突時のイベントを実行する衝突判定を持つスプライトノードを生成します。 var node2 = new EventRaisedCollidableSprite() { Position = new Vector2F(300, 100) }; // エンジンにノードを追加します。 scene.AddChildNode(node1); scene.AddChildNode(node2); Engine.AddNode(scene); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // 右側に移動させる node1.Position += new Vector2F(5, 0); // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } // 衝突判定が行われるノードのクラス class CollidableSprite : SpriteNode { // 円形コライダを持つノード private readonly CircleColliderNode colliderNode = new CircleColliderNode(); // コンストラクタ public CollidableSprite() { // テクスチャを読み込みます。 Texture = Texture2D.Load(@\"TestData/IO/AltseedPink256.png\"); // 半径を設定します。 colliderNode.Radius = Texture.Size.X / 2; // 中心を設定します。 CenterPosition = Texture.Size / 2; // コライダを登録します。 AddChildNode(colliderNode); } } // 衝突時の内容を実装できるクラス class EventRaisedCollidableSprite : CollidableSprite, ICollisionEventReceiver { // 衝突が開始された時に実行されます。 void ICollisionEventReceiver.OnCollisionEnter(CollisionInfo info) { Color = new Color(255, 50, 50); } // 衝突が継続している時に実行されます。 void ICollisionEventReceiver.OnCollisionStay(CollisionInfo info) { Angle++; } // 衝突が解除された時に実行されます。 void ICollisionEventReceiver.OnCollisionExit(CollisionInfo info) { Color = new Color(255, 255, 255); } } } 結果 衝突を開始したときに色が赤くなり，以降衝突している間回転します。 衝突終了時には色が戻ります。 衝突範囲の描画 ColliderVisualizeNodeFactory.Create(ColliderNode) を使用することで，衝突領域を描画できるノードを取得できます。 Important 得られたノードを， Node.AddChildNode(Node) で登録しなければ衝突判定の視覚化は行われません。 生成元の ColliderNode を CollisionManagerNode の子にすることで，描画範囲を衝突範囲に同期することが出来ます。 Caution 衝突範囲の描画の同期は，元となる ColliderNode が CollisionManagerNode の管理下にある必要があります。 使い方は以下のサンプルコードを参考にしてください。 using Altseed2; namespace Sample { class ColliderVisualization { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"Collision\", 640, 480); // 衝突判定が行われるノードの親ノードを作成します。 var scene = new Node(); // コライダを自動処理するノードをシーンに登録します。 scene.AddChildNode(new CollisionManagerNode()); // 衝突判定を持つSpriteNodeを生成します。 var texture = Texture2D.Load(@\"TestData/IO/AltseedPink256.png\"); var sprite = new SpriteNode() { Position = new Vector2F(200f, 200f), Scale = new Vector2F(0.5f, 0.5f), Texture = texture, CenterPosition = texture.Size / 2, }; // 円形コライダノードを生成します。 var collider = new CircleColliderNode() { Radius = texture.Size.X / 2, }; // colliderの衝突判定を視覚化できるノードを生成します。 var visualizer = ColliderVisualizeNodeFactory.Create(collider); // エンジンにノードを追加します。 scene.AddChildNode(sprite); sprite.AddChildNode(collider); collider.AddChildNode(visualizer); Engine.AddNode(scene); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } } このコードを実行すると以下のように円形の当たり判定が赤色で示されます。"
  },
  "Manual/Profiler/Profiler.html": {
    "href": "Manual/Profiler/Profiler.html",
    "title": "プロファイラ | Altseed2",
    "keywords": "プロファイラ Profiler クラスは、処理時間を測定する機能です。 指定した範囲の処理が実行された時間及びタイミングを取得します。 この機能は easy_profiler を使用します。 以下のように記述して情報を出力します。 Engine.Profiler.StartCapture(); { using var block1 = new ProfilerBlock(\"Block1\", new Color(255, 0, 0)); System.Threading.Thread.Sleep(500); { using var block2 = new ProfilerBlock(\"Block2\", new Color(0, 255, 0)); System.Threading.Thread.Sleep(500); } } Engine.Profiler.DumpToFileAndStopCapture(\"Profiler.prof\"); それをeasy_profilerのReleaseからエディタをダウンロードし、出力されたファイルを読み込みます。 ファイルに出力しなくとも、リモートからネットワーク経由で情報を取得することもできます。 以下のコードでネットワークを有効にし、easy_profilerのエディタから接続します。 Engine.Profiler.StartListen(28077);"
  },
  "Manual/Serialization/Serialization.html": {
    "href": "Manual/Serialization/Serialization.html",
    "title": "シリアライズ | Altseed2",
    "keywords": "シリアライズ Altseed2では一部を除き，殆どのクラス・構造体がバイナリシリアライズに対応しています。 Warning XMLシリアライズやJsonシリアライズには対応していません。 Important Altseed2のバージョンが変わってシリアライズ内容やフィールド情報が変わった場合，デシリアライズに失敗する可能性があります。 Altseed2のバージョンを差し替えるときはご注意ください。 シリアライズ非対応のクラス 以下のクラスはシリアライズに対応していません。 これらは Engine クラスにてシングルトンとしてインスタンスが提供されているクラスです。 BuiltinShader CommandList Easing File Glyph Graphics JoyStick JoyStickInfo KeyBoard Log Mouse SoundMixer Tool 使い道 Altseed2を用いたアプリケーションを制作する際にデータの保存や読み込み UIのノードを予め作っておいて読み込む 等があります。 サンプル(シリアライズの手順) シリアライズには System.Runtime.Serialization.Formatters.Binary.BinaryFormatter を使用します。 以下に， StaticFile のシリアライズを例にシリアライズ/デシリアライズの手順を示します。 using System; using System.IO; using System.Runtime.Serialization.Formatters.Binary; using System.Text; using Altseed2; namespace Sample { class Serialization { [STAThread] static void Main(string[] args) { // Altseed2 を初期化します。 if (!Engine.Initialize(\"Serialization\", 640, 480)) return; // シリアライズ結果を保存するファイルのパス var path = \"SerializeSample.bin\"; // StaticFileを生成。 var file1 = StaticFile.Create(@\"TestData/IO/test.txt\"); // fileをシリアライズします。 Serialize(path, file1); // シリアライズされたfileをデシリアライズします。 var file2 = (StaticFile)DeSerialize(path); // バイト配列をUTF8として、string型に変換します。 var text1 = Encoding.UTF8.GetString(file1.Buffer); var text2 = Encoding.UTF8.GetString(file2.Buffer); // テキストをコンソールに出力します。 Console.WriteLine(\"text1 : {0}\", text1); Console.WriteLine(\"text2 : {0}\", text2); // Altseed の終了処理をします。 Engine.Terminate(); } // シリアライズを行うメソッド static void Serialize(string path, object value) { // バイナリシリアライズに使用するフォーマッターを生成。 var formatter = new BinaryFormatter(); // シリアライズに使用するストリームを生成。 using var stream = new FileStream(path, FileMode.Create); // valueをシリアライズする。 formatter.Serialize(stream, value); } // デシリアライズを行うメソッド static object DeSerialize(string path) { // バイナリデシリアライズに使用するフォーマッターを生成。 var formatter = new BinaryFormatter(); // デシリアライズに使用するストリームを生成。 using var stream = new FileStream(path, FileMode.Open); // デシリアライズを実行 var result = formatter.Deserialize(stream); // デシリアライズの結果を返す。 return result; } } } 結果は以下のようになります。 text1 : Test text2 : Test"
  },
  "Manual/ShapeNode/ShapeNode.html": {
    "href": "Manual/ShapeNode/ShapeNode.html",
    "title": "図形ノード | Altseed2",
    "keywords": "図形ノード Altseed2には図形を描画するノードが存在します。 描画できる図形は円弧，円，直線，短形，三角形があります。 円の描画 円の描画は CircleNode で行う事が出来ます。 設定できる情報と対応するプロパティは以下の通りです。 設定できる情報 対応するプロパティ 備考 中心座標 Position 半径 Radius 頂点の数 VertNum 3以上にしなければならない。 VertNum を調整する事で，三角形や五角形など正多角形を描画出来ます。 円にしたければ頂点の数を増やすと良いでしょう。 円弧の描画 円弧の描画は ArcNode で行う事が出来ます。 ArcNode では CircleNode の内容に加えて，描画をする角度の範囲を設定できます。 設定できる情報と対応するプロパティは以下の通りです。 設定できる情報 対応するプロパティ 備考 中心座標 Position 半径 Radius 頂点の数 VertNum 3以上にしなければならない。 描画開始角度 StartDegree 描画終了角度 EndDegree Note StartDegree と EndDegree の値はそれぞれ-360～360の間に自動的に修正されます， その差も360までに自動的に修正されます。 StartDegree と EndDegree の大小に指定はありません。 直線の描画 直線の描画は LineNode で行う事が出来ます。 設定できる情報と対応するプロパティは以下の通りです。 設定できる情報 対応するプロパティ 端点1 Point1 端点2 Point2 太さ Thickness 短形の描画 短形の描画は RectangleNode で行う事が出来ます。 設定できる情報と対応するプロパティは以下の通りです。 設定できる情報 対応するプロパティ 備考 左上頂点の座標 Position サイズ RectangleSize Texture.Sizeに関係なくこのプロパティの値で決定。 三角形の描画 三角形の描画は TriangleNode で行う事が出来ます。 設定できる情報と対応するプロパティは以下の通りです。 設定できる情報 対応するプロパティ 頂点1 Point1 頂点2 Point2 頂点3 Point3 サンプルコード サンプルコードは以下の通りです。 using Altseed2; namespace Sample { class ShapeNode { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"ShapeNode\", 640, 480); // 円を描画するノード var circle = new CircleNode() { Color = new Color(255, 100, 100), Radius = 30f, Position = new Vector2F(100f, 300f), VertNum = 30 }; // 円弧を描画するノード var arc = new ArcNode() { Color = new Color(100, 255, 100), Radius = 25f, Position = new Vector2F(300f, 100f), StartDegree = 30f, EndDegree = 150f, VertNum = 30 }; // 直線を描画するノード var line = new LineNode() { Color = new Color(100, 100, 255), Point1 = new Vector2F(200f, 150f), Point2 = new Vector2F(400f, 350f), Thickness = 5f }; // 短形を描画するノード var rectangle = new RectangleNode() { Color = new Color(255, 255, 100), Position = new Vector2F(300f, 400f), RectangleSize = new Vector2F(50f, 50f) }; // 三角形を描画するノード var triangle = new TriangleNode() { Color = new Color(255, 100, 255), Point1 = new Vector2F(50f, 50f), Point2 = new Vector2F(100f, 50f), Point3 = new Vector2F(50f, 100f), }; // エンジンにノードを追加します。 Engine.AddNode(circle); Engine.AddNode(arc); Engine.AddNode(line); Engine.AddNode(rectangle); Engine.AddNode(triangle); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseed を更新します。 Engine.Update(); } // Altseed の終了処理をします。 Engine.Terminate(); } } } これを実行するとこのように図形が描画されます。"
  },
  "Manual/Sound/Sound.html": {
    "href": "Manual/Sound/Sound.html",
    "title": "サウンド | Altseed2",
    "keywords": "サウンド サウンドを再生するには、 Load メソッドを用いてサウンドファイルを読み込み Sound インスタンスを作成します。次に Engine.Sound.Play メソッドを用いて Sound インスタンスを再生します。 このとき返される ID や、ID を用いて再生中のサウンドを操作する機能について解説します。 Sound Sound はサウンドファイルを読み込んで生成される音源の情報を表すデータです。 サウンドファイルを読み込んで Sound インスタンスを生成するには Load メソッドを使います。 この時、事前に音のデータを解凍するかどうかを指定できます。 OGG等のフォーマットでは、音のデータが圧縮された状態で格納されているため、音を再生前にデータを解凍しなければなりません。 読み込み時に音のデータを解凍しなかった場合、再生しながらリアルタイムに解凍することになります。 Important 音のデータをを事前に解凍するか、再生中にリアルタイムに解凍するかによって、消費するメモリやCPUへの負荷が異なります。 事前に解凍する場合、読み込み時間は長くなりメモリも消費しますが再生時のCPUへの負荷は小さくなります。 一方、再生中にリアルタイムに解凍する場合は、読み込み時間もメモリも小さくなりますが、再生時に若干CPUの処理を必要とします。 基本的に、音が長い BGMは圧縮したまま 、音が短くたくさん鳴らす 効果音は事前に解凍 して読み込みます。 サウンドはループさせることが可能です。サウンドをループさせるには IsLoopingMode を true にします。 ループする範囲は LoopStartingPoint や LoopEndPoint を設定することでを設定でき、 ループする範囲を設定していない場合、音を最後まで再生したら最初に戻ってループします。 LoopStartingPoint や LoopEndPoint を設定すると、先頭から音を再生し、 LoopEndPoint に到達したら LoopStartingPoint の位置に戻ることを繰り返します。 SoundMixer 音の再生・停止・その他操作を行う機能を提供します。音を再生する際に使用します。 音を再生するには Play メソッドを使用します。このメソッドを実行すると、再生される音に対応するIDが返されます。 SoundMixer クラスの各メソッドに、このIDを渡すことで再生されている音に対して操作をすることができます。 SoundMixer クラスで行える操作は次の通りです。 音の停止・一時停止・再開 音量の変更・フェードイン/アウト 再生速度・パン位置・再生位置の取得・変更 スペクトル情報の取得 Tip Altseedでは、再生されている音に対する操作をIDを通して行っています。これは、音のデータそのものとは別に、音の再生情報に関するデータを管理するためです。 音のデータが再生情報を含んでいる場合、同じ音を二重に再生することができません。 Tip BGMなどを除き、再生中に停止などの操作を行うことは稀です。そのため再生の度に、再生情報を含むインスタンスを生成することは無駄が大きいため、都度IDを用いて操作する仕組みになっています。 スペクトル情報の取得 SoundMixer クラスにはメディアアートのための機能として、スペクトルアナライザが実装されています。 GetSpectrumData メソッドを使用することで、再生中の音声のスペクトル情報を取得し、それを使って独自のサウンドビジュアライザを作ることができます。 Tip 音は波としての性質を持ちます。スペクトルアナライザでは、その波のデータに対して、どの周波数の成分の波形がどれくらいの量含まれているかを解析します。解析する手法としてフーリエ変換が用いられています。 サンプル 効果音の再生 using System; using Altseed2; namespace Sample { class SoundSE { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"Sound_SE\", 640, 480); // 音ファイルを読み込みます。 // 効果音の場合は第2引数を true に設定して事前にファイルを解凍することが推奨されている。 var se = Sound.Load(@\"TestData\\Sound\\se1.wav\", true); // 音を再生します。 var id = Engine.Sound.Play(se); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseedを更新します。 Engine.Update(); // 音の再生が終了しているか調べる。 if (!Engine.Sound.GetIsPlaying(id)) { break; } } // Altseed の終了処理をします。 Engine.Terminate(); } } } BGMの再生 using System; using Altseed2; namespace Sample { class SoundBGM { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"Sound_BGM\", 640, 480); // 音ファイルを読み込みます。 // 効果音の場合は第2引数を true に設定して再生しながら解凍することが推奨されている。 var bgm = Sound.Load(@\"TestData\\Sound\\bgm1.ogg\", false); // 音を再生します。 var id = Engine.Sound.Play(bgm); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseedを更新します。 Engine.Update(); // 音の再生が終了しているか調べる。 if (!Engine.Sound.GetIsPlaying(id)) { break; } } // Altseed の終了処理をします。 Engine.Terminate(); } } } BGMのループ再生 using System; using Altseed2; namespace Sample { class SoundLoop { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"Sound_Loop\", 640, 480); // 音ファイルを読み込みます。 // 効果音の場合は第2引数を true に設定して再生しながら解凍することが推奨されている。 var bgm = Sound.Load(@\"TestData\\Sound\\bgm1.ogg\", false); // 音のループモードを有効にします。 bgm.IsLoopingMode = true; // ループの始端を1秒に、終端を2.5秒にします。 bgm.LoopStartingPoint = 1.0f; bgm.LoopEndPoint = 2.5f; // 音を再生します。 var id = Engine.Sound.Play(bgm); // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseedを更新します。 Engine.Update(); // 音の再生が終了しているか調べる。 if (!Engine.Sound.GetIsPlaying(id)) { break; } } // Altseed の終了処理をします。 Engine.Terminate(); } } } スペクトル情報の取得 using System; using Altseed2; namespace Sample { class SoundSpectrum { static void Main(string[] args) { // Altseed2 を初期化します。 Engine.Initialize(\"Sound_BGM\", 640, 480); // 音ファイルを読み込みます。 // 効果音の場合は第2引数を true に設定して再生しながら解凍することが推奨されている。 var bgm = Sound.Load(@\"TestData\\Sound\\bgm1.ogg\", false); // 音を再生します。 var id = Engine.Sound.Play(bgm); // スペクトルバーのインスタンスを1024個作成します。 var spectrumBars = new PolygonNode[1024]; for (int i = 0; i < 1024; ++i) { // ※ 640 / 1024 = 0.625 var spectrumBar = new PolygonNode(); spectrumBar.Position = new Vector2F(i * 0.625f, 1.0f); Span<Vector2F> vertexes = stackalloc Vector2F[4] { new Vector2F(0.0f, 480.0f), new Vector2F(0.0f, 480.0f), new Vector2F(0.625f, 480.0f), new Vector2F(0.625f, 480.0f), }; spectrumBar.SetVertexes(vertexes, new Color(255, 255, 255)); spectrumBars[i] = spectrumBar; Engine.AddNode(spectrumBar); } // メインループ。 // Altseed のウインドウが閉じられると終了します。 while (Engine.DoEvents()) { // Altseedを更新します。 Engine.Update(); // 再生されている音のスペクトル情報を取得します。 // データの長さは2のn乗でなくてはなりません。 var spectrum = Engine.Sound.GetSpectrum(id, 1024, FFTWindow.Rectangular); // 取得したスペクトル情報をスペクトルバーに反映させます。 for (int i = 0; i < 1024; ++i) { Span<Vector2F> vertexes = stackalloc Vector2F[] { new Vector2F(0.0f, 480.0f), new Vector2F(0.0f, 480.0f - spectrum[i]), new Vector2F(0.625f, 480.0f - spectrum[i]), new Vector2F(0.625f, 480.0f), }; spectrumBars[i].SetVertexes(vertexes, new Color(255, 255, 255)); } // 音の再生が終了しているか調べる。 if (!Engine.Sound.GetIsPlaying(id)) { break; } } // Altseed の終了処理をします。 Engine.Terminate(); } } }"
  },
  "Manual/Transition/Transition.html": {
    "href": "Manual/Transition/Transition.html",
    "title": "トランジション | Altseed2",
    "keywords": "トランジション トランジションとは、画面効果を演出しながら時間をかけて画面を切り替える機能を指します。 トランジションは、例えばフェードアウト・フェードインといった画面効果を与えます。 TransitionNode を使用することで、トランジションを導入することができます。 TransitionNode トランジションを担当するノードです。 このノードは、トランジション効果を演出するとともに、指定されたノードの入れ替えを行います。 コンストラクタの引数には、削除するノードと新しく追加するノード、そしてノードが入れ替わる前後の期間を指定します。 TransitionNode がエンジンに追加されると、 自動的にトランジションが開始されます。 また、トランジションが終了すると、 自動的にエンジンから削除されます。 ノードの入れ替えでは、下図のように、削除されたノードの親に新しくノードを追加するような形で行われます。 TransitionNode を継承する事で、独自のトランジションを作成する事ができます。 継承したクラスでは、以下の処理をオーバーライドできます。 トランジションが開始した瞬間の処理( OnTransitionBegin メソッド) ノードが入れ替わるまでに継続して行われる処理( OnClosing メソッド) ノードが入れ替わる瞬間の処理( OnNodeSwapped メソッド) トランジションが終了するまでに継続して行われる処理( OnOpening メソッド) トランジションが終了した瞬間の処理( OnTransitionEnd メソッド) なお、ノードの入れ替えは TransitionNode が自動で行う為、これらのメソッドの中にノードを入れ替える処理を記述する必要はありません。 Important TransitionNode をエンジンに追加しても、すぐにノードが入れ替わるわけではありません。 トランジションが実行されている間にノードの入れ替えをすると、予期せぬ挙動が発生する可能性があります。 Important TransitionNode を、削除予定のノードの子孫ノードにしないでください。 ノードは入れ替わりますが、その瞬間トランジションの演出が停止します。 RuledTransitionNode 画面遷移演出を自作する手間を省きたい場合は、こちらを使用します。 このノードは、ルール画像を用いたトランジション機能を提供します。 ルール画像とは、その名の通りトランジションのルールを規定するものです。 一般的には白黒の画像であり、適用すると白い部分から先に画面が切り替わります。 コンストラクタの引数には、 RuledTransitionState クラスのインスタンスを2つ、そして任意で上から被せるテクスチャを指定します。 上から被せるテクスチャを指定しなかった場合、代わりにノードが追加されたときのの描画情報が、テクスチャとして渡されます。 RuledTransitionNode がエンジンに追加されると、まず画面が指定されたテクスチャの画像に置き換わります。 完全に置き換わった瞬間、指定されたノードが入れ替わります。 その後、テクスチャの画像が少しずつ消えていき、最後にノードが入れ替わった後の新しい描画情報が画面に表示されます。 RuledTransitionState RuledTransitionNode のコンストラクタの引数に指定するインスタンスのクラスです。 RuledTransitionState クラスは、以下をプロパティに持ちます。 TargetNode : 操作を加えるノードを表します。 1つ目の引数にするときは 削除するノード を、2つ目の引数にするときは 新しく追加するノード を指定してください。 Duration : ノードが入れ替わる前後の期間を表します。 1つ目の引数にするときは ノードが入れ替わるまでの期間 を、2つ目の引数にするときは ノードが入れ替わった後の期間 を指定してください。 RuleTexture : トランジションに使用するルール画像を指定します。 Softness : 画面の変化がどれだけ柔らかくなるかを指定します。 この値が0に近ければ近いほど、画面がシャープに切り替わります。"
  },
  "Tutorials/Chap0/index.html": {
    "href": "Tutorials/Chap0/index.html",
    "title": "0章 : Altseed2 を初めよう | Altseed2",
    "keywords": "0章 : Altseed2 を初めよう チュートリアルを始める前に この章の目標は、C#とAltseed2を使って開発を進める前に、必要なツールを導入しておくことです。 ゲームに限らず、どんなアプリケーションを開発するにしても、そのための環境が必要になります。 ここでいう環境とは、アプリケーションを開発するために必要なツールやシステムの組み合わせのことを指します。 すなわち、ゲームを開発する準備段階として、開発に必要なツールを揃えておかなければなりません。 それでは早速必要なツールを導入してみましょう。 Visual Studioのインストール WindowsやMacで C#を使用してアプリケーションを開発するには、Visual Studioというツールが必要になります。 Visual Studioは、プログラムのソースコードから実行可能なアプリケーションを生成するツールです。 Visual Studioのインストーラは Visual Studioのウェブページ からダウンロードすることができます。 Windows の場合 まず「Visual Studio2019」の「コミュニティ」を選択し、インストーラをダウンロードしてください。 ダウンロードされたインストーラをクリックし、起動すると、次のようなウィンドウが出てきます。 「続行」をクリックしてください。 次に、Visual Studioをインストールするに際し、併せてインストールするものを選んでいきます。 Altseed2 を使った開発には「.NET Core」が必要です。 「.NET デスクトップ開発」と「.NET Core クロスプラットフォームの開発」にチェックをつけておきましょう。 インストールしたいものが決まったら「インストール」をクリックしましょう。 インストールが始まると、次のような画面が表示されます。 Visual Studioなるツールは、容量がとても大きいため、インストールに多くの時間を要します。 じっくり待ちましょう。 インストールが完了し、Visual Studioが起動すると、この画面が表示されるはずです。 ここまでできたら、晴れて Visual Studioの準備は完了となります。 なお、Visual Studioからサインインを求められることがあります。 ライセンス認証に必須ですが、今すぐ必要ということはないため、あとでやっておきましょう。 Mac の場合 まず「Visual Studio for Mac」を選択し、インストーラをダウンロードしてください。 ダウンロードされたインストーラをクリックし、起動すると、次のようなウィンドウが出てきます。 「Install Visual Studio for Mac」をクリックし、新しくウィンドウを表示させます。 暫く待って、このような画面が出たら「続行」をクリックします。 次に、Visual Studioをインストールするに際し、併せてインストールするものを選んでいきます。 Altseed2 を使った開発には「.NET Core」が必要です。 「.NET Core」にチェックをつけておきましょう。 インストールしたいものが決まったら「インストール」をクリックしましょう。 インストールが始まると、次のような画面が表示されます。 Visual Studioなるツールは、容量がとても大きいため、インストールに多くの時間を要します。 じっくり待ちましょう。 インストール中にパスワードの入力が求められることがあります。 その場合は、Mac にログインするときのパスワードを入力しましょう。 インストールが完了し、Visual Studioが起動すると、この画面が表示されるはずです。 ここまでできたら、晴れて Visual Studioの準備は完了となります。 なお、Visual Studioからサインインを求められることがあります。 ライセンス認証に必須ですが、今すぐ必要ということはないため、あとでやっておきましょう。 また、キーボードの配置を選択する画面が出てきますが、デフォルトのままで問題ないでしょう。 プロジェクトの作成 インストールが終わったら、プロジェクトを作成します。 プロジェクトとは、実行可能なアプリケーションを作るために必要なファイルをまとめたものを指します。 基本的に、1 つのアプリケーションを作成するときに 1 つのプロジェクトが必要になります。 Windowsの場合 まず、Visual Studioを起動したら「新しいプロジェクトの作成」をクリックします。 次に、プロジェクトのテンプレートを決めます。 今回は、「コンソールアプリ (.NET Core)」を選択します。 ただし、今回は C#を使用するため、アイコンに「C#」と書かれていることを確認してください。 選択したら「次へ」をクリックします。 次に、プロジェクトの名前と、プロジェクトを作成する場所の設定を行います。 プロジェクトの名前は「Tutorial」などに設定しておくと良いでしょう。 それ以外の設定は変更しなくても問題ありません。 ただし、プロジェクトを作成した場所は、どこかに記録するなどして覚えておきましょう。 「作成」を押してしばらく待つと、この画面が出てきます。 これが、Visual Studioのエディタ画面です。 ここまで来たら、プロジェクトの作成は完了となります。 Macの場合 まず、Visual Studioを起動したら「新規」をクリックします。 次に、プロジェクトのテンプレートを決めます。 今回は、ウィンドウ左側のメニューの中から「.NET Core」の「アプリ」をクリック、その後、ウィンドウ中央のメニューの中から「全般」の「コンソールアプリケーション」をクリックしてください。 「C#▼」と書かれている部分をクリックすると、使用する言語を変更することができます。 しかし、今回は C#を使用するため、このままにしてください。 選択したら「次へ」をクリックします。 次に、プロジェクトの名前と、プロジェクトを作成する場所の設定を行います。 プロジェクトの名前は「Tutorial」などに設定しておくと良いでしょう。 それ以外の設定は変更しなくても問題ありません。 ただし、プロジェクトを作成した場所は、どこかに記録するなどして覚えておきましょう。 「作成」を押してしばらく待つと、この画面が出てきます。 これが、Visual Studioのエディタ画面です。 ここまで来たら、プロジェクトの作成は完了となります。 Altseed2 の導入 Altseed2 といった「拡張機能」も、導入しない限りは使うことができません。 Visual Studioには「NuGet」という、拡張機能を管理するアプリケーションが同梱されています。 今回はこのNuGetを使用してAltseed2を導入していきます。 Windows の場合 右側のソリューションエクスプローラから「依存関係」を右クリックして、「NuGetパッケージの管理」をクリックしてください。(ソリューションエクスプローラが表示されていない場合は、上のメニューバーの「表示」から「ソリューションエクスプローラ」をクリックしてください) すると、このような画面が表示されます。 左上の検索欄から「Altseed2」と入力してください。 すると、拡張機能の一覧に「Altseed2」が出てきます。 「Altseed2」を選択して、「インストール」をクリックしてください。 「インストール」をクリックすると、次のような画面が表示されます。 「OK」をクリックして、インストールを開始してください。 しばらく待つと、このような画面が表示されます。 「同意する」をクリックしてください。 インストールが終わり、ソリューションエクスプローラーの「依存関係」の「パッケージ」の下にAltseed2と表示されていれば、Altseed2 の導入も完了です。 Mac の場合 左側のメニューから「依存関係」をダブルクリックしてください。 すると、このような画面が表示されます。 左上の検索欄から「Altseed2」と入力してください。 すると、拡張機能の一覧に「Altseed2」が出てきます。 チェックボックスにチェックを入れて「パッケージの追加」をクリックしてください。 しばらく待つと、このような画面が表示されます。 「同意する」をクリックしてください。 このように、「Altseed2 は正常に追加されました。」という表示が出れば、Altseed2 の導入も完了です。 ゲームに使用する画像や音声を用意する さて、これでゲームを開発するために必要最低限のツールは全て出揃いました。 これだけでゲームを作ってもいいのですが、より多彩な表現を盛り込むためには、画像や音声のファイルを用意する必要があります。 今回開発するゲームで使用する画像や音声は、下記のリンクからダウンロードすることができます。 リソースファイル まず、ダウンロードして得られたzipファイルを解凍します。 次に、解凍したzipファイルの中身を、指定した場所に配置します。 Windowsの場合は、 ~/source/repos/Tutorial/Tutorial/bin/Debug/netcoreapp3.1 に配置してください。 Macの場合は、 ~/Projects/Tutorial/Tutorial/bin/Debug/netcoreapp3.1 に配置してください。 このようにすることで、ゲームから画像や音声のデータを使用することができます。 まとめと次回予告 今回は、Visual Studio と Altseed2 の導入作業をしてきました。 「プロジェクトの作成」や「Altseed2 の導入」は、常にこの手順で行うため、覚えておくと吉です。 次回からいよいよ、シューティングゲームの開発を行っていきます。"
  },
  "Tutorials/Chap1/index.html": {
    "href": "Tutorials/Chap1/index.html",
    "title": "1章 : ウィンドウを表示してみよう | Altseed2",
    "keywords": "1章 : ウィンドウを表示してみよう この章の目標 この章の目標は、Altseed2を使ってウィンドウを表示することです。 プレイヤーや弾を描画する前に、そもそも「画像を表示するウィンドウ」がなければ何もできません。 そこで、最初にAltseed2を使ってウィンドウを表示してみましょう。 新たに導入する知識 本章で使用するC#の機能は下記のWebページに説明されています。 必要次第参照してください。 C# によるプログラミング入門 : コメント C# によるプログラミング入門 : 条件分岐 ここでは if 文を使用します。 C# によるプログラミング入門 : 反復処理 ウインドウの表示 0章でVisualStudioのセットアップができたと思います。 VisualStudioの右側にソリューションエクスプローラーと呼ばれるものがあると思います。 このProgram.csを開いてください。コードが表示されます。 ウィンドウを表示するプログラムは以下になります。 using Altseed2; using System; namespace Tutorial { class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } そのままコピーアンドペーストすると namespace が書き変わってしまうので namespace は変えないように気を付けてください。 コードですが using や namespace などよくわからない単語がありますが、この辺りはまだそこまで気にしなくていいです。気になる方はこちらを読んでください。 C# によるプログラミング入門 : 名前空間 上のコードを実行します。VisualStudio画面上部の開始ボタンを押すか F5 キーを押すことで実行することができます。 実行に成功すると以下のようなウィンドウが表示で来ると思います。 コードの解説をしていきます。 重要なのは Main の中です。C#では実行するとこのMainの中身が呼び出されます。ここが今回ウィンドウを表示させている部分です。 まず Engine.Initialize でAltseedの初期化をしています。 ここでウインドウに表示されるタイトルや画面サイズ、その他のオプション(フルスクリーンにするかどうか等)を設定できます。 この初期化はAltseedを使用する場合、必ず実行しなければいけません。 初期化に成功すると、ウインドウが表示されます。 今回は Engine.Initialize(\"Tutorial\", 960, 720); となっています \"Tutorial\" は表示されるウィンドウの名前、 960 は横幅、 720 は縦幅になります。 これでAltseedはWindowを表示してくれるのですが、それだけではすぐにプログラムが終了してしまうので、プログラムが終了しないように while ループでEngineを更新させてあげる必要があります。 while (Engine.DoEvents()) でウインドウが閉じられていないか確認することができます。 Engine.DoEvents メソッドはウインドウが閉じられていない場合、正( true )、閉じられた場合、否( false )を返します。 while は true が返され続ける限り、 {} の中身を何度も実行し、 false が返された場合、実行せずに {} の後に移動します。 ウインドウ右上の×ボタン等を押すと、 false を返し、 while の中身の実行を終了します。 while ループの中身を説明していきます。 Engine.Update() というものがあると思います。これを実行することで Altseed が更新を続けることができます。 もう一つ、Escキーを押したときにウィンドウを閉じる処理が書いてあります。 // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } Engine.Keyboard.GetKeyState はキーの状態、例えば、「押されている」「押されていない」などを返すメソッドです。ここではEscキーの状態を返します。 if は true が返されると {} の中身を実行します。ここではキーの状態が ButtonState.Push だったら {} の中身を実行します。 {} には break が書いてあります。これは while ループをその場で抜ける機能です。 while ループを抜けると、終了処理が実行されます。この時にウインドウが開いたままならば、自動的にウインドウを閉じます。 以下の通り ButtonState.Push 以外にも取得できるキーの状態があります。うまく組み合わせて使っていきましょう。 キーの状態 説明 ButtonState.Free キーを押していない状態 ButtonState.Hold キーを押している状態 ButtonState.Push Free から Hold に変わる瞬間の状態 ButtonState.Release Hold から Free に変わる瞬間の状態 まとめ 1章では一番基本となるWindowの表示を行いました。 2章ではウィンドウにキャラクターを描画していきます。"
  },
  "Tutorials/Chap10/index.html": {
    "href": "Tutorials/Chap10/index.html",
    "title": "10章 : いざ、公開準備 | Altseed2",
    "keywords": "10章 : いざ、公開準備"
  },
  "Tutorials/Chap2/index.html": {
    "href": "Tutorials/Chap2/index.html",
    "title": "2章 : キャラクターを描画してみよう | Altseed2",
    "keywords": "2章 : キャラクターを描画してみよう 前章では、ウィンドウを表示するところまで進みました。 この章では自機となるキャラクターを表示し、移動させるところまで進みます。 キャラクターの描写 まずは、キャラクターを表示してみましょう。 以下のコードを追加します。 using Altseed2; using System; namespace Tutorial { class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); + // 自機 + var player = new SpriteNode(); + // 自機のテクスチャを読み込む + player.Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); + // 自機の座標を設定 + player.Position = new Vector2F(100, 360); + // 自機の中心座標を設定 + player.CenterPosition = player.ContentSize / 2; + + // 自機をエンジンに追加 + Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } これを実行してみると、キャラクターが表示されているのが確認できると思います。 追加したコードのしていることは、15行目から順に SpriteNodeインスタンスを生成し、\"player\"に格納する。 自機の画像を読み込み、playerのテクスチャに設定する。 自機の座標を x: 100 / y: 360 に設定する。 自機の中心座標を、自機のテクスチャ画像サイズの縦横それぞれの半分だけずらした位置に設定する。 となります。 ちなみに、新しく登場した「インスタンス」という語については、以下を参考にすると良いでしょう。 C#によるプログラミング入門 : クラス Note 自機の中心座標 自機の中心座標は、自機画像の左上を原点(0,0)とした相対座標になります。デフォルトの中心座標は原点、つまり左上になります。 ここでやっている中心座標の操作は、キャラクターの移動や距離の計算等で色々不便になるため、中心座標を真ん中に持ってくるようにしています。 ここで ContentSize とありますが，これは自機のサイズを表します。この自機のサイズは読み込んだテクスチャのサイズが用いられます。 今後オブジェクトの大きさを取得したくなったら， サイズを取得したいオブジェクト.ContentSize としましょう。 キャラクターの移動 次は、表示したキャラクターを移動させてみましょう。 以下のコードを追加します。 using Altseed2; using System; namespace Tutorial { class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機 var player = new SpriteNode(); // 自機のテクスチャを読み込む player.Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 自機の座標を設定 player.Position = new Vector2F(100, 360); // 自機の中心座標を設定 player.CenterPosition = player.Texture.Size / 2; // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); + // ↑キーでY座標を減少 + if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) + { + player.Position -= new Vector2F(0.0f, 2.5f); + } // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } このコードを追加すると、キャラクターが画面上方向に進めるようになるはずです。 この追加したコードがしていることは、34行目から順に 上矢印キーの状態が、ホールド（押しっぱなし）の状態であるかどうかを確認。 上の条件が真であれば、\"player\"の座標(position)に x: 0.0 / y: -2.5 を足す。 ということです。 Note += って何？ 「+=」という見慣れない記号が気になった人もいるでしょう。 これは下の式と同じことを示しています。 player.Position = player.Position + new Vector2F(0.0f, -2.5f); プレイヤーの移動は、プログラム的にはプレイヤーの座標を書き換えつづけることで実現するわけですが、 移動は「今プレイヤーがいる座標を基準にして、そこから〇〇だけ移動する」と考えたほうがわかりやすいですね。 ですから、「プレイヤーの座標に、今のプレイヤーの座標に(0.0, -2.5)だけ加えた座標を代入する。」という操作を行います。 このような操作はプログラミングではよく用いるため、省略してかけるようになっています。それが「+=」というわけです。 この数字の後ろにある\"f\"ですが、これはその数字が浮動小数点数型であることを示しています。 キーボードのあるキーが押されているかどうか確認したいときは、 Engine.Keyboard.GetKeyState(Key.ここに確認したいキーを入れる) を用います。 詳しくは以下を参照してください。 Keyboard 左右上下に移動 では、同様にして、下・左右方向にも動けるようにしてみましょう。 using Altseed2; using System; namespace Tutorial { class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機 var player = new SpriteNode(); // 自機のテクスチャを読み込む player.Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 自機の座標を設定 player.Position = new Vector2F(100, 360); // 自機の中心座標を設定 player.CenterPosition = player.Texture.Size / 2; // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { player.Position -= new Vector2F(0.0f, 2.5f); } + // ↓キーでY座標を増加 + if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) + { + player.Position += new Vector2F(0.0f, 2.5f); + } + + // →キーでX座標を増加 + if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) + { + player.Position += new Vector2F(2.5f, 0.0f); + } + + // ←キーでX座標を減少 + if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) + { + player.Position -= new Vector2F(2.5f, 0.0f); + } + // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Keys.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } 上方向に進むコードの状態を取得するキーと、座標の足す(引く)値を変更すれば、 下・左右方向にも進めるようになりますね。 以上で自機キャラクターの表示と移動ができるようになりました！ 次の章では弾を撃てるようにしていきます。"
  },
  "Tutorials/Chap3/index.html": {
    "href": "Tutorials/Chap3/index.html",
    "title": "3章 : キャラクターに弾を撃たせてみよう | Altseed2",
    "keywords": "3章 : キャラクターに弾を撃たせてみよう 前章ではキャラクターの移動まで行いました。 次は，シューティングゲームとして大事な要素の一つ，弾の発射を実装していきましょう。 弾の生成 まず以下のコードを追加します。 using Altseed2; using System; + using System.Collections.Generic; namespace Tutorial { class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機 var player = new SpriteNode(); // 自機のテクスチャを読み込む player.Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 自機の座標を設定 player.Position = new Vector2F(100, 360); // 自機の中心座標を設定 player.CenterPosition = player.ContentSize / 2; // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { player.Position -= new Vector2F(0.0f, 2.5f); } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { player.Position += new Vector2F(0.0f, 2.5f); } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { player.Position += new Vector2F(2.5f, 0.0f); } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { player.Position -= new Vector2F(2.5f, 0.0f); } + // Zキーが押された時に実行 + if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) + { + // 発射される自機弾 + var bullet = new SpriteNode(); + // 自機弾のテクスチャを読み込む + bullet.Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); + // 自機弾の座標を設定 + bullet.Position = player.Position; + // 自機弾の中心座標を設定 + bullet.CenterPosition = bullet.ContentSize / 2; + // 自機弾の表示位置を自機より奥に設定 + bullet.ZOrder--; + + // 自機弾をエンジンに追加 + Engine.AddNode(bullet); + } // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } 結果，画像の様にZキーを押すたびに弾が生成されるようになりますが，まだ弾は動いていません。 やっていることは前章と大して変わっていませんが，1つ見たことの無いものがありますね。 // 自機弾の表示位置を自機より奥に設定 bullet.ZOrder--; ZOrder は，オブジェクトが手前側に描画されるか，奥側に描画されるかを表す数値です。 小さいほど奥側に，大きいほど手前側に表示されます。 同じ値の場合は手前/奥側に表示されるかどうかは不定です。 シューティングにおいては弾はプレイヤーや敵の奥側に表示されるものなので， ZOrder を -- 演算子を用いて1減らしています。 弾の移動 弾を動かすために以下のコードを追加します。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); + // 自機弾を格納するリスト + var list = new List<SpriteNode>(); // 自機 var player = new SpriteNode(); // 自機のテクスチャを読み込む player.Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 自機の座標を設定 player.Position = new Vector2F(100, 360); // 自機の中心座標を設定 player.CenterPosition = player.ContentSize / 2; // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { player.Position -= new Vector2F(0.0f, 2.5f); } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { player.Position += new Vector2F(0.0f, 2.5f); } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { player.Position += new Vector2F(2.5f, 0.0f); } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { player.Position -= new Vector2F(2.5f, 0.0f); } // Zキーが押された時に実行 if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { // 発射される自機弾 var bullet = new SpriteNode(); // 自機弾のテクスチャを読み込む bullet.Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); // 自機弾の座標を設定 bullet.Position = player.Position; // 自機弾の中心座標を設定 bullet.CenterPosition = bullet.ContentSize / 2; // 自機弾の表示位置を自機より奥に設定 bullet.ZOrder--; // 自機弾をエンジンに追加 Engine.AddNode(bullet); + // 自機弾をリストに追加 + list.Add(bullet); } + // 自機弾を右に進める + for (int i = 0; i < list.Count; i++) + { + list[i].Position += new Vector2F(10.0f, 0.0f); + } // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } これで発射された弾は右側に移動するようになりました。 ここでもまた始めてみるものが出てきました。 // 自機弾を格納するリスト var list = new List<SpriteNode>(); List<T> は，\"コレクション\"と呼ばれるものの一つです。 コレクションは，要素をまとめてくれるものです。 例えば， List<int> であったら int 型の整数を複数登録出来るものです。 List<T> は Add メソッドで末尾に要素を追加出来ます。 また，n番目に追加された要素を角括弧を用いて list[n] の様にして取得する事が出来ます。 更に， list.Count とすることで登録された要素の個数を取得することもできます。 // 自機弾を右に進める for (int i = 0; i < list.Count; i++) { list[i].Position += new Vector2F(10.0f, 0.0f); } 先程追加されたコードのこの部分では番号を指定した要素の検索と一緒にfor文を用いています。 このfor文というのはC#における繰り返し構文の一つで，while文に機能を足したようなものです。 forは for (繰り返し処理の前に行う事; 繰り返す条件; 繰り返し処理の最後に行われる事) { 繰り返して行いたい処理 } という風に書きます。 ここでは， 繰り返し処理の前に行う事 として int i = 0 を行い， int 型の変数を定義して値に0をセットしました。 繰り返す条件 は i < list.Count となっており， i がリストの回数よりも小さいことが条件になっています。 繰り返し処理の最後に行われる事 では， i++ で i に1を加算しています。 この3つの記述によって，このfor文は 鉤括弧内の処理を list.Count 回繰り返す という意味を持ちます。 この for (int i = 0; i < 繰り返し回数; i++) { 繰り返したい処理 } という書き方はよく使います。 この書き方において i は， 繰り返しが何回行われたか を意味します。 つまり， // 自機弾を右に進める for (int i = 0; i < list.Count; i++) { list[i].Position += new Vector2F(10.0f, 0.0f); } では list 内の要素を1つずつ取得して，それぞれの座標を右に動かしているのです。 ここで1つ疑問が浮かぶかもしれません。 あれ？ i が0からスタートって， list[0] から始めるの？0番目っておかしくない？ となるかもしれませんが， List<T> において，検索する数字は0番目から始まります。 つまり，10個の要素が格納されている List<T> では，最初の要素は0番目に存在して最後の要素は9番目に存在しているという事です。 因みに，このfor文をwhile文に書き換えるとこんな感じになります。 int i = 0; while (i < list.Count) { list[i].Position = new Vector2F(10.0f, 0.0f); i++; } \"指定回数繰り返す\"という動作はfor文の方が便利なのでこちらを使うことをお勧めします。 他のコレクション このチュートリアルでは以下のような List<T> 以外のコレクションも使っていきます。 コレクションごとに特徴が多種多様で難しいため，余裕がない場合はここは後で読むくらいで構いません。 配列 HashSet<T> Queue<T> 配列は List<T> とよく似ていますが， Add メソッドで要素の追加をするのではなく， array[0] = 3; のように直接代入することしかできません。 また，要素数は Count ではなく Length を用いて取得します。 HashSet<T> は同じ要素を2つ以上格納できないコレクションです。つまり， set.Add(3); を何回行っても3は1つしか格納されていません。 また， List<T> や配列の様に何番目の要素は…と言った検索はできません。 その代わり，他のコレクションに比べ要素の追加や削除が高速で行えるという特徴があります。 Queue<T> は\"先入れ先出し\"とも言われるコレクションで， Enqueue メソッドで末尾に要素を追加します。 要素を取り出すときは Dequeue メソッドを使用しますが，この操作で取り出せるのは先頭の要素です。 また， Dequeue メソッドで先頭の要素を取り出したとき，その要素は Queue<T> 内から自動的に削除されます。"
  },
  "Tutorials/Chap4/index.html": {
    "href": "Tutorials/Chap4/index.html",
    "title": "4章 : クラスを自分で設計してみよう | Altseed2",
    "keywords": "4章 : クラスを自分で設計してみよう 前章ではキャラクターが弾を撃つようになりました。 しかし、このまま新しい要素を Main メソッドに書き込んでいくと、ソースコードは段々と長く、わかりにくくなっていきます。 そこで、今回はソースコードを整理して、キャラクターと弾の処理を個別に行えるようにしましょう。 新たに導入する知識 C#によるプログラミング入門 : 関数 C#によるプログラミング入門 : 継承 プレイヤーを動かす処理をメソッドを使って整理する プレイヤーや弾を移動させるソースコードが while 文の中に書き込まれていたため、 while 文の中の処理が長くなっていました。 今はまだプレイヤーの移動と弾の発射だけなので、そこまで読みにくく感じることはないかもしれません。 しかし、ここに敵の追加や移動などの処理を加えると、ソースコードはどんどん長く、わかりにくくなっていきます。 しまいには開発者本人でさえ読めなくなってしまいます。 そこでまずは、メソッドを使って一連の処理をまとめていきましょう。 手始めに、キャラクターの移動に関する処理をメソッドで表現します。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { class Program { + // プレイヤーの移動を行う + static void MovePlayer(SpriteNode player) + { + // ↑キーでY座標を減少 + if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) + { + player.Position -= new Vector2F(0.0f, 2.5f); + } + + // ↓キーでY座標を増加 + if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) + { + player.Position += new Vector2F(0.0f, 2.5f); + } + + // →キーでX座標を増加 + if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) + { + player.Position += new Vector2F(2.5f, 0.0f); + } + + // ←キーでX座標を減少 + if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) + { + player.Position -= new Vector2F(2.5f, 0.0f); + } + } [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機弾を格納するリスト var list = new List<SpriteNode>(); // 自機 var player = new SpriteNode(); // 自機のテクスチャを読み込む player.Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 自機の座標を設定 player.Position = new Vector2F(100, 360); // 自機の中心座標を設定 player.CenterPosition = player.ContentSize / 2; // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); - // ↑キーでY座標を減少 - if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) - { - player.Position -= new Vector2F(0.0f, 2.5f); - } - - // ↓キーでY座標を増加 - if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) - { - player.Position += new Vector2F(0.0f, 2.5f); - } - - // →キーでX座標を増加 - if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) - { - player.Position += new Vector2F(2.5f, 0.0f); - } - - // ←キーでX座標を減少 - if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) - { - player.Position -= new Vector2F(2.5f, 0.0f); - } + // プレイヤーを動かす + MovePlayer(player); // Zキーが押された時に実行 if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { // 発射される自機弾 var bullet = new SpriteNode(); // 自機弾のテクスチャを読み込む bullet.Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); // 自機弾の座標を設定 bullet.Position = player.Position; // 自機弾の中心座標を設定 bullet.CenterPosition = bullet.ContentSize / 2; // 自機弾の表示位置を自機より奥に設定 bullet.ZOrder--; // 自機弾をエンジンに追加 Engine.AddNode(bullet); // 自機弾をリストに追加 list.Add(bullet); } // 自機弾を右に進める for (int i = 0; i < list.Count; i++) { list[i].Position += new Vector2F(10.0f, 0.0f); } // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } ソースコードでは、以下のようにメソッドを追加しました。 static void MovePlayer(SpriteNode player) { ...... } MovePlayer メソッドは引数 player の移動に関する処理を行います。 MovePlayer メソッドの中の処理は、以下のように記述することで呼び出されます。 MovePlayer(player); このように変更して、作成したプログラムを実行してみてください。 挙動は全く変わらないはずです。 プレイヤーを動かす処理を継承を使って整理する Main メソッドの中身がある程度すっきりしましたね。 しかし、これだけでは C#の良さは活かしきれません。 C#の機能にクラスというものがあったことを思い出してください。 ここからは、そのクラスを自分で設計していきましょう。 まず、プレイヤーに相当するクラスを追加します。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { + // プレイヤーのクラス + public class Player : SpriteNode + { + } class Program { // プレイヤーの移動を行う - static void MovePlayer(SpriteNode player) + static void MovePlayer(Player player) { // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { player.Position -= new Vector2F(0.0f, 2.5f); } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { player.Position += new Vector2F(0.0f, 2.5f); } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { player.Position += new Vector2F(2.5f, 0.0f); } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { player.Position -= new Vector2F(2.5f, 0.0f); } } [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機弾を格納するリスト var list = new List<SpriteNode>(); // 自機 - var player = new SpriteNode(); + var player = new Player(); // 自機のテクスチャを読み込む player.Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 自機の座標を設定 player.Position = new Vector2F(100, 360); // 自機の中心座標を設定 player.CenterPosition = player.ContentSize / 2; // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // プレイヤーを動かす MovePlayer(player); // Zキーが押された時に実行 if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { // 発射される自機弾 var bullet = new SpriteNode(); // 自機弾のテクスチャを読み込む bullet.Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); // 自機弾の座標を設定 bullet.Position = player.Position; // 自機弾の中心座標を設定 bullet.CenterPosition = bullet.ContentSize / 2; // 自機弾の表示位置を自機より奥に設定 bullet.ZOrder--; // 自機弾をエンジンに追加 Engine.AddNode(bullet); // 自機弾をリストに追加 list.Add(bullet); } // 自機弾を右に進める for (int i = 0; i < list.Count; i++) { list[i].Position += new Vector2F(10.0f, 0.0f); } // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } ソースコードでは、以下のようにクラスを追加しました。 class Player : SpriteNode { ...... } 第2章で、 SpriteNode は設計図であると述べました。 この変更では、 SpriteNode という設計図を利用して、 Player という新たな設計図を作成しています。 この機能を「継承」と呼びます。 また、 var player = new SpriteNode(); の部分が var player = new Player(); に変化しています。 このようにすることで、 player は Player クラスのインスタンスになります。 この Player クラスには、新たな機能が何も追加されていません。 そこで、プレイヤーを動かす処理を Player クラスの内部に持っていきます。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { // プレイヤーのクラス public class Player : SpriteNode { + // 移動を行う + public void Move() + { + // ↑キーでY座標を減少 + if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) + { + Position -= new Vector2F(0.0f, 2.5f); + } + + // ↓キーでY座標を増加 + if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) + { + Position += new Vector2F(0.0f, 2.5f); + } + + // →キーでX座標を増加 + if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) + { + Position += new Vector2F(2.5f, 0.0f); + } + + // ←キーでX座標を減少 + if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) + { + Position -= new Vector2F(2.5f, 0.0f); + } + } } class Program { - // プレイヤーの移動を行う - static void MovePlayer(Player player) - { - // ↑キーでY座標を減少 - if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) - { - player.Position -= new Vector2F(0.0f, 2.5f); - } - - // ↓キーでY座標を増加 - if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) - { - player.Position += new Vector2F(0.0f, 2.5f); - } - - // →キーでX座標を増加 - if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) - { - player.Position += new Vector2F(2.5f, 0.0f); - } - - // ←キーでX座標を減少 - if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) - { - player.Position -= new Vector2F(2.5f, 0.0f); - } - } [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機弾を格納するリスト var list = new List<SpriteNode>(); // 自機 var player = new Player(); // 自機のテクスチャを読み込む player.Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 自機の座標を設定 player.Position = new Vector2F(100, 360); // 自機の中心座標を設定 player.CenterPosition = player.ContentSize / 2; // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // プレイヤーを動かす - MovePlayer(player); + player.Move(); // Zキーが押された時に実行 if (Engine.Keyboard.GetKeyState(Keys.Z) == ButtonState.Push) { // 発射される自機弾 var bullet = new SpriteNode(); // 自機弾のテクスチャを読み込む bullet.Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); // 自機弾の座標を設定 bullet.Position = player.Position; // 自機弾の中心座標を設定 bullet.CenterPosition = bullet.ContentSize / 2; // 自機弾の表示位置を自機より奥に設定 bullet.ZOrder--; // 自機弾をエンジンに追加 Engine.AddNode(bullet); // 自機弾をリストに追加 list.Add(bullet); } // 自機弾を右に進める for (int i = 0; i < list.Count; i++) { list[i].Position += new Vector2F(10.0f, 0.0f); } // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } MovePlayer メソッドの処理を、 Player クラスの Move メソッドに移動させました。 Player クラスは、継承元である SpriteNode クラスの情報を持っているため、 Position や Texture が自身の情報となります。 したがって Move メソッドの中では、たとえば player.Position とはせずに、単に Position と記述します。 また、 Main メソッドからの呼び出し方が変わり、 player.Move() とします。 続いて、Altseed2のUpdate機能を使って、 Player クラスの更新を Player クラスの内部で行えるようにしましょう。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { // プレイヤーのクラス public class Player : SpriteNode { + // フレーム毎に実行 + protected override void OnUpdate() + { + // 移動を実行 + Move(); + } // 移動を行う - public void Move() + void Move() { // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { Position -= new Vector2F(0.0f, 2.5f); } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { Position += new Vector2F(0.0f, 2.5f); } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { Position += new Vector2F(2.5f, 0.0f); } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { Position -= new Vector2F(2.5f, 0.0f); } } } class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機弾を格納するリスト var list = new List<SpriteNode>(); // 自機 var player = new Player(); // 自機のテクスチャを読み込む player.Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 自機の座標を設定 player.Position = new Vector2F(100, 360); // 自機の中心座標を設定 player.CenterPosition = player.ContentSize / 2; // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); - // プレイヤーを動かす - player.Move(); // Zキーが押された時に実行 if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { // 発射される自機弾 var bullet = new SpriteNode(); // 自機弾のテクスチャを読み込む bullet.Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); // 自機弾の座標を設定 bullet.Position = player.Position; // 自機弾の中心座標を設定 bullet.CenterPosition = bullet.ContentSize / 2; // 自機弾の表示位置を自機より奥に設定 bullet.ZOrder--; // 自機弾をエンジンに追加 Engine.AddNode(bullet); // 自機弾をリストに追加 list.Add(bullet); } // 自機弾を右に進める for (int i = 0; i < list.Count; i++) { list[i].Position += new Vector2F(10.0f, 0.0f); } // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } OnUpdate は、Altseed2が更新されるたびに実行されるメソッドです。 この中に Move メソッドを加えることで、今までと同じように Move メソッドがAltseed2が更新されるたびに実行されます。 protected override void OnUpdate() { ...... } override は、継承元のメソッドの名前を使って処理を上書きするための機能です。 単に OnUpdate と記述するだけでなく、 override も併せて記述しなければ、正しい動作は望めません。 なお、 public void Move() の部分が void Move() に変化していることが見て取れます。 public や protected の説明は次の章にて行います。 弾を動かす処理を継承を使って整理する 今度は、先ほどと同じようにして弾のソースコードを整理していきます。 弾に相当するクラスを追加しましょう。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { // プレイヤーのクラス public class Player : SpriteNode { // フレーム毎に実行 protected override void OnUpdate() { // 移動を実行 Move(); } // 移動を行う void Move() { // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { Position -= new Vector2F(0.0f, 2.5f); } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { Position += new Vector2F(0.0f, 2.5f); } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { Position += new Vector2F(2.5f, 0.0f); } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { Position -= new Vector2F(2.5f, 0.0f); } } } + // 弾のクラス + public class Bullet : SpriteNode + { + // フレーム毎に実行 + protected override void OnUpdate() + { + // 座標を速度分進める + Position += new Vector2F(10.0f, 0.0f); + } + } class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); - // 自機弾を格納するリスト - var list = new List<SpriteNode>(); // 自機 var player = new Player(); // 自機のテクスチャを読み込む player.Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 自機の座標を設定 player.Position = new Vector2F(100, 360); // 自機の中心座標を設定 player.CenterPosition = player.ContentSize / 2; // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // Zキーが押された時に実行 if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { // 発射される自機弾 - var bullet = new SpriteNode(); + var bullet = new Bullet(); // 自機弾のテクスチャを読み込む bullet.Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); // 自機弾の座標を設定 bullet.Position = player.Position; // 自機弾の中心座標を設定 bullet.CenterPosition = bullet.ContentSize / 2; // 自機弾の表示位置を自機より奥に設定 bullet.ZOrder--; // 自機弾をエンジンに追加 Engine.AddNode(bullet); - // 自機弾をリストに追加 - list.Add(bullet); } - // 自機弾を右に進める - for (int i = 0; i < list.Count; i++) - { - list[i].Position += new Vector2F(10.0f, 0.0f); - } // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } Bullet クラスを追加しました。 public class Bullet : SpriteNode { ... } また、 var bullet = new SpriteNode(); の部分が var bullet = new Bullet(); に変化しています。 このようにすることで、 bullet は Bullet クラスのインスタンスになります。 更新処理が Bullet クラスに記述されていることで、更新するたびに弾自身が自分で移動するようになります。 そのため、 List による管理が必要なくなります。 弾を撃つ処理をプレイヤーに移動する 弾を撃っているのはプレイヤーなので、弾を撃つ処理をプレイヤーに移動してみましょう。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { // プレイヤーのクラス public class Player : SpriteNode { // フレーム毎に実行 protected override void OnUpdate() { // 移動を実行 Move(); + // ショットを実行 + Shot(); } // 移動を行う void Move() { // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { Position -= new Vector2F(0.0f, 2.5f); } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { Position += new Vector2F(0.0f, 2.5f); } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { Position += new Vector2F(2.5f, 0.0f); } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { Position -= new Vector2F(2.5f, 0.0f); } } + // ショット + private void Shot() + { + // Zキーでショットを放つ + if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) + { + // 発射される自機弾 + var bullet = new Bullet(); + + // 自機弾のテクスチャを読み込む + bullet.Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); + // 自機弾の座標を設定 + bullet.Position = Position; + // 自機弾の中心座標を設定 + bullet.CenterPosition = bullet.ContentSize / 2; + // 自機弾の表示位置を自機より奥に設定 + bullet.ZOrder--; + + // 自機弾をエンジンに追加 + Engine.AddNode(bullet); + } + } } // 弾のクラス public class Bullet : SpriteNode { // フレーム毎に実行 protected override void OnUpdate() { // 座標を速度分進める Position += new Vector2F(10.0f, 0.0f); } } class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機 var player = new Player(); // 自機のテクスチャを読み込む player.Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 自機の座標を設定 player.Position = new Vector2F(100, 360); // 自機の中心座標を設定 player.CenterPosition = player.ContentSize / 2; // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); - // Zキーが押された時に実行 - if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) - { - // 発射される自機弾 - var bullet = new Bullet(); - - // 自機弾のテクスチャを読み込む - bullet.Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); - // 自機弾の座標を設定 - bullet.Position = player.Position; - // 自機弾の中心座標を設定 - bullet.CenterPosition = bullet.ContentSize / 2; - // 自機弾の表示位置を自機より奥に設定 - bullet.ZOrder--; - - // 自機弾をエンジンに追加 - Engine.AddNode(bullet); - } // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } プレイヤーに関する処理のほとんどが Player クラスに移動しましたね。 Main メソッドの while 文の中身がAltseed2の更新処理だけになりました。 ここまで変更したプログラムを実行してみてください。 挙動は全く変わらないはずです。 コンストラクタを使って初期値を設定する 大分、処理がクラスにまとまってきました。 しかし、画像と最初の位置の指定がクラスの外で行われています。 これら初期値の設定も、クラスの中で行いたいものです。 そこで登場するのが「コンストラクタ」です。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { // プレイヤーのクラス public class Player : SpriteNode { + // コンストラクタ + public Player(Vector2F position) + { + // 座標を設定 + Position = position; + + // テクスチャを読み込む + Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); + + // 中心座標を設定 + CenterPosition = ContentSize / 2; + } // フレーム毎に実行 protected override void OnUpdate() { // 移動を実行 Move(); // ショットを実行 Shot(); } // 移動を行う void Move() { // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { Position -= new Vector2F(0.0f, 2.5f); } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { Position += new Vector2F(0.0f, 2.5f); } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { Position += new Vector2F(2.5f, 0.0f); } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { Position -= new Vector2F(2.5f, 0.0f); } } // ショット private void Shot() { // Zキーでショットを放つ if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { // 発射される自機弾 - var bullet = new Bullet(); + var bullet = new Bullet(Position); - // 自機弾のテクスチャを読み込む - bullet.Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); - // 自機弾の座標を設定 - bullet.Position = Position; - // 自機弾の中心座標を設定 - bullet.CenterPosition = bullet.ContentSize / 2; - // 自機弾の表示位置を自機より奥に設定 - bullet.ZOrder--; // 自機弾をエンジンに追加 Engine.AddNode(bullet); } } } // 弾のクラス public class Bullet : SpriteNode { + // コンストラクタ + public Bullet(Vector2F position) + { + // 座標を設定 + Position = position; + + // テクスチャを読み込む + Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); + + // 中心座標を設定 + CenterPosition = ContentSize / 2; + + // 表示位置をプレイヤーや敵より奥に設定 + ZOrder--; + } // フレーム毎に実行 protected override void OnUpdate() { // 座標を速度分進める Position += new Vector2F(10.0f, 0.0f); } } class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機 - var player = new Player(); + var player = new Player(new Vector2F(100, 360)); - // 自機のテクスチャを読み込む - player.Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); - // 自機の座標を設定 - player.Position = new Vector2F(100, 360); - // 自機の中心座標を設定 - player.CenterPosition = player.ContentSize / 2; // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } コンストラクタは、インスタンスが生成されたときに実行されるメソッドの一種です。 インスタンス生成と同時に画像を読み込むには、このコンストラクタにその処理を記述します。 また、コンストラクタはメソッドであり、引数を持つことができます。 ソースコードでは、 Player クラスと Bullet クラスのコンストラクタに、引数 position を持たせています。 このようにすることで、プレイヤーや弾の最初の位置を外部から設定できるようになります。 次に、コンストラクタで弾の速度を設定できるようにしましょう。 Bullet クラスのコンストラクタに速度を引数として設定してそこからいじれるようにします。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { // プレイヤーのクラス public class Player : SpriteNode { // コンストラクタ public Player(Vector2F position) { // 座標を設定 Position = position; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; } // フレーム毎に実行 protected override void OnUpdate() { // 移動を実行 Move(); // ショットを実行 Shot(); } // 移動を行う void Move() { // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { Position -= new Vector2F(0.0f, 2.5f); } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { Position += new Vector2F(0.0f, 2.5f); } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { Position += new Vector2F(2.5f, 0.0f); } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { Position -= new Vector2F(2.5f, 0.0f); } } // ショット private void Shot() { // Zキーでショットを放つ if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { // 発射される自機弾 var bullet = new Bullet(Position); // 自機弾をエンジンに追加 Engine.AddNode(bullet); } } } // 弾のクラス public class Bullet : SpriteNode { + // フレーム毎に進む距離 + private Vector2F velocity; // コンストラクタ - public Bullet(Vector2F position) + public Bullet(Vector2F position, Vector2F velocity) { // 座標を設定 Position = position; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; + // 弾速を設定 + this.velocity = velocity; // 表示位置をプレイヤーや敵より奥に設定 ZOrder--; } // フレーム毎に実行 protected override void OnUpdate() { // 座標を速度分進める - Position += new Vector2F(10.0f, 0.0f); + Position += velocity; } } class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機 var player = new Player(new Vector2F(100, 360)); // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } Bullet クラスのコンストラクタの引数を変えたので、それを呼び出すコードを修正しましょう。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { // プレイヤーのクラス public class Player : SpriteNode { // コンストラクタ public Player(Vector2F position) { // 座標を設定 Position = position; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; } // フレーム毎に実行 protected override void OnUpdate() { // 移動を実行 Move(); // ショットを実行 Shot(); } // 移動を行う void Move() { // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { Position -= new Vector2F(0.0f, 2.5f); } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { Position += new Vector2F(0.0f, 2.5f); } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { Position += new Vector2F(2.5f, 0.0f); } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { Position -= new Vector2F(2.5f, 0.0f); } } // ショット private void Shot() { // Zキーでショットを放つ if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { // 発射される自機弾 - var bullet = new Bullet(Position); + var bullet = new Bullet(Position, new Vector2F(10f, 0f)); // 自機弾をエンジンに追加 Engine.AddNode(bullet); } } } // 弾のクラス public class Bullet : SpriteNode { // フレーム毎に進む距離 private Vector2F velocity; // コンストラクタ public Bullet(Vector2F position, Vector2F velocity) { // 座標を設定 Position = position; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; // 弾速を設定 this.velocity = velocity; // 表示位置をプレイヤーや敵より奥に設定 ZOrder--; } // フレーム毎に実行 protected override void OnUpdate() { // 座標を速度分進める Position += velocity; } } class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機 var player = new Player(new Vector2F(100, 360)); // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } プレイヤーが画面外に出ないようにする ここまででできたプログラムを実行してわかると思いますが、方向キーを押しっぱなしにしていると、プレイヤーが画面外に出てしまいます。 そこで、プレイヤーが画面外に出ないように、処理を追加する必要があります。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { // プレイヤーのクラス public class Player : SpriteNode { // コンストラクタ public Player(Vector2F position) { // 座標を設定 Position = position; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; } // フレーム毎に実行 protected override void OnUpdate() { // 移動を実行 Move(); // ショットを実行 Shot(); } // 移動を行う void Move() { + // 現在のX座標を取得する + var x = Position.X; + // 現在のY座標を取得する + var y = Position.Y; // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { - Position -= new Vector2F(0.0f, 2.5f); + y -= 2.5f; } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { - Position += new Vector2F(0.0f, 2.5f); + y += 2.5f; } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { - Position += new Vector2F(2.5f, 0.0f); + x += 2.5f; } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { - Position -= new Vector2F(2.5f, 0.0f); + x -= 2.5f; } + // テクスチャのサイズの半分を取得する + var halfSize = ContentSize / 2; + + // X座標が画面外に行かないように調整 + x = MathHelper.Clamp(x, Engine.WindowSize.X - halfSize.X, halfSize.X); + // Y座標が画面外に行かないように調整 + y = MathHelper.Clamp(y, Engine.WindowSize.Y - halfSize.Y, halfSize.Y); + + // 調整された座標を設定 + Position = new Vector2F(x, y); } // ショット private void Shot() { // Zキーでショットを放つ if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { // 発射される自機弾 var bullet = new Bullet(Position, new Vector2F(10f, 0f)); // 自機弾をエンジンに追加 Engine.AddNode(bullet); } } } // 弾のクラス public class Bullet : SpriteNode { // フレーム毎に進む距離 private Vector2F velocity; // コンストラクタ public Bullet(Vector2F position, Vector2F velocity) { // 座標を設定 Position = position; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; // 弾速を設定 this.velocity = velocity; // 表示位置をプレイヤーや敵より奥に設定 ZOrder--; } // フレーム毎に実行 protected override void OnUpdate() { // 座標を速度分進める Position += velocity; } } class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機 var player = new Player(new Vector2F(100, 360)); // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } 追加した処理では、変更後の x 座標と y 座標について、画面に表示される範囲に収まるように数値を設定しています。 このようにすることで、プレイヤーが画面外に出ることはなくなります。 弾が画面外に出たら消える処理を追加する 弾はいずれ画面外に出ていきます。 しかし、画面外に出た弾を削除せずに、エンジンに弾を追加していくと、エンジンの処理が重くなっていきます。 そのため、弾が画面外に出て行ったら削除する処理を追加する必要があります。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { // プレイヤーのクラス public class Player : SpriteNode { // コンストラクタ public Player(Vector2F position) { // 座標を設定 Position = position; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; } // フレーム毎に実行 protected override void OnUpdate() { // 移動を実行 Move(); // ショットを実行 Shot(); } // 移動を行う void Move() { // 現在のX座標を取得する var x = Position.X; // 現在のY座標を取得する var y = Position.Y; // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { y -= 2.5f; } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { y += 2.5f; } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { x += 2.5f; } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { x -= 2.5f; } // テクスチャのサイズの半分を取得する var halfSize = ContentSize / 2; // X座標が画面外に行かないように調整 x = MathHelper.Clamp(x, Engine.WindowSize.X - halfSize.X, halfSize.X); // Y座標が画面外に行かないように調整 y = MathHelper.Clamp(y, Engine.WindowSize.Y - halfSize.Y, halfSize.Y); // 調整された座標を設定 Position = new Vector2F(x, y); } // ショット private void Shot() { // Zキーでショットを放つ if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { // 発射される自機弾 var bullet = new Bullet(Position, new Vector2F(10f, 0f)); // 自機弾をエンジンに追加 Engine.AddNode(bullet); } } } // 弾のクラス public class Bullet : SpriteNode { // フレーム毎に進む距離 private Vector2F velocity; // コンストラクタ public Bullet(Vector2F position, Vector2F velocity) { // 座標を設定 Position = position; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; // 弾速を設定 this.velocity = velocity; // 表示位置をプレイヤーや敵より奥に設定 ZOrder--; } // フレーム毎に実行 protected override void OnUpdate() { // 座標を速度分進める Position += velocity; + // 画面外に出たら自身を削除 + RemoveMyselfIfOutOfWindow(); } + // 画面外に出た時自身を消去 + private void RemoveMyselfIfOutOfWindow() + { + var halfSize = Texture.Size / 2; + if (Position.X < -halfSize.X + || Position.X > Engine.WindowSize.X + halfSize.X + || Position.Y < -halfSize.Y + || Position.Y > Engine.WindowSize.Y + halfSize.Y) + { + // 自身を削除 + Parent?.RemoveChildNode(this); + } + } } class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機 var player = new Player(new Vector2F(100, 360)); // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } 弾が画面外に出たら、親ノードを取得して RemoveChildNode メソッドを実行します。 このメソッドを実行すると、弾のインスタンスはAltseed2の管理対象から除外されます。 すなわち、画面外に出た弾は管理されなくなるということです。 これにて、画面外の弾が消えないも解決です。 クラスごとにファイルを分ける さて、ここまでソースコードをProgram.csに書き込んできたわけですが、行数が多くなり、見通しも悪くなってきました。 そこで、新しい C#のソースファイルを追加して、ソースコードを切り分けていきましょう。 Windows の場合 まず、下図に示すように、「ShootingGame」の青く示された部分を右クリックしてください。 その後、選択肢のウィンドウが出てくるので、「追加」、「新しい項目」の順にクリックしてください。 すると、「新しい項目の追加 - ShootingGame」というウィンドウが表示されます。 ウィンドウが表示されたら、画面左側の選択肢から「コード」を選択し、その後、画面中央の選択肢から「クラス」を選択します。 次に、画面下側の入力ボックスに、ファイル名を入力します。 今回は Player クラスを別のファイルに移動したいため、ファイル名を「Player.cs」とします。 入力が終わったら、「追加」をクリックします。 ここまで終わったら、「ソリューション」のところに「Player.cs」が追加されているはずです。 あとは、Program.csに記述されている Player クラスの部分を切り取って、Player.csに貼り付けるだけです。 ただし、ただ切り貼りしただけではエラーが発生します。 これは、ソースファイルに Altseed という名前空間が知らされていないことが原因です。 Player.csの頭に「 using Altseed2; 」と記述しましょう。 これと同様の手順を踏んで、Bullet.csを追加し、 Bullet クラスを移してみてください。 Mac の場合 まず、下図に示すように、「ShootingGame」の青く示された部分を右クリックしてください。 その後、選択肢のウィンドウが出てくるので、「追加」、「新しいファイル」の順にクリックしてください。 すると、「新しいファイル」というウィンドウが表示されます。 ウィンドウが表示されたら、画面左側の選択肢から「General」を選択し、その後、画面中央の選択肢から「空のクラス」を選択します。 次に、画面下側の入力ボックスに、ファイル名を入力します。 今回は Player クラスを別のファイルに移動したいため、ファイル名を「Player」とします。 入力が終わったら、「新規」をクリックします。 ここまで終わったら、「ソリューション」のところに「Player.cs」が追加されているはずです。 あとは、Program.csに記述されている Player クラスの部分を切り取って、Player.csに貼り付けるだけです。 ただし、ただ切り貼りしただけではエラーが発生します。 これは、ソースファイルに Altseed という名前空間が知らされていないことが原因です。 Player.csの頭に「 using Altseed; 」と記述しましょう。 これと同様の手順を踏んで、Bullet.csを追加し、 Bullet クラスを移してみてください。 プレイヤーや弾をまとめて管理できるようにする ソースコードが複数のファイルに振り分けられたことで、Program.csの内容がこれだけになりました。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); // 自機 var player = new Player(new Vector2F(100, 360)); // 自機をエンジンに追加 Engine.AddNode(player); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } しかし、このソースコードでは、プレイヤーや弾を、エンジンに直接登録してしまっています。 このままでは、何か別の画面に切り替えようとした場合に、エンジンに直接登録されたオブジェクトをいちいち登録解除するのが面倒です。 そこで、プレイヤーや弾をまとめて管理できる、すなわちメインステージを追加しておきましょう。 まず、新しくMainNode.csを作成します。 手順は、先ほどソースコードを振り分ける時に行ったものと同じです。 ファイルを新規作成できたら、メインステージを表す MainNode クラスに処理を書き込んでいきます。 MainNode.csに以下のように書いてください。 using Altseed2; namespace Tutorial { // メインステージのクラス public class MainNode : Node { // キャラクターを表示するノード private Node characterNode = new Node(); // プレイヤーの参照 private Player player; // エンジンに追加された時に実行 protected override void OnAdded() { // キャラクターノードを追加 AddChildNode(characterNode); // UIを表示するノード var uiNode = new Node(); // UIノードを追加 AddChildNode(uiNode); // プレイヤーを設定 player = new Player(new Vector2F(100, 360)); // キャラクターノードにプレイヤーを追加 characterNode.AddChildNode(player); } } } OnAdded は、このノードがエンジンに登録されたときに実行されるメソッドです。 ノードの初期状態を設定するには、このメソッドを使います。 protected override void OnAdded() { ...... } さて、 MainNode クラスは、ノードを表す Node クラスを継承しています。 こうすることで、 MainNode クラスのインスタンスは、エンジンに登録されるノードとして作用します。 このノードにプレイヤーや弾を登録することで、これらをまとめて管理できるというわけです。 また、 MainNode の中にも、 characterNode や uiNode のような、 Node クラスのインスタンスがあります。 同じ画面の中でも、プレイヤーや弾といったゲーム中のオブジェクトと、残機や得点といった UI に関わるオブジェクトを、それぞれまとめて管理したいものです。 このように、 Node クラスのインスタンスをうまく利用することで、系統ごとにオブジェクトをまとめて管理することができます。 では、 MainNode クラスのインスタンスを作成し、それをエンジンに登録してみましょう。 Program.csに移って、以下のようにソースコードを書き換えてください。 using Altseed2; using System; using System.Collections.Generic; namespace Tutorial { class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); - // 自機 - var player = new Player(new Vector2F(100, 360)); - - // 自機をエンジンに追加 - Engine.AddNode(player); + // メイン画面をエンジンに追加 + Engine.AddNode(new MainNode()); // メインループ while (Engine.DoEvents()) { // エンジンを更新 Engine.Update(); // Escapeキーでゲーム終了 if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push) { break; } } // エンジンの終了処理を行う Engine.Terminate(); } } } このようにすると、 MainNode の子ノードとして登録されているオブジェクト群が更新され、先ほどと同じ挙動をします。 また、ゲームシーンとして MainNode を定義したため、 Player クラスで行っている自機弾の追加先をエンジンから、 MainNode にある characterNode に変更しましょう。 using Altseed2; namespace Tutorial { // プレイヤーのクラス public class Player : SpriteNode { // コンストラクタ public Player(Vector2F position) { // 座標を設定 Position = position; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; } // フレーム毎に実行 protected override void OnUpdate() { // 移動を実行 Move(); // ショットを実行 Shot(); } // 移動を行う void Move() { // 現在のX座標を取得する var x = Position.X; // 現在のY座標を取得する var y = Position.Y; // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { y -= 2.5f; } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { y += 2.5f; } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { x += 2.5f; } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { x -= 2.5f; } // テクスチャのサイズの半分を取得する var halfSize = ContentSize / 2; // X座標が画面外に行かないように調整 x = MathHelper.Clamp(x, Engine.WindowSize.X - halfSize.X, halfSize.X); // Y座標が画面外に行かないように調整 y = MathHelper.Clamp(y, Engine.WindowSize.Y - halfSize.Y, halfSize.Y); // 調整された座標を設定 Position = new Vector2F(x, y); } // ショット private void Shot() { // Zキーでショットを放つ if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { - // 発射される自機弾 - var bullet = new Bullet(Position, new Vector2F(10f, 0f)); - - // 自機弾をエンジンに追加 - Engine.AddNode(bullet); + // Zキーでショットを放つ + Parent.AddChildNode(new Bullet(Position , new Vector2F(10f, 0f))); } } } } ここで， MainNode.characterNode がないではないかと思うかもしれませんが、 Parent が MainNode.characterNode を表しています。 MainNode.csにて、 // キャラクターノードを追加 AddChildNode(characterNode); ...... // キャラクターノードにプレイヤーを追加 characterNode.AddChildNode(player); という記述があります。これは、 エンジン-MainNode-characterNode-Player という親子関係を示しています。 ここで MainNode.characterNode の参照が欲しいとなったときは Player から Parent を呼び出すことで解決できます。 背景を追加する ソースコードが整理できたので、ここから敵を追加していっても良い頃合いです。 しかしその前に、プレーンな背景で繰り広げられるゲームは、いまいち面白みに欠けますよね。 それっぽい背景が欲しいものです。 ということで、 MainNode に背景を追加する機能を追加しておきましょう。 using Altseed2; namespace Tutorial { // メインステージのクラス public class MainNode : Node { // キャラクターを表示するノード private Node characterNode = new Node(); // プレイヤーの参照 private Player player; // エンジンに追加された時に実行 protected override void OnAdded() { // キャラクターノードを追加 AddChildNode(characterNode); // UIを表示するノード var uiNode = new Node(); // UIノードを追加 AddChildNode(uiNode); + // 背景に使用するテクスチャ + var backTexture = new SpriteNode(); + // 背景のテクスチャを読み込む + backTexture.Texture = Texture2D.LoadStrict(\"Resources/Background.png\"); + // 表示位置を奥に設定 + backTexture.ZOrder = -100; + + // 背景テクスチャを追加 + AddChildNode(backTexture); // プレイヤーを設定 player = new Player(new Vector2F(100, 360)); // キャラクターノードにプレイヤーを追加 characterNode.AddChildNode(player); } } } シューティングゲームらしい絵面になりました。 まとめと次回予告 今回は、C#のオブジェクト指向の機能を活用して、ソースコードを整理し、その過程で新たな機能を追加してきました。 このように、機能ごとにクラスを分けておくことで、ソースコードが読みやすくなります。 それによって、プログラムが落ちるなど、予期しない挙動が発生したとき、その原因となっている箇所を見つけやすくもなります。 クラスを自分で設計するということは、初めのうちは難しいかもしれません。 しかし、慣れていくと、自由自在にクラスを設計することができるようになります。 次回からやっと、敵機・敵弾を追加していきます。"
  },
  "Tutorials/Chap5/index.html": {
    "href": "Tutorials/Chap5/index.html",
    "title": "5章 : 敵・敵のショットを表示してみよう | Altseed2",
    "keywords": "5章 : 敵・敵のショットを表示してみよう 今まではプレイヤーの挙動のみでした。 次は敵の実装を行います。 本章では継承を使用します。 確かに、今までも既存のクラスを継承することはありました。 この継承元のクラスは自分でも作成できます。 敵は様々な挙動をしますが、それぞれ個別に実装するのも管理するのも大変です。 それらを共通化するために継承があります。 敵クラスの実装 まずは敵を実装します。 基本的にはプレイヤーと変わりません。 プレイヤーとの違いとして、プレイヤーを攻撃するためにプレイヤーへの参照を持っていること、画面外にでたら自動的に消えることが違います。 画面外にでても常に敵が残り続けると、敵が多すぎて重くなってしまいます。 そのため、画面外に出たら消えるようになっています。 Enemy.csを追加し、下記のコードを記述します。 Enemy.cs using Altseed2; namespace Tutorial { // 敵の基礎となるクラス public class Enemy : SpriteNode { // 倒された時に加算されるスコアの値 protected int score; // プレイヤーへの参照 protected Player player; // コンストラクタ public Enemy(Player player, Vector2F position) { // 座標を設定 Position = position; // プレイヤーへの参照を設定 this.player = player; } // フレーム毎に実行 protected override void OnUpdate() { // 画面外に出たら自身を削除 RemoveMyselfIfOutOfWindow(); } // 画面外に出た時自身を消去 protected void RemoveMyselfIfOutOfWindow() { var halfSize = Texture.Size / 2; if (Position.X < -halfSize.X || Position.X > Engine.WindowSize.X + halfSize.X || Position.Y < -halfSize.Y || Position.Y > Engine.WindowSize.Y + halfSize.Y) { // 自身を削除 Parent?.RemoveChildNode(this); } } } } 前章では、 protected や public の説明をしていませんでした。 これらはアクセス指定子といいます。 そのメンバー変数やメソッドにクラスの外部から使用できるかを指定します。 public は外部から使用できる、 protected は継承先を含めたクラス内、 private 、もしくは記述なしはクラス内のみ使用可能です。 今回の場合、Enemyクラスは継承して使用するので、多くのメンバー変数が protected になっています。 また、 Parent?.RemoveChildNode(this); という記述があります。 これは、 if(Parent != null) Parent.RemoveChildNode(this); と同じ意味です。nullでなかったら、何らかの処理を記述する、ということが多々あるため、簡単に記述できるようになっています。 ただ、見ての通り、この敵は動きもしないし攻撃もしません。 それでは、このクラスを継承して敵を実装しましょう。 隕石 先ほどのEnemyクラスを継承して隕石クラスを記述します。 Meteor.csを追加し、下記のコードを記述します。 Meteor.cs using Altseed2; namespace Tutorial { // 隕石 public class Meteor : Enemy { // フレーム毎の移動速度 private Vector2F velocity; // コンストラクタ public Meteor(Player player, Vector2F position, Vector2F velocity) : base(player, position) { // 速度の設定 this.velocity = velocity; // テクスチャの設定 Texture = Texture2D.LoadStrict(\"Resources/Meteor.png\"); // 中心座標の設定 CenterPosition = ContentSize / 2; // スコアの設定 score = 1; } // 毎フレーム実行 protected override void OnUpdate() { // 座標を速度分加算 Position += velocity; // EnemyクラスのOnUpdate呼び出し base.OnUpdate(); } } } 隕石は移動するだけの敵です。 更新するごとに速度の分、位置を動かしていきます。 <!-- 更新内で ```base.OnUpdate();``` を呼んでいます。 これは、継承元のOnUpdateを呼ぶという意味です。 継承元で、画面外に出たら消すという処理を行っているため、継承元のOnUpdateを呼ぶ必要があります。 --> 敵の出現 敵のクラスを用意しただけでは、敵は出現してくれません。 そこでMainNodeを編集して、敵が出現するようにします。 MainNode.cs using Altseed2; +using System.Collections.Generic; namespace Tutorial { // メインステージのクラス public class MainNode : Node { // キャラクターを表示するノード private Node characterNode = new Node(); // プレイヤーの参照 private Player player; // エンジンに追加された時に実行 protected override void OnAdded() { // キャラクターノードを追加 AddChildNode(characterNode); // UIを表示するノード var uiNode = new Node(); // UIノードを追加 AddChildNode(uiNode); // 背景に使用するテクスチャ var backTexture = new SpriteNode(); // 背景のテクスチャを読み込む backTexture.Texture = Texture2D.LoadStrict(\"Resources/Background.png\"); // 表示位置を奥に設定 backTexture.ZOrder = -100; // 背景テクスチャを追加 AddChildNode(backTexture); // プレイヤーを設定 player = new Player(new Vector2F(100, 360)); // キャラクターノードにプレイヤーを追加 characterNode.AddChildNode(player); + // 敵を追加する。 + characterNode.AddChildNode(new Meteor(player, new Vector2F(910, 400), new Vector2F(-4.0f, 0.0f))); } } } 弾を打つ敵 弾を打つ敵を用意しますが、その前に弾を共通化します。 味方の弾と敵の弾を全く異なるクラスにしてもいいですが、ほとんどの機能は共通なので同じようなコードが2箇所に書かれてしまいます。 そのため、弾クラスを用意して、それを継承するようにします。 前章で作成した弾クラスのコンストラクタを一部修正します。 弾の画像に関する部分を消しています。 Bullet.cs using Altseed2; namespace Tutorial { // 弾のクラス public class Bullet : SpriteNode { // フレーム毎に進む距離 private Vector2F velocity; // コンストラクタ public Bullet(Vector2F position, Vector2F velocity) { // 座標を設定 Position = position; - // テクスチャを読み込む - Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); - - // 中心座標を設定 - CenterPosition = ContentSize / 2; // 弾速を設定 this.velocity = velocity; // 表示位置をプレイヤーや敵より奥に設定 ZOrder--; } // ================================================================ // 省略 // ================================================================ } } それに合わせて、プレイヤーのコードも変更します。 プレイヤーの弾クラスは弾クラスを継承するようにします。 それに合わせて、プレイヤーはプレイヤーの弾クラスを発射するようにします。 新たにBulletクラスを継承してPlayerBulletクラスを追加します。 PlayerBullet.cs using Altseed2; namespace Tutorial { // 自機弾 public class PlayerBullet : Bullet { // コンストラクタ public PlayerBullet(Vector2F position) : base(position, new Vector2F(10f, 0.0f)) { // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; } } } Player.cs PlayerBulletを撃つように変更します。 using Altseed2; namespace Tutorial { // プレイヤーのクラス public class Player : SpriteNode { // ================================================================ // 省略 // ================================================================ // ショット private void Shot() { // Zキーでショットを放つ if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { + Parent.AddChildNode(new PlayerBullet(Position)); - Parent.AddChildNode(new Bullet(Position, new Vector2F(10f, 0f))); } } } } 次に敵の弾と弾を打つ敵クラスを実装します。 基本的には味方が弾を打つ処理と、敵の移動を組み合わせたものになります。 それぞれ、敵の弾クラスは弾クラスを継承し、弾を打つ敵クラスは敵クラスを継承します。 StraightShotEnemy.cs using Altseed2; using System; namespace Tutorial { // まっすぐな弾を発射する敵 public class StraightShotEnemy : Enemy { // カウンタ private int count = 0; // コンストラクタ public StraightShotEnemy(Player player, Vector2F position) : base(player, position) { // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/UFO.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; // 倒された時に加算されるスコアを設定 score = 20; } // フレーム毎に実行 protected override void OnUpdate() { // カウントが150の倍数で実行 if (count % 150 == 0) { // プレイヤーに対するベクトルの単位ベクトルを取得 var velocity = (player.Position - Position).Normal; // ベクトルの長さを調整(弾速になる) velocity *= 5; // 弾を追加 Shot(velocity); } // 座標を設定 Position -= new Vector2F(MathF.Sin(MathHelper.DegreeToRadian(count)) * 3.0f, 0); // EnemyのOnUpdateを実行 base.OnUpdate(); // カウントを進める count++; } // 弾を撃つ private void Shot(Vector2F velocity) { // 敵弾を画面に追加 Parent.AddChildNode(new EnemyBullet(Position, velocity)); } } } EnemyBullet.cs using Altseed2; namespace Tutorial { // 敵の弾のクラス public class EnemyBullet : Bullet { // コンストラクタ public EnemyBullet(Vector2F position, Vector2F velocity) : base(position, velocity) { // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Bullet_Red.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; } } } この敵も出現するようにしましょう。 MainNodeに敵を追加します。 MainNode.cs using Altseed2; using System.Collections.Generic; namespace Tutorial { // メインステージのクラス public class MainNode : Node { // キャラクターを表示するノード private Node characterNode = new Node(); // プレイヤーの参照 private Player player; // エンジンに追加された時に実行 protected override void OnAdded() { // ================================================================ // 省略 // ================================================================ // 敵を追加する。 + characterNode.AddChildNode(new StraightShotEnemy(player, new Vector2F(600, 620))); characterNode.AddChildNode(new Meteor(player, new Vector2F(910, 400), new Vector2F(-4.0f, 0.0f))); } } } 他の敵 他の敵もそれぞれ実装します。 複数方向に打てる敵です。 経過時間を計測し、経過時間ごとに異なる方向に弾を打ちます。 RadialShotEnemy.cs using Altseed2; namespace Tutorial { // 放射ショットの敵 public class RadialShotEnemy : Enemy { // カウンタ変数 private int count = 0; // 撃ち出すショットの個数 private int shotAmount; // フレーム毎の速度 private Vector2F velocity; // コンストラクタ public RadialShotEnemy(Player player, Vector2F position, int shotAmount) : base(player, position) { // 撃ち出すショットの個数を設定 this.shotAmount = shotAmount; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/UFO.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; // スコアを設定 score = 30; } // フレーム毎に実行 protected override void OnUpdate() { // カウントが250の倍数だったら if (count % 250 == 0) { // 計算用のローカル変数 var half = shotAmount / 2; for (int i = 0; i < shotAmount; i++) { // 現時点の座標からプレイヤーに向かうベクトルの単位ベクトルを取得する var vector = (player.Position - Position).Normal; // ベクトルを速度分掛ける vector *= 7.0f; // ベクトルを傾ける vector.Degree += 30 * (i - half); // ショットを放つ Shot(vector); } } // カウント÷100の余りが0～49だったら if (count % 100 < 50) { // カウント÷100の余りが0だったら if (count % 100 == 0) { // 進むベクトルを設定 velocity = (player.Position - Position).Normal * 3.0f; } // 速度分ベクトルを設定 Position += velocity; } // EnemyクラスのOnUpdateを呼び出す base.OnUpdate(); // カウントを進める count++; } // 弾を撃つ private void Shot(Vector2F velocity) { // 敵弾を画面に追加 Parent.AddChildNode(new EnemyBullet(Position, velocity)); } } } プレイヤーを追いかける敵です。 プレイヤーへの参照を使用し、プレイヤーのほうに近づきます。 ChaseEnemy.cs using Altseed2; namespace Tutorial { // 追跡型敵 public class ChaseEnemy : Enemy { // 移動速度 private float speed; // コンストラクタ public ChaseEnemy(Player player, Vector2F position, float speed) : base(player, position) { // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/UFO.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; // 移動速度を設定 this.speed = speed; // 自身が倒された時に加算されるスコアを設定 score = 10; } // フレーム毎に実行 protected override void OnUpdate() { // プレイヤーへのベクトルの単位ベクトルを取得 var vector = (player.Position - Position).Normal; // ベクトルの長さを調整 vector *= speed; // ベクトル分座標を動かす Position += vector; // EnemyのOnUpdateを実行 base.OnUpdate(); } } } それぞれの敵を追加します。 using Altseed2; using System.Collections.Generic; namespace Tutorial { // メインステージのクラス public class MainNode : Node { // キャラクターを表示するノード private Node characterNode = new Node(); // プレイヤーの参照 private Player player; // エンジンに追加された時に実行 protected override void OnAdded() { // ================================================================ // 省略 // ================================================================ // 敵を追加する。 + characterNode.AddChildNode(new ChaseEnemy(player, new Vector2F(700, 160), 2.0f)); characterNode.AddChildNode(new StraightShotEnemy(player, new Vector2F(600, 620))); characterNode.AddChildNode(new Meteor(player, new Vector2F(910, 400), new Vector2F(-4.0f, 0.0f))); + characterNode.AddChildNode(new RadialShotEnemy(player, new Vector2F(400, 160), 3)); } } } 続・敵の出現 いままでのだと、敵が一気に出現するし、そのあとにも敵は出現しないので面白くありません。 そこで複数の敵が順番に出るようにします。 ここでは Queue というクラスを使用しています。 これはListと同じようなものですが、挙動が異なります。 Listは、常に内部のコレクションの最後に値を追加するのみで、追加した後は任意の値にアクセスできました。 一方、Queueは、内部のコレクションの最後に値を追加し、取得するときは一番最初に追加した値を取得して、その値をコレクションから取り除きます。 追加には、 Enqueue 、取り出しには、 Dequeue を使用します。 例えば、下記のような挙動になります。 Queue<int> queue = new Queue<int>(); queue.Enqueue(1); queue.Enqueue(2); // この時点ではqueueの中身には1,2がある int value = queue.Dequeue(); // 1が表示される。 // この時点ではqueueの中身には2がある Console.WriteLine(value); これを使用して敵を管理します。 親ノードには敵を追加せず、Queueに敵ノードを追加します。 そして、一定時間ごとにQueueから敵ノードを取り出し、追加することで敵が徐々に出現するようにします。 using Altseed2; + using System.Collections.Generic; namespace Tutorial { // メインステージのクラス public class MainNode : Node { + // カウンタ + private int count = 0; + // 敵を格納するキュー + private Queue<Enemy> enemies = new Queue<Enemy>(); // キャラクターを表示するノード private Node characterNode = new Node(); // プレイヤーの参照 private Player player; // エンジンに追加された時に実行 protected override void OnAdded() { // キャラクターノードを追加 AddChildNode(characterNode); // UIを表示するノード var uiNode = new Node(); // UIノードを追加 AddChildNode(uiNode); // 背景に使用するテクスチャ var backTexture = new SpriteNode(); // 背景のテクスチャを読み込む backTexture.Texture = Texture2D.LoadStrict(\"Resources/Background.png\"); // 表示位置を奥に設定 backTexture.ZOrder = -100; // 背景テクスチャを追加 AddChildNode(backTexture); // プレイヤーを設定 player = new Player(new Vector2F(100, 360)); // キャラクターノードにプレイヤーを追加 characterNode.AddChildNode(player); - characterNode.AddChildNode(new StraightShotEnemy(player, new Vector2F(600, 620))); - - characterNode.AddChildNode(new RadialShotEnemy(player, new Vector2F(400, 160), 3)); - - characterNode.AddChildNode(new StraightShotEnemy(player, new Vector2F(600, 620)); - - characterNode.AddChildNode(new ChaseEnemy(player, new Vector2F(700, 160), 2.0f)); + // ウェーブを初期化する + InitWave(); } + // ウェーブの初期化 + private void InitWave() + { + // enemies.Enqueue～でウェーブに敵を追加 + // 追加した順番に敵が出現する + + + enemies.Enqueue(new ChaseEnemy(player, new Vector2F(700, 160), 2.0f)); + + enemies.Enqueue(new StraightShotEnemy(player, new Vector2F(600, 620))); + + enemies.Enqueue(new Meteor(player, new Vector2F(910, 400), new Vector2F(-4.0f, 0.0f))); + + enemies.Enqueue(new RadialShotEnemy(player, new Vector2F(400, 160), 3)); + } + + // フレーム毎に実行 + protected override void OnUpdate() + { + // ステージの更新 + UpdateStage(); + + // カウントを進める + count++; + } + + // 敵召還関連 + private void UpdateStage() + { + // カウントが100の倍数だったら + if (count % 100 == 0) + { + // 敵が残っていたら画面に追加 + if (enemies.Count > 0) + { + characterNode.AddChildNode(enemies.Dequeue()); + } + } + } } } まとめ ここでは敵の処理を実装しました。 ただ、この章で弾は打てるようになりましたが、一切攻撃は命中しません。 次章では、弾が命中するようにします。"
  },
  "Tutorials/Chap6/index.html": {
    "href": "Tutorials/Chap6/index.html",
    "title": "6章 : 当たり判定の機能を使ってみよう | Altseed2",
    "keywords": "6章 : 当たり判定の機能を使ってみよう 5章では敵機と敵弾の作成までを行いました。しかしこのままでは当たり判定がないただのオブジェクトになってしまいます。 本章では敵機と敵弾に当たり判定をつけていきます。 当たり判定仕組み 「当たり判定」とは読んで字の如く、オブジェクト同士が当たっているかどうか判定するものです。当たり判定の実装方法には色々な手法が考えられますが、今回は簡単のために「円同士の当たり判定をピクセル単位で取る」という方法を扱います。 例えば下のような２つの円のオブジェクトを考え、２つの円の中心座標を考えてみましょう。２つの円の半径をa, bとおき、２つの円のx座標の差をd、y座標の差をeとおくと、中学校で習うような「三平方の定理」よりd²+e²<(a+b)²ならば２つの円は「ぶつかっている」ということになりますね。 当たり判定実装 当たり判定の仕組みは上で説明したとおりですが、自分で一から実装するのは面倒なのでAltseed2ではこの当たり判定をまとめたクラスである CircleCollider が用意されています。 早速この CircleCollider を使って当たり判定を実装していきましょう。 今回は自機、自弾、敵機、敵弾の4つに当たり判定をつけるので基底クラスとして CollidableObject クラスを用意してそれを継承していくような実装にします。 継承については以下を参照してください。 C# によるプログラミング入門 : 継承 CollidableObject のコードは以下のようになります。 using System.Collections.Generic; using Altseed2; namespace Tutorial { // 衝突可能なオブジェクト(円形) public class CollidableObject : SpriteNode { // コライダのコレクション public static HashSet<CollidableObject> objects = new HashSet<CollidableObject>(); // コライダ protected CircleCollider collider = new CircleCollider(); // OnUpdate内で衝突判定を調査するかどうか protected bool doSurvey; // 所属するメインノードへの参照 public MainNode mainNode; // コンストラクタ public CollidableObject(MainNode mainNode, Vector2F position) { // メインノードへの参照を設定 this.mainNode = mainNode; // コライダの座標を設定 collider.Position = position; // 座標を設定 Position = position; } // エンジンに追加された時に実行 protected override void OnAdded() { // コライダのコレクションに自身を追加 objects.Add(this); } // エンジンから削除された時に実行 protected override void OnRemoved() { // コライダのコレクションから自身を削除 objects.Remove(this); } // フレーム毎に実行 protected override void OnUpdate() { // フラグが成立時に衝突判定を実行 if (doSurvey) { Survey(); } // コライダの座標を更新 collider.Position = Position; } // 衝突時に実行 private void CollideWith(CollidableObject obj) { // nullだったら終了 if (obj == null) { return; } // 衝突対象がSurveyを実行しないオブジェクトだった場合，相手のOnCollisionも実行 if (!obj.doSurvey) { obj.OnCollision(this); } // 自身のOnCollisiionを実行 OnCollision(obj); } // 衝突時に実行される内容をオーバーライドして設定できる protected virtual void OnCollision(CollidableObject obj) { } // 画面外に出た時自身を消去 protected void RemoveMyselfIfOutOfWindow() { var halfSize = Texture.Size / 2; if (Position.X < -halfSize.X || Position.X > Engine.WindowSize.X + halfSize.X || Position.Y < -halfSize.Y || Position.Y > Engine.WindowSize.Y + halfSize.Y) { // 自身を削除 Parent?.RemoveChildNode(this); } } // 衝突判定を調査する private void Survey() { // objects内の全オブジェクトを検索し，衝突が確認されたオブジェクト間でCollideWithを実行 foreach (var obj in objects) if (collider.GetIsCollidedWith(obj.collider)) CollideWith(obj); } } } これまで SpriteNode を継承していたため、 CollidableObject でも SpriteNode を継承しています。 また、 Enemy クラスと Bullet クラスに定義していた RemoveMyselfIfOutOfWindow 関数ですが同じ処理が二か所にあって冗長です。基本的に同じ処理は一か所にまとめた方が良いのでそれぞれの親クラスになる CollidableObject でこの関数を定義することにします。 変数とコンストラクタを解説していきます。 // コライダのコレクション public static HashSet<CollidableObject> objects = new HashSet<CollidableObject>(); // コライダ protected CircleCollider collider = new CircleCollider(); // OnUpdate内で衝突判定を調査するかどうか protected bool doSurvey; // 所属するメインノードへの参照 public MainNode mainNode; // コンストラクタ public CollidableObject(MainNode mainNode, Vector2F position) { // メインノードへの参照を設定 this.mainNode = mainNode; // コライダの座標を設定 collider.Position = position; // 座標を設定 Position = position; } それぞれのコライダとの当たり判定をとるためにコライダのコレクションを保存しておく必要があります。コライダオブジェクトは変数 objects に保存します。 この変数 objects の宣言には static というキーワードが使われています。これは静的メンバーと呼ばれるもので、すべてのインスタンスから共有されるような変数を宣言できます。詳しい説明は以下のリンク先を参照してください。 C# によるプログラミング入門 : 静的メンバー 変数 collider はコライダの本体で、先ほど言ったようにAltseed2で用意された CircleCollider を使用します。 doSurvey と mainNode はコメントにある通りです。 コンストラクタの collider.Position = position はコライダの位置設定で Position = position は本体の描画されているオブジェクトの位置設定であることに注意してください。 次に OnUpdate です。 // フレーム毎に実行 protected override void OnUpdate() { // フラグが成立時に衝突判定を実行 if (doSurvey) { Survey(); } // コライダの座標を更新 collider.Position = Position; } 先ほど定義した doSurvey のフラグが true の場合後述する Survey 関数が呼ばれて当たり判定が開始します。 オブジェクトが動いてもコライダの位置は変わらないのでコライダとオブジェクトの位置と同期させるために collider.Position = Position; としています。 さらに OnAdded 関数と OnRemoved 関数があると思います。こちらはエンジンにオブジェクトが追加されたタイミングと消去されたタイミングで呼ばれます。この時変数 objects に追加と削除をしてエンジンに追加されているオブジェクトのみをコレクションに残しておきます。 Survey関数です。 // 衝突判定を調査する private void Survey() { // objects内の全オブジェクトを検索し，衝突が確認されたオブジェクト間でCollideWithを実行 foreach (var obj in objects) if (collider.GetIsCollidedWith(obj.collider)) CollideWith(obj); } コライダ間の衝突は GetIsCollidedWith 関数で取ることができます。この関数は衝突している場合 true を返すのでif文で衝突した場合に CollideWith が呼ばれます。 CollideWith には衝突した場合の処理を書いていきます。 ここで、 foreach とは for 文の拡張で、 foreach (var obj in objects) というのは、 「 objects の要素をとりだして、 obj と名前を付ける」 ことを objects の全要素について行ってくれます。 今回は foreach 文を使って objects から取り出した CollidableObject である obj のコライダ obj.collider と自身のコライダ collider の間での当たり判定を取っています。 また、 var というキーワードがあります。これは 型推論 と呼ばれるもので、名前の通り変数の宣言の際に型を推論してくれるというものです。なので上の foreach 文は foreach (CollidableObject obj in objects) if (collider.GetIsCollidedWith(obj.collider)) CollideWith(obj); このようにしても大丈夫です。ただ、 var を使ったほうが記述が短くて楽です。 foreach と var についての詳しい解説を以下に載せておきます。 C# によるプログラミング入門 : foreach C# によるプログラミング入門 : 型推論 CollideWith 関数では衝突時の処理を書いていきます。 // 衝突時に実行 private void CollideWith(CollidableObject obj) { // nullだったら終了 if (obj == null) { return; } // 衝突対象がSurveyを実行しないオブジェクトだった場合，相手のOnCollisionも実行 if (!obj.doSurvey) { obj.OnCollision(this); } // 自身のOnCollisiionを実行 OnCollision(obj); } ここで， Survey を実行しないオブジェクト(= doSurvey が false )に対して OnCollision を呼び出しています。 何故，全ての CollidableObject に対して Survey を実行させず， doSurvey のような面倒な処理を挟むのかというのが気になるかと思います。 後々説明しますが， doSurvey フラグは自機や敵では true ，自機弾や敵弾では false にします。 もし仮に全ての CollidableObject にて Survey を走らせるとなると，衝突判定が計算される回数は objects に登録されている CollidableObject の2乗に相当します。 弾というオブジェクトは，自機や敵の個数に比べて大量に画面上に出現する機会が多いです。その為，弾幕シューティングを作ったときなどは処理が重くなることがあります。 それを避けるために doSurvey というフラグを用いて Survey を実行する回数を最小限に留める事が出来ます。 プログラミングを行う際はこのようにパフォーマンスを意識するという事も大事です(最初のうちは動くこと重視，慣れてきたら意識すると良いです)。 オブジェクトにより当たった時の処理は異なるので継承先で OnCollision 関数をオーバーライドさせて処理を継承先に委託するようにしています。 OnCollision 関数にあるキーワード virtual は仮想メソッドと呼ばれるものでこれをつけることで継承先で関数のオーバーライドができます。 C# によるプログラミング入門 : 多態性 // 衝突時に実行される内容をオーバーライドして設定できる protected virtual void OnCollision(CollidableObject obj) { } 当たり判定を持つクラスへの切り替え ざっとですが基本的なコライダの使い方を解説しました。 次は継承先での処理を作っていきましょう。 まずは各クラスを CollidableObject から継承させるようにします。 Player クラス - public class Player : SpriteNode + public class Player : CollidableObject Enemy クラス - public class Enemy : SpriteNode + public class Enemy : CollidableObject Bullet クラス - class Bullet : SpriteNode + class Bullet : CollidableObject さらにコンストラクタも書き換えていきます。 冒頭でも少し触れましたが Enemy クラスと Bullet クラスの RemoveMyselfIfOutOfWindow 関数は親クラスである CollidableObject に移したのでついでに削除しましょう。 また， CollidableObject の OnUpdate に処理を書いたので， base.OnUpdate を呼び出しましょう。 Player クラス using Altseed2; namespace Tutorial { // プレイヤーのクラス public class Player : CollidableObject { // コンストラクタ - public Player(Vector2F position) + public Player(MainNode mainNode, Vector2F position) : base(mainNode, position) { - // 座標を設定 - Position = position; + // 衝突判定を行うように設定 + doSurvey = true; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; + // コライダの半径を設定 + collider.Radius = Texture.Size.Y / 2; } // フレーム毎に実行 protected override void OnUpdate() { // 移動を実行 Move(); // ショットを実行 Shot(); + // CollidableObjectのOnUpdate呼び出し + base.OnUpdate(); } ...略... } } Enemy クラス using Altseed2; namespace Tutorial { // 敵の基礎となるクラス public class Enemy : CollidableObject { // 倒された時に加算されるスコアの値 protected int score; // プレイヤーへの参照 protected Player player; // コンストラクタ - public Enemy(Player player, Vector2F position) + public Enemy(Player player, Vector2F position) : base(player.mainNode, position) { + // 衝突判定を行うように設定 + doSurvey = true; - // 座標を設定 - Position = position; // プレイヤーへの参照を設定 this.player = player; } // フレーム毎に実行 protected override void OnUpdate() { // CollidableObjectのOnUpdateを実行 base.OnUpdate(); + // 画面外に出たら自身を削除 + RemoveMyselfIfOutOfWindow(); } - private void RemoveMyselfIfOutOfWindow() - { - var halfSize = Texture.Size / 2; - if (Position.X < -halfSize.X - || Position.X > Engine.WindowSize.X + halfSize.X - || Position.Y < -halfSize.Y - || Position.Y > Engine.WindowSize.Y + halfSize.Y) - { - // 自身を削除 - Parent?.RemoveChildNode(this); - } - } } } Bullet クラス using Altseed2; namespace Tutorial { // 弾のクラス public class Bullet : CollidableObject { // フレーム毎に進む距離 private Vector2F velocity; // コンストラクタ - public Bullet(Vector2F position, Vector2F velocity) + public Bullet(MainNode mainNode, Vector2F position, Vector2F velocity) : base(mainNode, position) { + // 衝突判定を行わないように設定 + doSurvey = false; - // 座標を設定 - Position = position; // 弾速を設定 this.velocity = velocity; // 表示位置をプレイヤーや敵より奥に設定 ZOrder--; } // フレーム毎に実行 protected override void OnUpdate() { // 座標を速度分進める Position += velocity; + // CollidableObjectのOnUpdateを呼び出す + base.OnUpdate(); // 画面外に出たら自身を削除 RemoveMyselfIfOutOfWindow(); } - private void RemoveMyselfIfOutOfWindow() - { - var halfSize = Texture.Size / 2; - if (Position.X < -halfSize.X - || Position.X > Engine.WindowSize.X + halfSize.X - || Position.Y < -halfSize.Y - || Position.Y > Engine.WindowSize.Y + halfSize.Y) - { - // 画面外に出たら自身を削除 - Parent?.RemoveChildNode(this); - } - } } } ここでコンストラクタの後ろに base というキーワードが出てきました。これは親クラスのコンストラクタ呼び出しという意味です。今回だと ColliderObject のコンストラクタを呼び出します。 ColliderObject のコンストラクタでは MainNode と position が必要なため base の後の引数で受け渡します。 base についての詳しい解説はこちらを参照してください。 C# によるプログラミング入門 : 継承 また、 ColliderObject のコンストラクタで座標を設定する処理があるので子クラスでは座標を設定するコードは消しています。 Bullet の修正に併せて EnemyBullet と PlayerBullet のコードも修正していきましょう。 これらはコンストラクタの引数変更と半径を設定させるだけで大丈夫です EnemyBullet クラス + public EnemyBullet(MainNode mainNode, Vector2F position, Vector2F velocity) : base(mainNode, position, velocity) - public EnemyBullet(Vector2F position, Vector2F velocity) : base(position, velocity) { // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Bullet_Red.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; + // 半径を設定 + collider.Radius = Texture.Size.X / 2; } PlayerBullet クラス + public PlayerBullet(MainNode mainNode, Vector2F position) : base(mainNode, position, new Vector2F(10f, 0.0f)) - public PlayerBullet(Vector2F position) : base(position, new Vector2F(10f, 0.0f)) { // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Bullet_Blue.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; + // 半径を設定 + collider.Radius = Texture.Size.X / 2; } 次に Enemy クラスの変更に併せてその派生クラスである ChaseEnemy クラスと RadialShotEnemy クラスと StraightShotEnemy クラスと Meteor クラスを書き換えていきます。先ほど EnemyBullet クラスの引数を変更したので Shot 関数の EnemyBullet を生成するコードもついでに書き換えましょう。 ChaseEnemy クラス public ChaseEnemy(Player player, Vector2F position, float speed) : base(player, position) { // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/UFO.png\"); // 中心座標を設定 CenterPosition = ConentSize / 2; + // 半径を設定 + collider.Radius = Texture.Size.X / 2; // 移動速度を設定 this.speed = speed; // 自身が倒された時に加算されるスコアを設定 score = 10; } RadialShotEnemy クラス public RadialShotEnemy(Player player, Vector2F position, int shotAmount) : base(player, position) { // 撃ち出すショットの個数を設定 this.shotAmount = shotAmount; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/UFO.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; + // 半径を設定 + collider.Radius = Texture.Size.X / 2; // スコアを設定 score = 30; } // 弾を撃つ private void Shot(Vector2F velocity) { // 敵弾を画面に追加 + Parent.AddChildNode(new EnemyBullet(mainNode, Position, velocity)); - Parent.AddChildNode(new EnemyBullet(Position, velocity)); } StraightShotEnemy クラス public StraightShotEnemy(Player player, Vector2F position) : base(player, position) { // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/UFO.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; + // 半径を設定 + collider.Radius = Texture.Size.X / 2; // 倒された時に加算されるスコアを設定 score = 20; } // 弾を撃つ private void Shot(Vector2F velocity) { // 敵弾を画面に追加 + Parent.AddChildNode(new EnemyBullet(mainNode, Position, velocity)); - Parent.AddChildNode(new EnemyBullet(Position, velocity)); } Meteor クラス public Meteor(Player player, Vector2F position, Vector2F velocity) : base(player, position) { // 速度の設定 this.velocity = velocity; // テクスチャの設定 Texture = Texture2D.LoadStrict(\"Resources/Meteor.png\"); // 中心座標の設定 CenterPosition = ContentSize / 2; + // 半径の設定 + collider.Radius = Texture.Size.X / 2; // スコアの設定 score = 1; } さらに Player クラスで PlayerBullet を使用していたのでこちらも修正が必要になります。 Player クラスの Shot 関数 // ショット private void Shot() { // Zキーでショットを放つ if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { + Parent.AddChildNode(new PlayerBullet(mainNode, Position)); - Parent.AddChildNode(new PlayerBullet(Position)); } } 最後に MainNode クラスを修正します。まず、 Player クラスの呼び出しの変更が必要です。さらにもう一つ変更が必要です。もし MainNode が消去されてもコライダがコレクションに残っている場合、使われていないコライダがコレクションに保存され続けるとになります。この場合、ゲームのリトライなどを行うとリトライ前のコライダが残ってしまい、バグなどを引き起こす恐れがあるのでコライダの消去を行います。 HashSet クラスの中身消去は Clear 関数でできます。 MainNode クラス protected override void OnAdded() { // ================================================================ // 省略 // ================================================================ // プレイヤーを設定 + player = new Player(this, new Vector2F(100, 360)); - player = new Player(new Vector2F(100, 360)); // ================================================================ // 省略 // ================================================================ } + // エンジンから削除されたときに実行 + protected override void OnRemoved() + { + // 衝突判定を全てリセット + CollidableObject.objects.Clear(); + } これでひと段落と思いきや、衝突時の処理をまだ書いていないので衝突してもまだ何も起こりません。次にそれぞれのクラスで衝突した時の処理を書いていきたいところですが、先に衝突したときのエフェクトを作りましょう。 Effectを作成するクラス 衝突したときに出すエフェクトである DeathEffect クラスを作ります。 DeathEffect のコードは以下のようになります。 using Altseed2; namespace Tutorial { // 死亡時エフェクト public class DeathEffect : SpriteNode { // カウンタ private int count = 0; // コンストラクタ public DeathEffect(Vector2F position) { // 座標を設定 Position = position; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Explosion.png\"); // 中心座標を設定 CenterPosition = new Vector2F(32f, 32f); // 表示位置をプレイヤーや敵よりも手前に設定 ZOrder++; // テクスチャの描画範囲を設定 Src = new RectF(new Vector2F(), new Vector2F(Texture.Size.X / 9, Texture.Size.Y)); } // フレーム毎に実行 protected override void OnUpdate() { // 表示されるテクスチャのサイズを取得 var size = new Vector2F(Texture.Size.X / 9, Texture.Size.Y); // 表示されるテクスチャの左上の座標を計算する var pos = new Vector2F(size.X * (count / 2 % 9), size.Y); // 描画範囲を設定 Src = new RectF(pos, size); // カウントを進める count++; // カウントが18以上で自身を削除 if (count >= 18) { Parent.RemoveChildNode(this); } } } } どのように実装されているかというと以下のような画像の一部を表示して表示位置をずらしてあげることでアニメーションのような効果を出しています。 コード中で使われている Src について説明します。今までは Texture に設定された画像全てを描画していましたが、今回は画像の一部だけを切り取って描画する必要があります。 そこで、 Src を使用します。 Src は SpriteNode クラスの持つフィールドで、 Src に値を設定すると画像の中で指定された範囲のみが描画されるようになります。 Src に値を設定する方法ですが、第一引数は表示したい範囲の左上の座標を、第二引数はその座標から表示する範囲を指定します // 描画範囲を設定 Src = new RectF(pos, size); 設定する変数 size と pos は count という毎フレーム1ずつ増える整数の変数を作って計算します。今回は2フレームごとに画像をずらすような式にしてあります。上に示した画像は爆破の画像が横に9枚並んでいるもので、2フレーム×9=18なので count が18になった場合 Parent.RemoveChildNode(this); により自身を削除してエフェクトの再生を終了します。 // 表示されるテクスチャのサイズを取得 var size = new Vector2F(Texture.Size.X / 9, Texture.Size.Y); // 表示されるテクスチャの左上の座標を計算する var pos = new Vector2F(size.X * (count / 2 % 9), size.Y); // 描画範囲を設定 Src = new RectF(pos, size); // カウントを進める count++; // カウントが18以上で自身を削除 if (count >= 18) { Parent.RemoveChildNode(this); } 爆破のエフェクトが完成したので衝突時の処理を書いていきましょう。 OnCollideの実装 CollidableObject では衝突したときに OnCollide 関数を呼び出すように実装しましたね。なので子クラスで OnCollide 関数の中身を記述してあげればよいです。 衝突時に処理するクラスは Player と Enemy と PlayerBullet と EnemyBullet の4クラスになります。 これら4つの OnCollide 関数を以下に載せます。 Player クラス // 衝突時に実行 protected override void OnCollision(CollidableObject obj) { // 衝突対象が敵か敵の弾だったら if (obj is Enemy || obj is EnemyBullet) { // 自身を親から削除 Parent.RemoveChildNode(this); } } PlayerBullet クラス // 衝突時に実行 protected override void OnCollision(CollidableObject obj) { // 衝突対象が敵だったら自身を削除 if (obj is Enemy) { Parent?.RemoveChildNode(this); } } Enemy クラス // 衝突時に実行 protected override void OnCollision(CollidableObject obj) { // 衝突対象が自機弾だったら if (obj is PlayerBullet) { // 死亡時エフェクトを再生 Parent.AddChildNode(new DeathEffect(Position)); // 自身を削除 Parent.RemoveChildNode(this); } } EnemyBullet クラス // 衝突時に実行 protected override void OnCollision(CollidableObject obj) { // 衝突対象がプレイヤーだったらBulletのOnCollisionを実行して削除 if (obj is Player) { Parent?.RemoveChildNode(this); } } ここで is というキーワードがありますね。これは is演算子 と呼ばれるものです。この is というのは変数 obj がどの型を継承しているのか判断するために使えます。一例ですが、 if (obj is Enemy) と書けば、 obj が Enemy クラスか、その派生クラスの時に処理をすることができます。 余談ですが似たような機能に as演算子 というものがあります。こちらは戻り値が bool ではなく型変換したものになります。 is演算子 と as演算子 について詳しく知りたい方は以下を参照してください。 C# によるプログラミング入門 : 多態性 Meteorクラス改変 今、 Meteor クラスの衝突処理は Enemy クラスの OnCollide が呼ばれるので、 Player の弾に当たると消滅します。これで完成してもよいのですが、 Meteor というからには岩石で硬いはずなので Player の弾ごとき3回くらいまでなら耐えると思います。 そのように改変しましょう。 Meteor クラス using Altseed2; namespace Tutorial { // 隕石 public class Meteor : Enemy { // フレーム毎の移動速度 private Vector2F velocity; + // HP + private int HP = 3; // コンストラクタ、OnUpdate略 + protected override void OnCollision(CollidableObject obj) + { + // 衝突したのが自機弾だったら + if (obj is PlayerBullet) + { + // HPを1減らす + HP--; + // HPが0になったらEnemyクラスのOnCollisionを呼び出して削除 + if (HP == 0) + { + base.OnCollision(obj); + } + } + } + } } HPというフィールドを追加して、プレイヤーの弾に当たる度にHPを1減らしていき、HPが0になったら消滅するというシンプルな処理です。 このように Enemy クラスでオーバーライドした OnCollision をさらにオーバーライドすると親クラスの OnCollision は呼ばれなくなり、子クラスの処理に切り替わります。 長い工程を経て衝突判定と衝突時の処理が完成しました。実行してみると敵に衝突したり、自弾が敵に衝突したときにエフェクトが出て画面から消えることが確認できると思います。 まとめ 今回は衝突判定をつけてみました。ようやくゲームらしさが増してきましたね。 Altseed2 では CircleCollider 以外にも多角形のコライダである PolygonCollier クラスや四角形のコライダである RectangleCollider クラスがあります。もし、厳密さが必要な形のオブジェクトに衝突判定をつけたい場合はそちらを使ってみてください。 次章では音を鳴らしてみます。"
  },
  "Tutorials/Chap7/index.html": {
    "href": "Tutorials/Chap7/index.html",
    "title": "7章 : 音を鳴らしてみよう | Altseed2",
    "keywords": "7章 : 音を鳴らしてみよう 前章では、当たり判定を実装しました。 この章では、ゲームに不可欠な音を追加します。 ゲームには、オブジェクトの動きに合わせたサウンドエフェクト(SE)やゲームの雰囲気を作り出すBGMが必要です。 以下では、SEやBGMを再生する処理を実装します。 SEを鳴らす 今回は、以下のSEを再生します。 プレイヤーのショット音 プレイヤーの死亡時サウンド 敵共通の死亡時サウンド まっすぐな弾を発射する敵のショット音 放射ショットの敵のショット音 プレイヤーのショット音を追加 Player.cs に以下のソースコードを追加します。 using Altseed2; namespace Tutorial { // プレイヤーのクラス public class Player : CollidableObject { + // ショット時の効果音 + private Sound shotSound; // コンストラクタ public Player(MainNode mainNode, Vector2F position) : base(mainNode, position) { // 衝突判定を行うように設定 doSurvey = true; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; // コライダの半径を設定 collider.Radius = Texture.Size.Y / 2; + // ショット音を読み込む + shotSound = Sound.LoadStrict(\"Resources/shot1.wav\", true); } // 衝突時に実行 protected override void OnCollision(CollidableObject obj) { // 衝突対象が敵か敵の弾だったら if (obj is Enemy || obj is EnemyBullet) { // 自身を親から削除 Parent.RemoveChildNode(this); } } // フレーム毎に実行 protected override void OnUpdate() { // 移動を実行 Move(); // ショットを実行 Shot(); // CollidableObjectのOnupdate呼び出し base.OnUpdate(); } // 移動を行う private void Move() { // 現在のX座標を取得する var x = Position.X; // 現在のY座標を取得する var y = Position.Y; // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { y -= 2.5f; } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { y += 2.5f; } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { x += 2.5f; } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { x -= 2.5f; } // テクスチャのサイズの半分を取得する var halfSize = Texture.Size / 2; // X座標が画面外に行かないように調整 x = MathHelper.Clamp(x, Engine.WindowSize.X - halfSize.X, halfSize.X); // Y座標が画面外に行かないように調整 y = MathHelper.Clamp(y, Engine.WindowSize.Y - halfSize.Y, halfSize.Y); // 調整された座標を設定 Position = new Vector2F(x, y); } // ショット private void Shot() { // Zキーでショットを放つ if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { Parent.AddChildNode(new PlayerBullet(mainNode, Position)); + // ショット音を鳴らす + Engine.Sound.Play(shotSound); } } } } // ショット時の効果音 private Sound shotSound; Altseed2では、音源データを Sound クラスインスタンスに格納します。 また、ファイルから音源データを読み込む場合は、以下のように Sound.LoadStrict メソッドを用います。 // ショット音を読み込む shotSound = Sound.LoadStrict(\"Resources/shot1.wav\", true); 第一引数には、音源データファイルへのパスします。 そして、第二引数には、音源データを事前に解凍するか否かを指定します。 一般的に、短い音をたくさん鳴らすようなSEの場合は、事前に解凍します。 一方、BGMのような長い音源に対しては、事前に解凍せず、逐次解凍するようにします。 そして、読み込んだ音源データを再生するには、以下のように Engine.Sound.Play メソッドを呼び出す必要があります。 // ショット音を鳴らす Engine.Sound.Play(shotSound); 引数として、上で作成した Sound クラスインスタンスを渡します。 この段階でビルドし、実行するとZキーでショットを放った瞬間に音が鳴ると思います。 プレイヤーの死亡時サウンドを追加 ショット音と同様に Player.cs に以下のソースコードを追加します。 using Altseed2; namespace Tutorial { // プレイヤーのクラス public class Player : CollidableObject { // ショット時の効果音 private Sound shotSound; // コンストラクタ public Player(MainNode mainNode, Vector2F position) : base(mainNode, position) { // 衝突判定を行うように設定 doSurvey = true; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/Player.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; // コライダの半径を設定 collider.Radius = Texture.Size.Y / 2; // ショット音を読み込む shotSound = Sound.LoadStrict(\"Resources/shot1.wav\", true); } // 衝突時に実行 protected override void OnCollision(CollidableObject obj) { // 衝突対象が敵か敵の弾だったら if (obj is Enemy || obj is EnemyBullet) { + // 死亡音を読み込む + var deathSound = Sound.LoadStrict(\"Resources/Explosion.wav\", true); + + // 死亡音を再生 + Engine.Sound.Play(deathSound); + // 自身を親から削除 Parent.RemoveChildNode(this); } } // フレーム毎に実行 protected override void OnUpdate() { // 移動を実行 Move(); // ショットを実行 Shot(); // CollidableObjectのOnupdate呼び出し base.OnUpdate(); } // 移動を行う private void Move() { // 現在のX座標を取得する var x = Position.X; // 現在のY座標を取得する var y = Position.Y; // ↑キーでY座標を減少 if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold) { y -= 2.5f; } // ↓キーでY座標を増加 if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold) { y += 2.5f; } // →キーでX座標を増加 if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold) { x += 2.5f; } // ←キーでX座標を減少 if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold) { x -= 2.5f; } // テクスチャのサイズの半分を取得する var halfSize = Texture.Size / 2; // X座標が画面外に行かないように調整 x = MathHelper.Clamp(x, Engine.WindowSize.X - halfSize.X, halfSize.X); // Y座標が画面外に行かないように調整 y = MathHelper.Clamp(y, Engine.WindowSize.Y - halfSize.Y, halfSize.Y); // 調整された座標を設定 Position = new Vector2F(x, y); } // ショット private void Shot() { // Zキーでショットを放つ if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { Parent.AddChildNode(new PlayerBullet(mainNode, Position)); // ショット音を鳴らす Engine.Sound.Play(shotSound); } } } } 敵共通の死亡時サウンドを追加 すべての敵共通で再生するため、 Enemy.cs に以下のソースコードを追加します。 using Altseed2; namespace Tutorial { // 敵の基礎となるクラス public class Enemy : CollidableObject { // 倒された時に加算されるスコアの値 protected int score; // プレイヤーへの参照 protected Player player; // コンストラクタ public Enemy(Player player, Vector2F position) : base(player.mainNode, position) { // 衝突判定を行うように設定 doSurvey = true; // プレイヤーへの参照を設定 this.player = player; } // 衝突時に実行 protected override void OnCollision(CollidableObject obj) { // 衝突対象が自機弾だったら if (obj is PlayerBullet) { // スコアを加算 mainNode.score += score; // 死亡時エフェクトを再生 Parent.AddChildNode(new DeathEffect(Position)); // 自身を削除 Parent.RemoveChildNode(this); + // 死亡時サウンドを読み込み + var deathSound = Sound.LoadStrict(\"Resources/Explosion.wav\", true); + + // 死亡時サウンドを再生 + Engine.Sound.Play(deathSound); } } // フレーム毎に実行 protected override void OnUpdate() { // CollidableObjectのOnUpdateを実行 base.OnUpdate(); // 画面外に出たら自身を削除 RemoveMyselfIfOutOfWindow(); } } } まっすぐな弾を発射する敵のショット音を追加 StraightShotEnemy.cs に以下のソースコードを追加します。 using Altseed2; using System; namespace Tutorial { // まっすぐな弾を発射する敵 public class StraightShotEnemy : Enemy { // カウンタ private int count = 0; + // ショット時の効果音 + private Sound shotSound; // コンストラクタ public StraightShotEnemy(Player player, Vector2F position) : base(player, position) { // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/UFO.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; // 半径を設定 collider.Radius = Texture.Size.X / 2; // 倒された時に加算されるスコアを設定 score = 20; + // ショット時の効果音を読み込む + shotSound = Sound.LoadStrict(\"Resources/shot2.wav\", true); } // フレーム毎に実行 protected override void OnUpdate() { // カウントが150の倍数で実行 if (count % 150 == 0) { // プレイヤーに対するベクトルの単位ベクトルを取得 var velocity = (player.Position - Position).Normal; // ベクトルの長さを調整(弾速になる) velocity *= 5; // 弾を追加 Shot(velocity); } // 座標を設定 Position -= new Vector2F(MathF.Sin(MathHelper.DegreeToRadian(count)) * 3.0f, 0); // EnemyのOnUpdateを実行 base.OnUpdate(); // カウントを進める count++; } // 弾を撃つ private void Shot(Vector2F velocity) { // 敵弾を画面に追加 Parent.AddChildNode(new EnemyBullet(mainNode, Position, velocity)); + // ショット音を再生 + Engine.Sound.Play(shotSound); } } } 放射ショットの敵のショット音を追加 RadialShotEnemy.cs に以下のソースコードを追加します。 using Altseed2; namespace Tutorial { // 放射ショットの敵 public class RadialShotEnemy : Enemy { // カウンタ変数 private int count = 0; // 撃ち出すショットの個数 private int shotAmount; + // ショット時の効果音 + private Sound shotSound; // フレーム毎の速度 private Vector2F velocity; // コンストラクタ public RadialShotEnemy(Player player, Vector2F position, int shotAmount) : base(player, position) { // 撃ち出すショットの個数を設定 this.shotAmount = shotAmount; // テクスチャを読み込む Texture = Texture2D.LoadStrict(\"Resources/UFO.png\"); // 中心座標を設定 CenterPosition = ContentSize / 2; // 半径を設定 collider.Radius = Texture.Size.X / 2; // スコアを設定 score = 30; + // ショット時の効果音を読み込む + shotSound = Sound.LoadStrict(\"Resources/shot2.wav\", true); } // フレーム毎に実行 protected override void OnUpdate() { // カウントが250の倍数だったら if (count % 250 == 0) { // 計算用のローカル変数 var half = shotAmount / 2; for (int i = 0; i < shotAmount; i++) { // 現時点の座標からプレイヤーに向かうベクトルの単位ベクトルを取得する var vector = (player.Position - Position).Normal; // ベクトルを速度分掛ける vector *= 7.0f; // ベクトルを傾ける vector.Degree += 30 * (i - half); // ショットを放つ Shot(vector); } } // カウント÷100の余りが0～49だったら if (count % 100 < 50) { // カウント÷100の余りが0だったら if (count % 100 == 0) { // 進むベクトルを設定 velocity = (player.Position - Position).Normal * 3.0f; } // 速度分ベクトルを設定 Position += velocity; } // EnemyクラスのOnUpdateを呼び出す base.OnUpdate(); // カウントを進める count++; } // 弾を撃つ private void Shot(Vector2F velocity) { // 敵弾を画面に追加 Parent.AddChildNode(new EnemyBullet(mainNode, Position, velocity)); + // ショット音を再生 + Engine.Sound.Play(shotSound); } } } 以上を追加し、ビルドするとSEが適切なタイミングで再生されると思います。 BGMを鳴らす 次は、BGMを再生する処理を追加しましょう。 メインステージのBGMであるため、 MainNode.cs に以下のソースコードを追加します。 using Altseed2; using System.Collections.Generic; namespace Tutorial { // メインステージのクラス public class MainNode : Node { // カウンタ private int count = 0; // 敵を格納するキュー private Queue<Enemy> enemies = new Queue<Enemy>(); // キャラクターを表示するノード private Node characterNode = new Node(); // プレイヤーの参照 private Player player; // エンジンに追加された時に実行 protected override void OnAdded() { // キャラクターノードを追加 AddChildNode(characterNode); // UIを表示するノード var uiNode = new Node(); // UIノードを追加 AddChildNode(uiNode); // 背景に使用するテクスチャ var backTexture = new SpriteNode(); // 背景のテクスチャを読み込む backTexture.Texture = Texture2D.LoadStrict(\"Resources/Background.png\"); // 表示位置を奥に設定 backTexture.ZOrder = -100; // 背景テクスチャを追加 AddChildNode(backTexture); // プレイヤーを設定 player = new Player(this, new Vector2F(100, 360)); // キャラクターノードにプレイヤーを追加 characterNode.AddChildNode(player); // ウェーブを初期化する InitWave(); + // BGMを初期化する + InitBGM(); } // エンジンから削除されたときに実行 protected override void OnRemoved() { // 衝突判定を全てリセット CollidableObject.objects.Clear(); } + // BGMを初期化 + private void InitBGM() + { + // BGMを読み込む + var bgm = Sound.LoadStrict(\"Resources/BGM.wav\", false); + + // BGMのプレイ開始 + Engine.Sound.Play(bgm); + } // ウェーブの初期化 private void InitWave() { // enemies.Enqueue～でウェーブに敵を追加 // 追加した順番に敵が出現する enemies.Enqueue(new ChaseEnemy(player, new Vector2F(700, 160), 2.0f)); enemies.Enqueue(new StraightShotEnemy(player, new Vector2F(600, 620))); enemies.Enqueue(new Meteor(player, new Vector2F(910, 400), new Vector2F(-4.0f, 0.0f))); enemies.Enqueue(new RadialShotEnemy(player, new Vector2F(400, 160), 3)); } // フレーム毎に実行 protected override void OnUpdate() { // ステージの更新 UpdateStage(); // カウントを進める count++; } // 敵召還関連 private void UpdateStage() { // カウントが100の倍数だったら if (count % 100 == 0) { // 敵が残っていたら画面に追加 if (enemies.Count > 0) { characterNode.AddChildNode(enemies.Dequeue()); } } } } } BGMに関する初期化をするメソッド InitBGM を実装し、 メインステージが始まった時点で再生するため、 OnAdded で呼び出します。 BGMを再生する場合も、基本的はSEと変わらず、 Sound クラスインスタンスを用います。 しかし、このままではうまくいきません。 今回、BGMを再生するために、以下の処理が必要となります。 ループ処理 再生している音の制御(一時停止、終了) ループ処理 InitBGM メソッドに以下の処理を追加しましょう。 using Altseed2; using System.Collections.Generic; namespace Tutorial { // メインステージのクラス public class MainNode : Node { // カウンタ private int count = 0; // 敵を格納するキュー private Queue<Enemy> enemies = new Queue<Enemy>(); // キャラクターを表示するノード private Node characterNode = new Node(); // プレイヤーの参照 private Player player; // エンジンに追加された時に実行 protected override void OnAdded() { // キャラクターノードを追加 AddChildNode(characterNode); // UIを表示するノード var uiNode = new Node(); // UIノードを追加 AddChildNode(uiNode); // 背景に使用するテクスチャ var backTexture = new SpriteNode(); // 背景のテクスチャを読み込む backTexture.Texture = Texture2D.LoadStrict(\"Resources/Background.png\"); // 表示位置を奥に設定 backTexture.ZOrder = -100; // 背景テクスチャを追加 AddChildNode(backTexture); // プレイヤーを設定 player = new Player(this, new Vector2F(100, 360)); // キャラクターノードにプレイヤーを追加 characterNode.AddChildNode(player); // ウェーブを初期化する InitWave(); // BGMを初期化する InitBGM(); } // エンジンから削除されたときに実行 protected override void OnRemoved() { // 衝突判定を全てリセット CollidableObject.objects.Clear(); } // BGMを初期化 private void InitBGM() { // BGMを読み込む var bgm = Sound.LoadStrict(\"Resources/BGM.wav\", false); + // BGMをループするように設定 + bgm.IsLoopingMode = true; + + // ループ開始位置を設定 + bgm.LoopStartingPoint = 11.33f; + + // ループ終了位置を設定 + bgm.LoopEndPoint = 33.93f; // BGMのプレイ開始 Engine.Sound.Play(bgm); } // ウェーブの初期化 private void InitWave() { // enemies.Enqueue～でウェーブに敵を追加 // 追加した順番に敵が出現する enemies.Enqueue(new ChaseEnemy(player, new Vector2F(700, 160), 2.0f)); enemies.Enqueue(new StraightShotEnemy(player, new Vector2F(600, 620))); enemies.Enqueue(new Meteor(player, new Vector2F(910, 400), new Vector2F(-4.0f, 0.0f))); enemies.Enqueue(new RadialShotEnemy(player, new Vector2F(400, 160), 3)); } // フレーム毎に実行 protected override void OnUpdate() { // ステージの更新 UpdateStage(); // カウントを進める count++; } // 敵召還関連 private void UpdateStage() { // カウントが100の倍数だったら if (count % 100 == 0) { // 敵が残っていたら画面に追加 if (enemies.Count > 0) { characterNode.AddChildNode(enemies.Dequeue()); } } } } } BGMをループさせるには、 Sound クラスインスタンスの IsLoopingMode プロパティを true にします。 そして、音源の任意の区間をループさせる場合、 Sound クラスインスタンスの LoopStartingPoint プロパティで区間の始点 Sound クラスインスタンスの LoopEndPoint プロパティで区間の終点 を指定する必要があります。 再生している音の制御(一時停止、終了) MainNode.cs に以下のソースコードを変更します。 using Altseed2; using System.Collections.Generic; namespace Tutorial { // メインステージのクラス public class MainNode : Node { + // BGMのID + private int? bgmID = null; + // カウンタ private int count = 0; // 敵を格納するキュー private Queue<Enemy> enemies = new Queue<Enemy>(); // キャラクターを表示するノード private Node characterNode = new Node(); // プレイヤーの参照 private Player player; // エンジンに追加された時に実行 protected override void OnAdded() { // キャラクターノードを追加 AddChildNode(characterNode); // UIを表示するノード var uiNode = new Node(); // UIノードを追加 AddChildNode(uiNode); // 背景に使用するテクスチャ var backTexture = new SpriteNode(); // 背景のテクスチャを読み込む backTexture.Texture = Texture2D.LoadStrict(\"Resources/Background.png\"); // 表示位置を奥に設定 backTexture.ZOrder = -100; // 背景テクスチャを追加 AddChildNode(backTexture); // プレイヤーを設定 player = new Player(this, new Vector2F(100, 360)); // キャラクターノードにプレイヤーを追加 characterNode.AddChildNode(player); // ウェーブを初期化する InitWave(); // BGMを初期化する InitBGM(); } // エンジンから削除されたときに実行 protected override void OnRemoved() { // 衝突判定を全てリセット CollidableObject.objects.Clear(); } // BGMを初期化 private void InitBGM() { // BGMを読み込む var bgm = Sound.LoadStrict(\"Resources/BGM.wav\", false); // BGMをループするように設定 bgm.IsLoopingMode = true; // ループ開始位置を設定 bgm.LoopStartingPoint = 11.33f; // ループ終了位置を設定 bgm.LoopEndPoint = 33.93f; // BGMのプレイ開始 + bgmID = Engine.Sound.Play(bgm); - Engine.Sound.Play(bgm); } // ウェーブの初期化 private void InitWave() { // enemies.Enqueue～でウェーブに敵を追加 // 追加した順番に敵が出現する enemies.Enqueue(new ChaseEnemy(player, new Vector2F(700, 160), 2.0f)); enemies.Enqueue(new StraightShotEnemy(player, new Vector2F(600, 620))); enemies.Enqueue(new Meteor(player, new Vector2F(910, 400), new Vector2F(-4.0f, 0.0f))); enemies.Enqueue(new RadialShotEnemy(player, new Vector2F(400, 160), 3)); } // フレーム毎に実行 protected override void OnUpdate() { // ステージの更新 UpdateStage(); // カウントを進める count++; } // 敵召還関連 private void UpdateStage() { // カウントが100の倍数だったら if (count % 100 == 0) { // 敵が残っていたら画面に追加 if (enemies.Count > 0) { characterNode.AddChildNode(enemies.Dequeue()); } } } } } 再生している音は、 Engine.Sound.Play メソッドの戻り値である int 型のIDによって、制御できます。 今回は、BGMはずっと再生させておくため、制御はしませんが、 今後、BGMを制御する場合に備えて、 MainNode クラスの bgmID フィールドに格納しておきましょう。 以上を反映させて、ビルドを行うとBGMが再生されると思います。 まとめ 本章では、ゲームに音を加えることによって、よりゲームらしくなったかと思います。 みなさんのゲームでも、どんどん効果音をつけていってください。 次の章では、ゲーム性を高める上で重要な得点を表示させていきましょう。"
  },
  "Tutorials/Chap8/index.html": {
    "href": "Tutorials/Chap8/index.html",
    "title": "8章 : 得点を表示してみよう | Altseed2",
    "keywords": "8章 : 得点を表示してみよう 前章では音を鳴らすところまで進みました。 今回は5章で設定したスコア( score )を、画面に表示してみましょう！ まずは、スコアを表示させるための TextNode を作り、それを表示するところまでやってみます。 これが表示できたら、あとは表示するテキストをスコアに切り替えます。 テキストを表示 まずは、スコア変数とスコア表示用の TextNode を追加していきます。 以下のコードを追加してください。 using Altseed2; using System.Collections.Generic; namespace Tutorial { // メインステージのクラス public class MainNode : Node { // BGMのID private int? bgmID = null; // カウンタ private int count = 0; // 敵を格納するキュー private Queue<Enemy> enemies = new Queue<Enemy>(); // キャラクターを表示するノード private Node characterNode = new Node(); // プレイヤーの参照 private Player player; + // スコアを表示するノード + private TextNode scoreNode; + // スコア + public int score; ...略... 二つの TextNode 用の変数を書いたら、 次は敵を倒したときにスコア加算が行われるようにします。 以下のコードを追加してください。 using Altseed2; namespace Tutorial { // 敵の基礎となるクラス public class Enemy : CollidableObject { ...略... // 衝突時に実行 protected override void OnCollision(CollidableObject obj) { // 衝突対象が自機弾だったら if (obj is PlayerBullet) { + // スコアを加算 + mainNode.score += score; // 死亡時エフェクトを再生 Parent.AddChildNode(new DeathEffect(Position)); // 自身を削除 Parent.RemoveChildNode(this); // 死亡時サウンドを読み込み var deathSound = Sound.LoadStrict(\"Resources/Explosion.wav\", true); // 死亡時サウンドを再生 Engine.Sound.Play(deathSound); } } ...略... } } 次はこの TextNode の設定していきます。 using Altseed2; using System.Collections.Generic; namespace Tutorial { // メインステージのクラス public class MainNode : Node { ...略... // エンジンに追加された時に実行 protected override void OnAdded() { // キャラクターノードを追加 AddChildNode(characterNode); // UIを表示するノード var uiNode = new Node(); // UIノードを追加 AddChildNode(uiNode); // 背景に使用するテクスチャ var backTexture = new SpriteNode(); // 背景のテクスチャを読み込む backTexture.Texture = Texture2D.LoadStrict(\"Resources/Background.png\"); // 表示位置を奥に設定 backTexture.ZOrder = -100; // 背景テクスチャを追加 AddChildNode(backTexture); // プレイヤーを設定 player = new Player(this, new Vector2F(100, 360)); // キャラクターノードにプレイヤーを追加 characterNode.AddChildNode(player); + // スコアを表示するノードを設定 + scoreNode = new TextNode(); + // スコア表示に使うフォントを読み込む + scoreNode.Font = Font.LoadDynamicFontStrict(\"Resources/GenYoMinJP-Bold.ttf\"); + // スコア表示に使う文字のサイズを設定 + scoreNode.FontSize = 30; + // スコア表示の位置を設定 + scoreNode.Position = new Vector2F(); + // スコア表示の文字を設定 + scoreNode.Text = \"スコア\"; + + // UIノードにスコア表示ノードを追加 + uiNode.AddChildNode(scoreNode); // ウェーブを初期化する InitWave(); // BGMを初期化する InitBGM(); } ...略... } } 設定した内容は、 TextNode インスタンスの代入 フォントの読み込みと設定 表示位置を設定 uiNode に追加 の4点です。 この4つの設定をスコアのテキストにしています。 ここで一度実行してみます。 「スコア」が画面上部に表示されているのが確認できました。 ここまできたら次は、実際のスコアを表示してみましょう。 実際のスコアを表示 スコアは score に格納されていますね。 これらをテキストに設定していきます。 では、以下のコードを追加・削除してください。 using Altseed2; using System.Collections.Generic; namespace Tutorial { // メインステージのクラス public class MainNode : Node { ...略... // エンジンに追加された時に実行 protected override void OnAdded() { // キャラクターノードを追加 AddChildNode(characterNode); // UIを表示するノード var uiNode = new Node(); // UIノードを追加 AddChildNode(uiNode); // 背景に使用するテクスチャ var backTexture = new SpriteNode(); // 背景のテクスチャを読み込む backTexture.Texture = Texture2D.LoadStrict(\"Resources/Background.png\"); // 表示位置を奥に設定 backTexture.ZOrder = -100; // 背景テクスチャを追加 AddChildNode(backTexture); // プレイヤーを設定 player = new Player(this, new Vector2F(100, 360)); // キャラクターノードにプレイヤーを追加 characterNode.AddChildNode(player); // スコアを表示するノードを設定 scoreNode = new TextNode(); // スコア表示に使うフォントを読み込む scoreNode.Font = Font.LoadDynamicFontStrict(\"Resources/GenYoMinJP-Bold.ttf\"); // スコア表示に使う文字のサイズを設定 scoreNode.FontSize = 30; // スコア表示の位置を設定 scoreNode.Position = new Vector2F(); - // スコア表示の文字を設定 - scoreNode.Text = \"スコア\"; // UIノードにスコア表示ノードを追加 uiNode.AddChildNode(scoreNode); // ウェーブを初期化する InitWave(); // BGMを初期化する InitBGM(); } ...略... // フレーム毎に実行 protected override void OnUpdate() { + // スコア表示の更新 + scoreNode.Text = \"Score : \" + score; // ステージの更新 UpdateStage(); // カウントを進める count++; } ...略... } } まず、先ほど追加した仮テキストを代入する箇所を削除します。 次に、それぞれのテキスト表示を更新する箇所ですが、 scoreNode.Text = \"Score : \" + score; このようになっています。 これは、 \"Score : \" と score 変数を合体させて、 \"Score : 210\" という形式で表示しようとしています。 この処理を毎フレーム実行することで、現在のスコアを表示することができるようになる、ということです。 では実行してみます 左上の方に「Score」が表示できてますね。 さて、これで現在のスコアを表示できるようになりました。 次回は自機がダメージを受けたときの処理を書いていきます！ コード全体 最後に、今回修正を加えた、今回の MainNode 全体を載せておきます。困ったときは見比べたりコピペしてみてください。 using Altseed2; using System.Collections.Generic; namespace Tutorial { // メインステージのクラス public class MainNode : Node { // BGMのID private int? bgmID = null; // カウンタ private int count = 0; // 敵を格納するキュー private Queue<Enemy> enemies = new Queue<Enemy>(); // キャラクターを表示するノード private Node characterNode = new Node(); // プレイヤーの参照 private Player player; // スコアを表示するノード private TextNode scoreNode; // スコア public int score; // エンジンに追加された時に実行 protected override void OnAdded() { // キャラクターノードを追加 AddChildNode(characterNode); // UIを表示するノード var uiNode = new Node(); // UIノードを追加 AddChildNode(uiNode); // 背景に使用するテクスチャ var backTexture = new SpriteNode(); // 背景のテクスチャを読み込む backTexture.Texture = Texture2D.LoadStrict(\"Resources/Background.png\"); // 表示位置を奥に設定 backTexture.ZOrder = -100; // 背景テクスチャを追加 AddChildNode(backTexture); // プレイヤーを設定 player = new Player(this, new Vector2F(100, 360)); // キャラクターノードにプレイヤーを追加 characterNode.AddChildNode(player); // スコアを表示するノードを設定 scoreNode = new TextNode(); // スコア表示に使うフォントを読み込む scoreNode.Font = Font.LoadDynamicFontStrict(\"Resources/GenYoMinJP-Bold.ttf\"); // スコア表示に使う文字のサイズを設定 scoreNode.FontSize = 30; // スコア表示の位置を設定 scoreNode.Position = new Vector2F(); // UIノードにスコア表示ノードを追加 uiNode.AddChildNode(scoreNode); // ウェーブを初期化する InitWave(); // BGMを初期化する InitBGM(); } // エンジンから削除されたときに実行 protected override void OnRemoved() { // 衝突判定を全てリセット CollidableObject.objects.Clear(); } // BGMを初期化 private void InitBGM() { // BGMを読み込む var bgm = Sound.LoadStrict(\"Resources/BGM.wav\", false); // BGMをループするように設定 bgm.IsLoopingMode = true; // ループ開始位置を設定 bgm.LoopStartingPoint = 11.33f; // ループ終了位置を設定 bgm.LoopEndPoint = 33.93f; // BGMのプレイ開始 bgmID = Engine.Sound.Play(bgm); } // ウェーブの初期化 private void InitWave() { // enemies.Enqueue～でウェーブに敵を追加 // 追加した順番に敵が出現する enemies.Enqueue(new ChaseEnemy(player, new Vector2F(700, 160), 2.0f)); enemies.Enqueue(new StraightShotEnemy(player, new Vector2F(600, 620))); enemies.Enqueue(new Meteor(player, new Vector2F(910, 400), new Vector2F(-4.0f, 0.0f))); enemies.Enqueue(new RadialShotEnemy(player, new Vector2F(400, 160), 3)); } // フレーム毎に実行 protected override void OnUpdate() { // スコア表示の更新 scoreNode.Text = \"Score : \" + score; // ステージの更新 UpdateStage(); // カウントを進める count++; } // 敵召還関連 private void UpdateStage() { // カウントが100の倍数だったら if (count % 100 == 0) { // 敵が残っていたら画面に追加 if (enemies.Count > 0) { characterNode.AddChildNode(enemies.Dequeue()); } } } } }"
  },
  "Tutorials/Chap9/index.html": {
    "href": "Tutorials/Chap9/index.html",
    "title": "9章 : タイトル・ゲームオーバー画面を作ってみよう | Altseed2",
    "keywords": "9章 : タイトル・ゲームオーバー画面を作ってみよう ここまでの実装でシューティングとしてほぼほぼ完成形になりました。 あと一息，タイトル画面や死亡時のゲームオーバー画面を作ればもうゲームとして成立してしまいます。 タイトル画面の追加 タイトルノードの実装 まず以下のコードを追加してタイトル画面を作りましょう。 + using Altseed2; + + namespace Tutorial + { + // タイトル画面 + public class TitleNode : Node + { + // 画面が遷移中かどうか + private bool fading = false; + + // エンジンに追加された時に実行 + protected override void OnAdded() + { + // タイトル + var titleText = new TextNode(); + // タイトルのフォントを読み込む + titleText.Font = Font.LoadDynamicFontStrict(\"Resources/GenYoMinJP-Bold.ttf\"); + // タイトルの文字のサイズを設定 + titleText.FontSize = 100; + // タイトルの文字を設定 + titleText.Text = \"Tutorial STG\"; + // タイトルの座標を設定 + titleText.Position = new Vector2F(Engine.WindowSize.X / 2, 100f); + // タイトルの中心座標を設定 + titleText.CenterPosition = titleText.ContentSize / 2; + + // タイトルを追加 + AddChildNode(titleText); + + // 画面下に表示される案内 + var announce = new TextNode(); + // 案内のフォントを読み込む + announce.Font = Font.LoadDynamicFontStrict(\"Resources/GenYoMinJP-Bold.ttf\"); + // 案内の文字のサイズを設定 + announce.FontSize = 50; + // 案内の文字を設定 + announce.Text = \"Press Z to start\"; + // 案内の座標を設定 + announce.Position = new Vector2F(Engine.WindowSize.X / 2, 600f); + // 案内の中心座標を設定 + announce.CenterPosition = announce.ContentSize / 2; + + // 案内を追加 + AddChildNode(announce); + + // 背景のテクスチャ + var backTexture = new SpriteNode(); + // 背景のテクスチャを読み込む + backTexture.Texture = Texture2D.LoadStrict(\"Resources/image.png\"); + // 背景の表示位置を奥に設定 + backTexture.ZOrder = -1; + + // 背景を追加 + AddChildNode(backTexture); + } + + // フレーム毎に実行 + protected override void OnUpdate() + { + // 画面が遷移中でなく，Zキーが押された時に実行 + if (!fading && Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) + { + // エンジンから自身を削除 + Engine.RemoveNode(this); + + // エンジンにメイン画面を追加 + Engine.AddNode(new MainNode()); + + // 画面遷移中のフラグを立てる + fading = true; + } + } + } + } 基本的に実装は今迄行ってきたような， SpriteNode や TextNode を用いた画像/文字の描画です。 ここで注意する点が2つあります。 1つ目は // エンジンから自身を削除 Engine.RemoveNode(this); // エンジンにメイン画面を追加 Engine.AddNode(new MainNode()); の部分です。 第4章にて， Program.cs で Engine.AddNode(Node) は書きましたね。 ここでは， タイトル画面でZキーを押したときメインのシューティング画面に変更する処理 を行っています。 タイトル画面にいるときは，ノードの親子関係はこのようになっています。 此処における Root は， Engine 内で定義されている全てのノードの祖先となるノードです。 TitleNode の子ノードとして，タイトルのテキストや案内の文字，背景のテクスチャがあります。 この状態で Engine.RemoveNode(TitleNode) を行うとノードの親子関係はこのようになります。 Root と TitleNode の親子関係が解消され， TitleNode に登録されているテキストやテクスチャがウィンドウに描画されなくなります。 Root.RemoveNode(TitleNode) とやっていることに違いはありません。 次に Engine.AddNode(MainNode) を行う事でノードの親子関係は次のようになります。 Root の子に MainNode が追加され， MainNode での実装が実行されます。 前の章で実装してきたシューティングゲーム本体の内容ですね。 此処で大事なのは， Engine.Rootの子孫になったノードに描画や更新処理が適用される という事です。 描画や更新をしたくないノードは Remove して，描画や更新を実行したいノードを Add するようにしましょう。 2つ目は // 画面が遷移中かどうか private bool fading = false; の部分です。 この変数は，タイトル画面でZキーを押したときに true に変更されます。 // 画面が遷移中でなく，Zキーが押された時に実行 if (!fading && Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) { そして， true になるとこのif文の条件の様に，もう一度Zキーを押してもif文の内容が実行されなくなります。 これは，Zキー連打によって MainNode が Root に複数追加されるのを防ぎたいという事です。 タイトルノードへの遷移を追加 タイトルを実装したので，実際にゲームを始めた時に最初に表示されるようにしてみましょう。 Program.cs のコードを次のように書き換えてみましょう。 namespace Tutorial { class Program { [STAThread] static void Main(string[] args) { // エンジンを初期化 Engine.Initialize(\"Tutorial\", 960, 720); + // タイトル画面をエンジンに追加 + Engine.AddNode(new TitleNode()); - // メイン画面をエンジンに追加 - Engine.AddNode(new MainNode()); // メインループ while (Engine.DoEvents()) { …以下略… これで最初に表示されるノードが MainNode から TitleNode に変わりました。 ゲームオーバー画面の追加 次は死亡時にゲームオーバー画面を表示してみましょう。 TitleNode と同様に実装します。 + using Altseed2; + + namespace Tutorial + { + // ゲームオーバー画面 + public class GameOverNode : Node + { + // 画面が遷移中かどうか + private bool fading = false; + + // エンジンに追加された時に実行 + protected override void OnAdded() + { + // タイトル + var titleText = new TextNode(); + // タイトルのフォントを読み込む + titleText.Font = Font.LoadDynamicFontStrict(\"Resources/GenYoMinJP-Bold.ttf\"); + // タイトルの文字のサイズを設定 + titleText.FontSize = 100; + // タイトルの文字を設定 + titleText.Text = \"Game Over\"; + // タイトルの座標を設定 + titleText.Position = new Vector2F(Engine.WindowSize.X / 2, 100f); + // タイトルの中心座標を設定 + titleText.CenterPosition = titleText.ContentSize / 2; + // タイトルを追加 + AddChildNode(titleText); + + // 画面下に表示される案内 + var announce = new TextNode(); + // 案内のフォントを読み込む + announce.Font = Font.LoadDynamicFontStrict(\"Resources/GenYoMinJP-Bold.ttf\"); + // 案内の文字のサイズを設定 + announce.FontSize = 50; + // 案内の文字を設定 + announce.Text = \"Press Z to go title\"; + // 案内の座標を設定 + announce.Position = new Vector2F(Engine.WindowSize.X / 2, 600f); + // 案内の中心座標を設定 + announce.CenterPosition = announce.ContentSize / 2; + // 案内を追加 + AddChildNode(announce); + } + + // フレーム毎に実行 + protected override void OnUpdate() + { + // 画面が遷移中でなく，Zキーが押された時に実行 + if (!fading && Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) + { + // エンジンから自身を削除 + Engine.RemoveNode(this); + + // エンジンにタイトル画面を追加 + Engine.AddNode(new TitleNode()); + + // 画面遷移中のフラグを立てる + fading = true; + } + } + } + } 次に， MainNode に，ゲームオーバーへの遷移メソッドを実装します。 using Altseed2; using System.Collections.Generic; namespace Tutorial { // メインステージのクラス public class MainNode : Node { ...略... // スコアを表示するノード private TextNode scoreNode; + // 他画面へ遷移しているかどうか + private bool fading = false; // スコア public int score; ...略... + // ゲームオーバー画面に遷移 + public void ToGameOver() + { + // BGMをフェードアウト + if (bgmID.HasValue) + { + Engine.Sound.FadeOut(bgmID.Value, 1.0f); + + // BGMが止まったのでIDをnullに + bgmID = null; + } + + // 画面遷移中でないなら遷移処理を実行 + if (!fading) + { + // 自身をエンジンから削除 + Engine.RemoveNode(this); + + // エンジンにゲームオーバー画面を追加 + Engine.AddNode(new GameOverNode()); + + // 遷移中フラグを縦立てる + fading = true; + } + } // 敵召還関連 private void UpdateStage() ...略... } } これで， ToGameOver() メソッドを呼び出すことでゲームオーバー画面に遷移できるようになりました。 ゲームオーバーの呼び出しはプレイヤーが死亡したとき，つまりプレイヤーが敵/敵弾に衝突したときに呼び出せば良いですね。 それでは，以下のように Player.cs にて呼び出してみましょう。 using Altseed2; namespace Tutorial { // プレイヤーのクラス public class Player : CollidableObject { ...略... // 衝突時に実行 protected override void OnCollision(CollidableObject obj) { // 衝突対象が敵か敵の弾だったら if (obj is Enemy || obj is EnemyBullet) { // 死亡音を読み込む var deathSound = Sound.LoadStrict(\"Resources/Explosion.wav\", true); // 死亡音を再生 Engine.Sound.Play(deathSound); // 自身を親から削除 Parent.RemoveChildNode(this); + // ゲームオーバーに遷移 + mainNode.ToGameOver(); } } ...略... これでプレイヤーが敵/敵弾に衝突したときにゲームオーバー画面が呼び出されるようになりました。 // BGMをフェードアウト if (bgmID.HasValue) { Engine.Sound.FadeOut(bgmID.Value, 1.0f); // BGMが止まったのでIDをnullに bgmID = null; } この部分ではBGMのフェードアウトを行っています。 SoundMixer.FadeOut(int id, float seconds) は，指定した音を指定した秒数でフェードアウトするというものです。 BGMが再生中，つまり bgmID がnullじゃないとき(= bgmID.HasValue が true のとき)にフェードアウトを行い， bgmID を null にします。ここで bgmID を null にすることで bgmID.HasValue が false となるため，フェードアウト処理は一度だけしか行われません。 クリア画面の追加 クリア画面も追加してみましょう。 TitleNode や GameOverNode と同じ要領でクリア画面も作ってみましょう。 + using Altseed2; + + namespace Tutorial + { + // クリア画面 + public class LevelCompletedNode : Node + { + // 画面遷移中かどうか + private bool fading = false; + + // エンジンに追加された時に実行 + protected override void OnAdded() + { + // タイトル + var titleText = new TextNode(); + // タイトルのフォントを読み込む + titleText.Font = Font.LoadDynamicFontStrict(\"Resources/GenYoMinJP-Bold.ttf\"); + // タイトルの文字のサイズを設定 + titleText.FontSize = 100; + // タイトルの文字を設定 + titleText.Text = \"Clear!\"; + // タイトルの座標を設定 + titleText.Position = new Vector2F(Engine.WindowSize.X / 2, 100f); + // タイトルの中心座標を設定 + titleText.CenterPosition = titleText.ContentSize / 2; + // タイトルを追加 + AddChildNode(titleText); + + // 画面下の案内 + var announce = new TextNode(); + // 案内のフォントを読み込む + announce.Font = Font.LoadDynamicFontStrict(\"Resources/GenYoMinJP-Bold.ttf\"); + // タイトルの文字のサイズを設定 + announce.FontSize = 50; + // 案内のテキストを設定 + announce.Text = \"Press Z to go title\"; + // 案内の座標を設定 + announce.Position = new Vector2F(Engine.WindowSize.X / 2, 600f); + // 案内の中心座標を設定 + announce.CenterPosition = announce.ContentSize / 2; + //案内を追加 + AddChildNode(announce); + } + + // フレーム毎に実行 + protected override void OnUpdate() + { + // 画面遷移中でなく，かつZキーが押された時に実行 + if (!fading && Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push) + { + // エンジンから自身を削除 + Engine.RemoveNode(this); + + // エンジンにタイトル画面を追加 + Engine.AddNode(new TitleNode()); + + // 画面遷移中のフラグを立てる + fading = true; + } + } + } + } 同様に， MainNode.cs にもクリア画面への遷移を追加してみましょう。 using Altseed2; using System.Collections.Generic; namespace Tutorial { // メインステージのクラス public class MainNode : Node { ...略... // 敵召還関連 private void UpdateStage() { // カウントが100の倍数だったら if (count % 100 == 0) { // 敵が残っていたら画面に追加 if (enemies.Count > 0) { characterNode.AddChildNode(enemies.Dequeue()); } else { + // もし画面遷移中でなければ実行 + if (!fading) + { + // BGMをフェードアウト + if (bgmID.HasValue) + { + Engine.Sound.FadeOut(bgmID.Value, 1.0f); + + // BGMが止まったのでIDをnullに + bgmID = null; + } + + // エンジンから自身を削除 + Engine.RemoveNode(this); + + // クリア画面をエンジンに追加 + Engine.AddNode(new LevelCompletedNode()); + + // 画面遷移中フラグを立てる + fading = true; + } } } } } } これで，ウェーブをクリアしたときに自動的にBGMがフェードアウトされ，クリア画面に遷移します。"
  },
  "Tutorials/index.html": {
    "href": "Tutorials/index.html",
    "title": "Altseed2 チュートリアル | Altseed2",
    "keywords": "Altseed2 チュートリアル このチュートリアルでは、ゲームエンジン「Altseed2」を使ってシューティングゲームを開発していきます。 プログラミングをやったことがない人でも、このチュートリアルを通してある程度のクオリティのシューティングゲームを作れるようになります。 このチュートリアルでは、開発に使用するプログラミング言語として C#を用います。 C#の文法自体は本文中でも軽く説明しますが、ある程度 C#の知識を身につけておくと読みやすくなるでしょう。 C#のより詳しい解説は、 C#によるプログラミング入門 にわかりやすく纏まっています。 C#の文法や機能について不明な点があった場合は、是非一読してみてください。 また、C#の学習を円滑なものにするため、各章の冒頭に新たに導入される C#の機能とその解説へのリンクを記載しています。 C#の機能をもっと知りたい、本文を読んでもよく分からなかったという場合は、そちらをご参照ください。 なお、このチュートリアルは、Windowsユーザ及び Mac ユーザを想定しています。"
  }
}