<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>5&#31456; : &#25973;&#12539;&#25973;&#12398;&#12471;&#12519;&#12483;&#12488;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358; | Altseed2 </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="5&#31456; : &#25973;&#12539;&#25973;&#12398;&#12471;&#12519;&#12483;&#12488;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358; | Altseed2 ">
    <meta name="generator" content="docfx 2.56.2.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link rel="stylesheet" href="../../styles/reference.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" src="../../Logo.png" alt="" style="height:100%;margin-right:15px;">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href="../../Tutorials/index.html" title="&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;">&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;</a>
                      </li>
                      <li>
                          <a href="../../Manual/index.html" title="&#27231;&#33021;&#35299;&#35500;">&#27231;&#33021;&#35299;&#35500;</a>
                      </li>
                      <li>
                          <a href="../../References/Altseed2.html" title="&#12522;&#12501;&#12449;&#12524;&#12531;&#12473;">&#12522;&#12501;&#12449;&#12524;&#12531;&#12473;</a>
                      </li>
                      <li>
                          <a href="../../First/index.html" title="&#21021;&#20195;Altseed&#12399;&#12467;&#12481;&#12521;">&#21021;&#20195;Altseed&#12399;&#12467;&#12481;&#12521;</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <a href="../index.html" title="&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;" class="">&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;</a>
                    </li>
                    <li class="">
                      <a href="../Chap0/index.html" title="0&#31456; : Altseed&#12434;&#21021;&#12417;&#12424;&#12358;" class="">0&#31456; : Altseed&#12434;&#21021;&#12417;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap1/index.html" title="1&#31456; : &#12454;&#12451;&#12531;&#12489;&#12454;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">1&#31456; : &#12454;&#12451;&#12531;&#12489;&#12454;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap2/index.html" title="2&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12434;&#25551;&#30011;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">2&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12434;&#25551;&#30011;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap3/index.html" title="3&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12395;&#24382;&#12434;&#25731;&#12383;&#12379;&#12390;&#12415;&#12424;&#12358;" class="">3&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12395;&#24382;&#12434;&#25731;&#12383;&#12379;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap4/index.html" title="4&#31456; : &#12463;&#12521;&#12473;&#12434;&#33258;&#20998;&#12391;&#35373;&#35336;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">4&#31456; : &#12463;&#12521;&#12473;&#12434;&#33258;&#20998;&#12391;&#35373;&#35336;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="active">
                      <a href="../Chap5/index.html" title="5&#31456; : &#25973;&#12539;&#25973;&#12398;&#12471;&#12519;&#12483;&#12488;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;" class="active">5&#31456; : &#25973;&#12539;&#25973;&#12398;&#12471;&#12519;&#12483;&#12488;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap6/index.html" title="6&#31456; : &#24403;&#12383;&#12426;&#21028;&#23450;&#12398;&#27231;&#33021;&#12434;&#20351;&#12387;&#12390;&#12415;&#12424;&#12358;" class="">6&#31456; : &#24403;&#12383;&#12426;&#21028;&#23450;&#12398;&#27231;&#33021;&#12434;&#20351;&#12387;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap7/index.html" title="7&#31456; : &#38899;&#12434;&#40180;&#12425;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">7&#31456; : &#38899;&#12434;&#40180;&#12425;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap8/index.html" title="8&#31456; : &#24471;&#28857;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">8&#31456; : &#24471;&#28857;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap9/index.html" title="9&#31456; : &#12479;&#12452;&#12488;&#12523;&#12539;&#12466;&#12540;&#12512;&#12458;&#12540;&#12496;&#12540;&#30011;&#38754;&#12434;&#20316;&#12387;&#12390;&#12415;&#12424;&#12358;" class="">9&#31456; : &#12479;&#12452;&#12488;&#12523;&#12539;&#12466;&#12540;&#12512;&#12458;&#12540;&#12496;&#12540;&#30011;&#38754;&#12434;&#20316;&#12387;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap10/index.html" title="10&#31456; : &#12356;&#12374;&#12289;&#20844;&#38283;&#28310;&#20633;" class="">10&#31456; : &#12356;&#12374;&#12289;&#20844;&#38283;&#28310;&#20633;</a>
                    </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="5章--敵敵のショットを表示してみよう">5章 : 敵・敵のショットを表示してみよう</h1>

<p>今まではプレイヤーの挙動のみでした。
次は敵の実装を行います。</p>
<p>本章では継承を使用します。
確かに、今までも既存のクラスを継承することはありました。
この継承元のクラスは自分でも作成できます。</p>
<p>敵は様々な挙動をしますが、それぞれ個別に実装するのも管理するのも大変です。
それらを共通化するために継承があります。</p>
<h2 id="敵クラスの実装">敵クラスの実装</h2>
<p>まずは敵を実装します。
基本的にはプレイヤーと変わりません。
プレイヤーとの違いとして、プレイヤーを攻撃するためにプレイヤーへの参照を持っていること、画面外にでたら自動的に消えることが違います。
画面外にでても常に敵が残り続けると、敵が多すぎて重くなってしまいます。
そのため、画面外に出たら消えるようになっています。</p>
<p>Enemy.csを追加し、下記のコードを記述します。</p>
<ul>
<li>Enemy.cs</li>
</ul>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // 敵の基礎となるクラス
    public class Enemy : SpriteNode
    {
        // 倒された時に加算されるスコアの値
        protected int score;
        
        // プレイヤーへの参照
        protected Player player;
        
        // コンストラクタ
        public Enemy(Player player, Vector2F position)
        {
            // 座標を設定
            Position = position;

            // プレイヤーへの参照を設定
            this.player = player;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 画面外に出たら自身を削除
            RemoveMyselfIfOutOfWindow();
        }

        // 画面外に出た時自身を消去
        protected void RemoveMyselfIfOutOfWindow()
        {
            var halfSize = Texture.Size / 2;
            if (Position.X &lt; -halfSize.X
                || Position.X &gt; Engine.WindowSize.X + halfSize.X
                || Position.Y &lt; -halfSize.Y
                || Position.Y &gt; Engine.WindowSize.Y + halfSize.Y)
            {
                // 自身を削除
                Parent?.RemoveChildNode(this);
            }
        }
    }
}
</code></pre>
<p>前章では、<code>protected</code>や<code>public</code>の説明をしていませんでした。
これらはアクセス指定子といいます。
そのメンバー変数やメソッドにクラスの外部から使用できるかを指定します。</p>
<p><code>public</code>は外部から使用できる、<code>protected</code>は継承先を含めたクラス内、<code>private</code>、もしくは記述なしはクラス内のみ使用可能です。</p>
<p>今回の場合、Enemyクラスは継承して使用するので、多くのメンバー変数が<code>protected</code>になっています。</p>
<p>また、<code>Parent?.RemoveChildNode(this);</code> という記述があります。
これは、</p>
<pre><code class="lang-cs">if(Parent != null)
    Parent.RemoveChildNode(this);
</code></pre>
<p>と同じ意味です。nullでなかったら、何らかの処理を記述する、ということが多々あるため、簡単に記述できるようになっています。</p>
<p>ただ、見ての通り、この敵は動きもしないし攻撃もしません。
それでは、このクラスを継承して敵を実装しましょう。</p>
<h2 id="隕石">隕石</h2>
<p>先ほどのEnemyクラスを継承して隕石クラスを記述します。
Meteor.csを追加し、下記のコードを記述します。</p>
<ul>
<li>Meteor.cs</li>
</ul>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // 隕石
    public class Meteor : Enemy
    {
        // フレーム毎の移動速度
        private Vector2F velocity;

        // コンストラクタ
        public Meteor(Player player, Vector2F position, Vector2F velocity) : base(player, position)
        {
            // 速度の設定
            this.velocity = velocity;

            // テクスチャの設定
            Texture = Texture2D.LoadStrict(&quot;Resources/Meteor.png&quot;);

            // 中心座標の設定
            CenterPosition = ContentSize / 2;

            // スコアの設定
            score = 1;
        }

        // 毎フレーム実行
        protected override void OnUpdate()
        {
            // 座標を速度分加算
            Position += velocity;

            // EnemyクラスのOnUpdate呼び出し
            base.OnUpdate();
        }
    }
}
</code></pre>
<p>隕石は移動するだけの敵です。
更新するごとに速度の分、位置を動かしていきます。</p>
<!--
更新内で ```base.OnUpdate();``` を呼んでいます。
これは、継承元のOnUpdateを呼ぶという意味です。
継承元で、画面外に出たら消すという処理を行っているため、継承元のOnUpdateを呼ぶ必要があります。
-->
<h2 id="敵の出現">敵の出現</h2>
<p>敵のクラスを用意しただけでは、敵は出現してくれません。
そこでMainNodeを編集して、敵が出現するようにします。</p>
<ul>
<li>MainNode.cs</li>
</ul>
<pre><code class="lang-diff" name="Main">using Altseed2;
+using System.Collections.Generic;

namespace Tutorial
{
    // メインステージのクラス
    public class MainNode : Node
    {
        // キャラクターを表示するノード
        private Node characterNode = new Node();
        
        // プレイヤーの参照
        private Player player;

        // エンジンに追加された時に実行
        protected override void OnAdded()
        {
            // キャラクターノードを追加
            AddChildNode(characterNode);

            // UIを表示するノード
            var uiNode = new Node();

            // UIノードを追加
            AddChildNode(uiNode);

            // 背景に使用するテクスチャ
            var backTexture = new SpriteNode();
            // 背景のテクスチャを読み込む
            backTexture.Texture = Texture2D.LoadStrict(&quot;Resources/Background.png&quot;);
            // 表示位置を奥に設定
            backTexture.ZOrder = -100;

            // 背景テクスチャを追加
            AddChildNode(backTexture);

            // プレイヤーを設定
            player = new Player(new Vector2F(100, 360));

            // キャラクターノードにプレイヤーを追加
            characterNode.AddChildNode(player);

+           // 敵を追加する。
+           characterNode.AddChildNode(new Meteor(player, new Vector2F(910, 400), new Vector2F(-4.0f, 0.0f)));
        }
    }
}
</code></pre>
<p><img src="Image/Meteor.png" alt="Meteor"></p>
<h2 id="弾を打つ敵">弾を打つ敵</h2>
<p>弾を打つ敵を用意しますが、その前に弾を共通化します。
味方の弾と敵の弾を全く異なるクラスにしてもいいですが、ほとんどの機能は共通なので同じようなコードが2箇所に書かれてしまいます。
そのため、弾クラスを用意して、それを継承するようにします。</p>
<p>前章で作成した弾クラスのコンストラクタを一部修正します。
弾の画像に関する部分を消しています。</p>
<ul>
<li>Bullet.cs</li>
</ul>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // 弾のクラス
    public class Bullet : SpriteNode
    {
        // フレーム毎に進む距離
        private Vector2F velocity;

        // コンストラクタ
        public Bullet(Vector2F position, Vector2F velocity)
        {
            // 座標を設定
            Position = position;

-            // テクスチャを読み込む
-            Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);
-
-            // 中心座標を設定
-            CenterPosition = ContentSize / 2;

            // 弾速を設定
            this.velocity = velocity;

            // 表示位置をプレイヤーや敵より奥に設定
            ZOrder--;
        }

        // ================================================================
        // 省略
        // ================================================================
    }
}
</code></pre>
<p>それに合わせて、プレイヤーのコードも変更します。
プレイヤーの弾クラスは弾クラスを継承するようにします。
それに合わせて、プレイヤーはプレイヤーの弾クラスを発射するようにします。</p>
<p>新たにBulletクラスを継承してPlayerBulletクラスを追加します。</p>
<ul>
<li>PlayerBullet.cs</li>
</ul>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // 自機弾
    public class PlayerBullet : Bullet
    {
        // コンストラクタ
        public PlayerBullet(Vector2F position) : base(position, new Vector2F(10f, 0.0f))
        {
            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;
        }
    }
}
</code></pre>
<ul>
<li>Player.cs</li>
</ul>
<p>PlayerBulletを撃つように変更します。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // プレイヤーのクラス
    public class Player : SpriteNode
    {
        // ================================================================
        // 省略
        // ================================================================
    
        // ショット
        private void Shot()
        {
            // Zキーでショットを放つ
            if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
            {
+               Parent.AddChildNode(new PlayerBullet(Position));
-               Parent.AddChildNode(new Bullet(Position, new Vector2F(10f, 0f)));
            }
        }
    }
}
</code></pre>
<p>次に敵の弾と弾を打つ敵クラスを実装します。
基本的には味方が弾を打つ処理と、敵の移動を組み合わせたものになります。
それぞれ、敵の弾クラスは弾クラスを継承し、弾を打つ敵クラスは敵クラスを継承します。</p>
<ul>
<li>StraightShotEnemy.cs</li>
</ul>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;

namespace Tutorial
{
    // まっすぐな弾を発射する敵
    public class StraightShotEnemy : Enemy
    {
        // カウンタ
        private int count = 0;

        // コンストラクタ
        public StraightShotEnemy(Player player, Vector2F position) : base(player, position)
        {
            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/UFO.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;

            // 倒された時に加算されるスコアを設定
            score = 20;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // カウントが150の倍数で実行
            if (count % 150 == 0)
            {
                // プレイヤーに対するベクトルの単位ベクトルを取得
                var velocity = (player.Position - Position).Normal;
                // ベクトルの長さを調整(弾速になる)
                velocity *= 5;

                // 弾を追加
                Shot(velocity);
            }

            // 座標を設定
            Position -= new Vector2F(MathF.Sin(MathHelper.DegreeToRadian(count)) * 3.0f, 0);

            // EnemyのOnUpdateを実行
            base.OnUpdate();

            // カウントを進める
            count++;
        }

        // 弾を撃つ
        private void Shot(Vector2F velocity)
        {
            // 敵弾を画面に追加
            Parent.AddChildNode(new EnemyBullet(Position, velocity));
        }
    }
}
</code></pre>
<ul>
<li>EnemyBullet.cs</li>
</ul>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // 敵の弾のクラス
    public class EnemyBullet : Bullet
    {
        // コンストラクタ
        public EnemyBullet(Vector2F position, Vector2F velocity) : base(position, velocity)
        {
            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Red.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;
        }
    }
}
</code></pre>
<p>この敵も出現するようにしましょう。
MainNodeに敵を追加します。</p>
<ul>
<li>MainNode.cs</li>
</ul>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System.Collections.Generic;

namespace Tutorial
{
    // メインステージのクラス
    public class MainNode : Node
    {
        // キャラクターを表示するノード
        private Node characterNode = new Node();
        
        // プレイヤーの参照
        private Player player;

        // エンジンに追加された時に実行
        protected override void OnAdded()
        {
            // ================================================================
            // 省略
            // ================================================================
            // 敵を追加する。

+           characterNode.AddChildNode(new StraightShotEnemy(player, new Vector2F(600, 620)));

            characterNode.AddChildNode(new Meteor(player, new Vector2F(910, 400), new Vector2F(-4.0f, 0.0f)));
        }
    }
}
</code></pre>
<p><img src="Image/StraightShotEnemy.png" alt="StraightShotEnemy"></p>
<h2 id="他の敵">他の敵</h2>
<p>他の敵もそれぞれ実装します。</p>
<p>複数方向に打てる敵です。
経過時間を計測し、経過時間ごとに異なる方向に弾を打ちます。</p>
<ul>
<li>RadialShotEnemy.cs</li>
</ul>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // 放射ショットの敵
    public class RadialShotEnemy : Enemy
    {
        // カウンタ変数
        private int count = 0;

        // 撃ち出すショットの個数
        private int shotAmount;

        // フレーム毎の速度
        private Vector2F velocity;

        // コンストラクタ
        public RadialShotEnemy(Player player, Vector2F position, int shotAmount) : base(player, position)
        {
            // 撃ち出すショットの個数を設定
            this.shotAmount = shotAmount;

            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/UFO.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;

            // スコアを設定
            score = 30;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // カウントが250の倍数だったら
            if (count % 250 == 0)
            {
                // 計算用のローカル変数
                var half = shotAmount / 2;

                for (int i = 0; i &lt; shotAmount; i++)
                {
                    // 現時点の座標からプレイヤーに向かうベクトルの単位ベクトルを取得する
                    var vector = (player.Position - Position).Normal;

                    // ベクトルを速度分掛ける
                    vector *= 7.0f;

                    // ベクトルを傾ける
                    vector.Degree += 30 * (i - half);

                    // ショットを放つ
                    Shot(vector);
                }
            }

            // カウント÷100の余りが0～49だったら
            if (count % 100 &lt; 50)
            {
                // カウント÷100の余りが0だったら
                if (count % 100 == 0)
                {
                    // 進むベクトルを設定
                    velocity = (player.Position - Position).Normal * 3.0f;
                }

                // 速度分ベクトルを設定
                Position += velocity;
            }

            // EnemyクラスのOnUpdateを呼び出す
            base.OnUpdate();

            // カウントを進める
            count++;
        }

        // 弾を撃つ
        private void Shot(Vector2F velocity)
        {
            // 敵弾を画面に追加
            Parent.AddChildNode(new EnemyBullet(Position, velocity));
        }
    }
}
</code></pre>
<p>プレイヤーを追いかける敵です。
プレイヤーへの参照を使用し、プレイヤーのほうに近づきます。</p>
<ul>
<li>ChaseEnemy.cs</li>
</ul>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // 追跡型敵
    public class ChaseEnemy : Enemy
    {
        // 移動速度
        private float speed;

        // コンストラクタ
        public ChaseEnemy(Player player, Vector2F position, float speed) : base(player, position)
        {
            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/UFO.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;

            // 移動速度を設定
            this.speed = speed;

            // 自身が倒された時に加算されるスコアを設定
            score = 10;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // プレイヤーへのベクトルの単位ベクトルを取得
            var vector = (player.Position - Position).Normal;

            // ベクトルの長さを調整
            vector *= speed;

            // ベクトル分座標を動かす
            Position += vector;

            // EnemyのOnUpdateを実行
            base.OnUpdate();
        }
    }
}
</code></pre>
<p>それぞれの敵を追加します。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System.Collections.Generic;

namespace Tutorial
{
    // メインステージのクラス
    public class MainNode : Node
    {
        // キャラクターを表示するノード
        private Node characterNode = new Node();
        
        // プレイヤーの参照
        private Player player;

        // エンジンに追加された時に実行
        protected override void OnAdded()
        {
            // ================================================================
            // 省略
            // ================================================================

            // 敵を追加する。
+            characterNode.AddChildNode(new ChaseEnemy(player, new Vector2F(700, 160), 2.0f));

            characterNode.AddChildNode(new StraightShotEnemy(player, new Vector2F(600, 620)));

            characterNode.AddChildNode(new Meteor(player, new Vector2F(910, 400), new Vector2F(-4.0f, 0.0f)));

+            characterNode.AddChildNode(new RadialShotEnemy(player, new Vector2F(400, 160), 3));
        }
    }
}
</code></pre>
<p><img src="Image/Enemies.png" alt="Enemies"></p>
<h2 id="続敵の出現">続・敵の出現</h2>
<p>いままでのだと、敵が一気に出現するし、そのあとにも敵は出現しないので面白くありません。
そこで複数の敵が順番に出るようにします。</p>
<p>ここでは<code>Queue</code> というクラスを使用しています。
これはListと同じようなものですが、挙動が異なります。</p>
<p>Listは、常に内部のコレクションの最後に値を追加するのみで、追加した後は任意の値にアクセスできました。</p>
<p>一方、Queueは、内部のコレクションの最後に値を追加し、取得するときは一番最初に追加した値を取得して、その値をコレクションから取り除きます。</p>
<p>追加には、<code>Enqueue</code>、取り出しには、<code>Dequeue</code>を使用します。</p>
<p>例えば、下記のような挙動になります。</p>
<pre><code class="lang-cs">
Queue&lt;int&gt; queue = new Queue&lt;int&gt;();

queue.Enqueue(1);
queue.Enqueue(2);

// この時点ではqueueの中身には1,2がある

int value = queue.Dequeue();

// 1が表示される。
// この時点ではqueueの中身には2がある
Console.WriteLine(value); 

</code></pre>
<p>これを使用して敵を管理します。</p>
<p>親ノードには敵を追加せず、Queueに敵ノードを追加します。
そして、一定時間ごとにQueueから敵ノードを取り出し、追加することで敵が徐々に出現するようにします。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
+ using System.Collections.Generic;

namespace Tutorial
{
    // メインステージのクラス
    public class MainNode : Node
    {
+       // カウンタ
+       private int count = 0;

+       // 敵を格納するキュー
+       private Queue&lt;Enemy&gt; enemies = new Queue&lt;Enemy&gt;();

        // キャラクターを表示するノード
        private Node characterNode = new Node();
        
        // プレイヤーの参照
        private Player player;

        // エンジンに追加された時に実行
        protected override void OnAdded()
        {
            // キャラクターノードを追加
            AddChildNode(characterNode);

            // UIを表示するノード
            var uiNode = new Node();

            // UIノードを追加
            AddChildNode(uiNode);

            // 背景に使用するテクスチャ
            var backTexture = new SpriteNode();
            // 背景のテクスチャを読み込む
            backTexture.Texture = Texture2D.LoadStrict(&quot;Resources/Background.png&quot;);
            // 表示位置を奥に設定
            backTexture.ZOrder = -100;

            // 背景テクスチャを追加
            AddChildNode(backTexture);

            // プレイヤーを設定
            player = new Player(new Vector2F(100, 360));

            // キャラクターノードにプレイヤーを追加
            characterNode.AddChildNode(player);

-           characterNode.AddChildNode(new StraightShotEnemy(player, new Vector2F(600, 620)));
-
-           characterNode.AddChildNode(new RadialShotEnemy(player, new Vector2F(400, 160), 3));
-
-           characterNode.AddChildNode(new StraightShotEnemy(player, new Vector2F(600, 620));
-
-           characterNode.AddChildNode(new ChaseEnemy(player, new Vector2F(700, 160), 2.0f));

+           // ウェーブを初期化する
+           InitWave();
        }

+       // ウェーブの初期化
+       private void InitWave()
+       {
+           // enemies.Enqueue～でウェーブに敵を追加
+           // 追加した順番に敵が出現する
+
+
+           enemies.Enqueue(new ChaseEnemy(player, new Vector2F(700, 160), 2.0f));
+
+           enemies.Enqueue(new StraightShotEnemy(player, new Vector2F(600, 620)));
+
+           enemies.Enqueue(new Meteor(player, new Vector2F(910, 400), new Vector2F(-4.0f, 0.0f)));
+
+           enemies.Enqueue(new RadialShotEnemy(player, new Vector2F(400, 160), 3));
+       }
+
+       // フレーム毎に実行
+       protected override void OnUpdate()
+       {
+           // ステージの更新
+           UpdateStage();
+
+           // カウントを進める
+           count++;
+       }
+
+       // 敵召還関連
+       private void UpdateStage()
+       {
+           // カウントが100の倍数だったら
+           if (count % 100 == 0)
+           {
+               // 敵が残っていたら画面に追加
+               if (enemies.Count &gt; 0)
+               {
+                   characterNode.AddChildNode(enemies.Dequeue());
+               }
+           }
+       }
    }
}
</code></pre>
<p><img src="Image/Finish.png" alt="Finish"></p>
<h2 id="まとめ">まとめ</h2>
<p>ここでは敵の処理を実装しました。
ただ、この章で弾は打てるようになりましたが、一切攻撃は命中しません。
次章では、弾が命中するようにします。</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright &copy; 2020 Altseed .
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
