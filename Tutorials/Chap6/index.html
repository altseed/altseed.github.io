<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>6&#31456; : &#24403;&#12383;&#12426;&#21028;&#23450;&#12398;&#27231;&#33021;&#12434;&#20351;&#12387;&#12390;&#12415;&#12424;&#12358; | Altseed2 </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="6&#31456; : &#24403;&#12383;&#12426;&#21028;&#23450;&#12398;&#27231;&#33021;&#12434;&#20351;&#12387;&#12390;&#12415;&#12424;&#12358; | Altseed2 ">
    <meta name="generator" content="docfx 2.56.2.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link rel="stylesheet" href="../../styles/reference.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" src="../../Logo.png" alt="" style="height:100%;margin-right:15px;">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href="../../Tutorials/index.html" title="&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;">&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;</a>
                      </li>
                      <li>
                          <a href="../../Manual/index.html" title="&#27231;&#33021;&#35299;&#35500;">&#27231;&#33021;&#35299;&#35500;</a>
                      </li>
                      <li>
                          <a href="../../References/Altseed2.html" title="&#12522;&#12501;&#12449;&#12524;&#12531;&#12473;">&#12522;&#12501;&#12449;&#12524;&#12531;&#12473;</a>
                      </li>
                      <li>
                          <a href="../../First/index.html" title="&#21021;&#20195;Altseed&#12399;&#12467;&#12481;&#12521;">&#21021;&#20195;Altseed&#12399;&#12467;&#12481;&#12521;</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <a href="../index.html" title="&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;" class="">&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;</a>
                    </li>
                    <li class="">
                      <a href="../Chap0/index.html" title="0&#31456; : Altseed&#12434;&#21021;&#12417;&#12424;&#12358;" class="">0&#31456; : Altseed&#12434;&#21021;&#12417;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap1/index.html" title="1&#31456; : &#12454;&#12451;&#12531;&#12489;&#12454;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">1&#31456; : &#12454;&#12451;&#12531;&#12489;&#12454;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap2/index.html" title="2&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12434;&#25551;&#30011;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">2&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12434;&#25551;&#30011;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap3/index.html" title="3&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12395;&#24382;&#12434;&#25731;&#12383;&#12379;&#12390;&#12415;&#12424;&#12358;" class="">3&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12395;&#24382;&#12434;&#25731;&#12383;&#12379;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap4/index.html" title="4&#31456; : &#12463;&#12521;&#12473;&#12434;&#33258;&#20998;&#12391;&#35373;&#35336;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">4&#31456; : &#12463;&#12521;&#12473;&#12434;&#33258;&#20998;&#12391;&#35373;&#35336;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap5/index.html" title="5&#31456; : &#25973;&#12539;&#25973;&#12398;&#12471;&#12519;&#12483;&#12488;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">5&#31456; : &#25973;&#12539;&#25973;&#12398;&#12471;&#12519;&#12483;&#12488;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="active">
                      <a href="../Chap6/index.html" title="6&#31456; : &#24403;&#12383;&#12426;&#21028;&#23450;&#12398;&#27231;&#33021;&#12434;&#20351;&#12387;&#12390;&#12415;&#12424;&#12358;" class="active">6&#31456; : &#24403;&#12383;&#12426;&#21028;&#23450;&#12398;&#27231;&#33021;&#12434;&#20351;&#12387;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap7/index.html" title="7&#31456; : &#38899;&#12434;&#40180;&#12425;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">7&#31456; : &#38899;&#12434;&#40180;&#12425;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap8/index.html" title="8&#31456; : &#24471;&#28857;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">8&#31456; : &#24471;&#28857;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap9/index.html" title="9&#31456; : &#12479;&#12452;&#12488;&#12523;&#12539;&#12466;&#12540;&#12512;&#12458;&#12540;&#12496;&#12540;&#30011;&#38754;&#12434;&#20316;&#12387;&#12390;&#12415;&#12424;&#12358;" class="">9&#31456; : &#12479;&#12452;&#12488;&#12523;&#12539;&#12466;&#12540;&#12512;&#12458;&#12540;&#12496;&#12540;&#30011;&#38754;&#12434;&#20316;&#12387;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap10/index.html" title="10&#31456; : &#12356;&#12374;&#12289;&#20844;&#38283;&#28310;&#20633;" class="">10&#31456; : &#12356;&#12374;&#12289;&#20844;&#38283;&#28310;&#20633;</a>
                    </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="6章--当たり判定の機能を使ってみよう">6章 : 当たり判定の機能を使ってみよう</h1>

<p>5章では敵機と敵弾の作成までを行いました。しかしこのままでは当たり判定がないただのオブジェクトになってしまいます。<br>
本章では敵機と敵弾に当たり判定をつけていきます。</p>
<h2 id="当たり判定仕組み">当たり判定仕組み</h2>
<p>「当たり判定」とは読んで字の如く、オブジェクト同士が当たっているかどうか判定するものです。当たり判定の実装方法には色々な手法が考えられますが、今回は簡単のために「円同士の当たり判定をピクセル単位で取る」という方法を扱います。</p>
<p>例えば下のような２つの円のオブジェクトを考え、２つの円の中心座標を考えてみましょう。２つの円の半径をa, bとおき、２つの円のx座標の差をd、y座標の差をeとおくと、中学校で習うような「三平方の定理」よりd²+e²&lt;(a+b)²ならば２つの円は「ぶつかっている」ということになりますね。</p>
<p><img src="Image/06_collision.png" alt="当たり判定"></p>
<h2 id="当たり判定実装">当たり判定実装</h2>
<p>当たり判定の仕組みは上で説明したとおりですが、自分で一から実装するのは面倒なのでAltseed2ではこの当たり判定をまとめたクラスである<code>CircleCollider</code>が用意されています。</p>
<p>早速この<code>CircleCollider</code>を使って当たり判定を実装していきましょう。</p>
<p>今回は自機、自弾、敵機、敵弾の4つに当たり判定をつけるので基底クラスとして<code>CollidableObject</code>クラスを用意してそれを継承していくような実装にします。<br>
継承については以下を参照してください。</p>
<p><a href="https://ufcpp.net/study/csharp/oo_inherit.html">C# によるプログラミング入門 : 継承</a></p>
<p><code>CollidableObject</code>のコードは以下のようになります。</p>
<pre><code class="lang-cs" name="Main">using System.Collections.Generic;
using Altseed2;

namespace Tutorial
{
    // 衝突可能なオブジェクト(円形)
    public class CollidableObject : SpriteNode
    {
        // コライダのコレクション
        public static HashSet&lt;CollidableObject&gt; objects = new HashSet&lt;CollidableObject&gt;();

        // コライダ
        protected CircleCollider collider = CircleCollider.Create();

        // OnUpdate内で衝突判定を調査するかどうか
        protected bool doSurvey;

        // 所属するメインノードへの参照
        public MainNode mainNode;

        // コンストラクタ
        public CollidableObject(MainNode mainNode, Vector2F position)
        {
            // メインノードへの参照を設定
            this.mainNode = mainNode;

            // コライダの座標を設定
            collider.Position = position;

            // 座標を設定
            Position = position;
        }

        // エンジンに追加された時に実行
        protected override void OnAdded()
        {
            // コライダのコレクションに自身を追加
            objects.Add(this);
        }

        // エンジンから削除された時に実行
        protected override void OnRemoved()
        {
            // コライダのコレクションから自身を削除
            objects.Remove(this);
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // フラグが成立時に衝突判定を実行
            if (doSurvey)
            {
                Survey();
            }

            // コライダの座標を更新
            collider.Position = Position;
        }

        // 衝突時に実行
        private void CollideWith(CollidableObject obj)
        {
            // nullだったら終了
            if (obj == null)
            {
                return;
            }

            // 衝突対象がSurveyを実行しないオブジェクトだった場合，相手のOnCollisionも実行
            if (!obj.doSurvey)
            {
                obj.OnCollision(this);
            }

            // 自身のOnCollisiionを実行
            OnCollision(obj);
        }

        // 衝突時に実行される内容をオーバーライドして設定できる
        protected virtual void OnCollision(CollidableObject obj)
        {

        }

        // 画面外に出た時自身を消去
        protected void RemoveMyselfIfOutOfWindow()
        {
            var halfSize = Texture.Size / 2;
            if (Position.X &lt; -halfSize.X
                || Position.X &gt; Engine.WindowSize.X + halfSize.X
                || Position.Y &lt; -halfSize.Y
                || Position.Y &gt; Engine.WindowSize.Y + halfSize.Y)
            {
                // 自身を削除
                Parent?.RemoveChildNode(this);
            }
        }

        // 衝突判定を調査する
        private void Survey()
        {
            // objects内の全オブジェクトを検索し，衝突が確認されたオブジェクト間でCollideWithを実行
            foreach (var obj in objects)
                if (collider.GetIsCollidedWith(obj.collider))
                    CollideWith(obj);
        }
    }
}
</code></pre>
<p>これまで<code>SpriteNode</code>を継承していたため、<code>CollidableObject</code>でも<code>SpriteNode</code>を継承しています。<br>
また、<code>Enemy</code>クラスと<code>Bullet</code>クラスに定義していた<code>RemoveMyselfIfOutOfWindow</code>関数ですが同じ処理が二か所にあって冗長です。基本的に同じ処理は一か所にまとめた方が良いのでそれぞれの親クラスになる<code>CollidableObject</code>でこの関数を定義することにします。</p>
<p>変数とコンストラクタを解説していきます。</p>
<pre><code class="lang-cs" name="Main">// コライダのコレクション
public static HashSet&lt;CollidableObject&gt; objects = new HashSet&lt;CollidableObject&gt;();

// コライダ
protected CircleCollider collider = new CircleCollider();

// OnUpdate内で衝突判定を調査するかどうか
protected bool doSurvey;

// 所属するメインノードへの参照
public MainNode mainNode;

// コンストラクタ
public CollidableObject(MainNode mainNode, Vector2F position)
{
    // メインノードへの参照を設定
    this.mainNode = mainNode;

    // コライダの座標を設定
    collider.Position = position;

    // 座標を設定
    Position = position;
}
</code></pre>
<p>それぞれのコライダとの当たり判定をとるためにコライダのコレクションを保存しておく必要があります。コライダオブジェクトは変数<code>objects</code>に保存します。<br>
この変数<code>objects</code>の宣言には<code>static</code>というキーワードが使われています。これは静的メンバーと呼ばれるもので、すべてのインスタンスから共有されるような変数を宣言できます。詳しい説明は以下のリンク先を参照してください。</p>
<p><a href="https://ufcpp.net/study/csharp/oo_static.html">C# によるプログラミング入門 : 静的メンバー</a></p>
<p>変数<code>collider</code>はコライダの本体で、先ほど言ったようにAltseed2で用意された<code>CircleCollider</code>を使用します。
<code>doSurvey</code>と<code>mainNode</code>はコメントにある通りです。<br>
コンストラクタの<code>collider.Position = position</code>はコライダの位置設定で<code>Position = position</code>は本体の描画されているオブジェクトの位置設定であることに注意してください。</p>
<p>次に<code>OnUpdate</code>です。</p>
<pre><code class="lang-C#">// フレーム毎に実行
protected override void OnUpdate()
{
    // フラグが成立時に衝突判定を実行
    if (doSurvey)
    {
        Survey();
    }

    // コライダの座標を更新
    collider.Position = Position;
}
</code></pre>
<p>先ほど定義した<code>doSurvey</code>のフラグが<code>true</code>の場合後述する<code>Survey</code>関数が呼ばれて当たり判定が開始します。<br>
オブジェクトが動いてもコライダの位置は変わらないのでコライダとオブジェクトの位置と同期させるために<code>collider.Position = Position;</code>としています。</p>
<p>さらに<code>OnAdded</code>関数と<code>OnRemoved</code>関数があると思います。こちらはエンジンにオブジェクトが追加されたタイミングと消去されたタイミングで呼ばれます。この時変数<code>objects</code>に追加と削除をしてエンジンに追加されているオブジェクトのみをコレクションに残しておきます。</p>
<p>Survey関数です。</p>
<pre><code class="lang-C#">// 衝突判定を調査する
private void Survey()
{
    // objects内の全オブジェクトを検索し，衝突が確認されたオブジェクト間でCollideWithを実行
    foreach (var obj in objects)
        if (collider.GetIsCollidedWith(obj.collider))
            CollideWith(obj);
}
</code></pre>
<p>コライダ間の衝突は<code>GetIsCollidedWith</code>関数で取ることができます。この関数は衝突している場合<code>true</code>を返すのでif文で衝突した場合に<code>CollideWith</code>が呼ばれます。<code>CollideWith</code>には衝突した場合の処理を書いていきます。</p>
<p>ここで、<code>foreach</code>とは<code>for</code>文の拡張で、</p>
<pre><code class="lang-cs">foreach (var obj in objects)
</code></pre>
<p>というのは、 「 <code>objects</code> の要素をとりだして、 <code>obj</code> と名前を付ける」 ことを<code>objects</code> の全要素について行ってくれます。<br>
今回は<code>foreach</code>文を使って<code>objects</code>から取り出した<code>CollidableObject</code>である<code>obj</code>のコライダ<code>obj.collider</code>と自身のコライダ<code>collider</code>の間での当たり判定を取っています。<br>
また、<code>var</code>というキーワードがあります。これは<strong>型推論</strong>と呼ばれるもので、名前の通り変数の宣言の際に型を推論してくれるというものです。なので上の<code>foreach</code>文は</p>
<pre><code class="lang-C#">foreach (CollidableObject obj in objects)
    if (collider.GetIsCollidedWith(obj.collider))
        CollideWith(obj);
</code></pre>
<p>このようにしても大丈夫です。ただ、<code>var</code>を使ったほうが記述が短くて楽です。</p>
<p><code>foreach</code>と<code>var</code>についての詳しい解説を以下に載せておきます。</p>
<p><a href="https://ufcpp.net/study/csharp/sp_foreach.html">C# によるプログラミング入門 : foreach</a><br>
<a href="https://ufcpp.net/study/csharp/sp3_inference.html">C# によるプログラミング入門 : 型推論</a></p>
<p><code>CollideWith</code>関数では衝突時の処理を書いていきます。</p>
<pre><code class="lang-C#">// 衝突時に実行
private void CollideWith(CollidableObject obj)
{
    // nullだったら終了
    if (obj == null)
    {
        return;
    }

    // 衝突対象がSurveyを実行しないオブジェクトだった場合，相手のOnCollisionも実行
    if (!obj.doSurvey)
    {
        obj.OnCollision(this);
    }

    // 自身のOnCollisiionを実行
    OnCollision(obj);
}
</code></pre>
<p>ここで，<code>Survey</code>を実行しないオブジェクト(=<code>doSurvey</code>が<code>false</code>)に対して<code>OnCollision</code>を呼び出しています。
何故，全ての<code>CollidableObject</code>に対して<code>Survey</code>を実行させず，<code>doSurvey</code>のような面倒な処理を挟むのかというのが気になるかと思います。
後々説明しますが，<code>doSurvey</code>フラグは自機や敵では<code>true</code>，自機弾や敵弾では<code>false</code>にします。
もし仮に全ての<code>CollidableObject</code>にて<code>Survey</code>を走らせるとなると，衝突判定が計算される回数は<code>objects</code>に登録されている<code>CollidableObject</code>の2乗に相当します。
弾というオブジェクトは，自機や敵の個数に比べて大量に画面上に出現する機会が多いです。その為，弾幕シューティングを作ったときなどは処理が重くなることがあります。
それを避けるために<code>doSurvey</code>というフラグを用いて<code>Survey</code>を実行する回数を最小限に留める事が出来ます。
プログラミングを行う際はこのようにパフォーマンスを意識するという事も大事です(最初のうちは動くこと重視，慣れてきたら意識すると良いです)。</p>
<p>オブジェクトにより当たった時の処理は異なるので継承先で<code>OnCollision</code>関数をオーバーライドさせて処理を継承先に委託するようにしています。<br>
<code>OnCollision</code>関数にあるキーワード<code>virtual</code>は仮想メソッドと呼ばれるものでこれをつけることで継承先で関数のオーバーライドができます。</p>
<p><a href="https://ufcpp.net/study/csharp/oo_polymorphism.html?key=virtual_method#virtual_method">C# によるプログラミング入門 : 多態性</a></p>
<pre><code class="lang-C#">// 衝突時に実行される内容をオーバーライドして設定できる
protected virtual void OnCollision(CollidableObject obj)
{

}
</code></pre>
<h2 id="当たり判定を持つクラスへの切り替え">当たり判定を持つクラスへの切り替え</h2>
<p>ざっとですが基本的なコライダの使い方を解説しました。<br>
次は継承先での処理を作っていきましょう。</p>
<p>まずは各クラスを<code>CollidableObject</code>から継承させるようにします。<br>
<code>Player</code> クラス</p>
<pre><code class="lang-diff">-   public class Player : SpriteNode
+   public class Player : CollidableObject
</code></pre>
<p><code>Enemy</code> クラス</p>
<pre><code class="lang-diff">-    public class Enemy : SpriteNode
+    public class Enemy : CollidableObject
</code></pre>
<p><code>Bullet</code> クラス</p>
<pre><code class="lang-diff">-    class Bullet : SpriteNode
+    class Bullet : CollidableObject
</code></pre>
<p>さらにコンストラクタも書き換えていきます。
冒頭でも少し触れましたが<code>Enemy</code>クラスと<code>Bullet</code>クラスの<code>RemoveMyselfIfOutOfWindow</code>関数は親クラスである<code>CollidableObject</code>に移したのでついでに削除しましょう。
また，<code>CollidableObject</code>の<code>OnUpdate</code>に処理を書いたので，<code>base.OnUpdate</code>を呼び出しましょう。</p>
<p><code>Player</code> クラス</p>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // プレイヤーのクラス
    public class Player : CollidableObject
    {
        // コンストラクタ
-       public Player(Vector2F position)
+       public Player(MainNode mainNode, Vector2F position) : base(mainNode, position)
        {
-           // 座標を設定
-           Position = position;

+           // 衝突判定を行うように設定
+           doSurvey = true;

            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;

+           // コライダの半径を設定
+           collider.Radius = Texture.Size.Y / 2;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 移動を実行
            Move();

            // ショットを実行
            Shot();

+           // CollidableObjectのOnUpdate呼び出し
+           base.OnUpdate();
        }

        ...略...

    }
}
</code></pre>
<p><code>Enemy</code> クラス</p>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // 敵の基礎となるクラス
    public class Enemy : CollidableObject
    {
        // 倒された時に加算されるスコアの値
        protected int score;
        
        // プレイヤーへの参照
        protected Player player;
        
        // コンストラクタ
-       public Enemy(Player player, Vector2F position)
+       public Enemy(Player player, Vector2F position) : base(player.mainNode, position)
        {
+           // 衝突判定を行うように設定
+           doSurvey = true;

-           // 座標を設定
-           Position = position;

            // プレイヤーへの参照を設定
            this.player = player;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // CollidableObjectのOnUpdateを実行
            base.OnUpdate();

+           // 画面外に出たら自身を削除
+           RemoveMyselfIfOutOfWindow();
        }

-       private void RemoveMyselfIfOutOfWindow()
-       {
-           var halfSize = Texture.Size / 2;
-           if (Position.X &lt; -halfSize.X
-               || Position.X &gt; Engine.WindowSize.X + halfSize.X
-               || Position.Y &lt; -halfSize.Y
-               || Position.Y &gt; Engine.WindowSize.Y + halfSize.Y)
-           {
-               // 自身を削除
-               Parent?.RemoveChildNode(this);
-           }
-       }
    }
}
</code></pre>
<p><code>Bullet</code> クラス</p>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // 弾のクラス
    public class Bullet : CollidableObject
    {
        // フレーム毎に進む距離
        private Vector2F velocity;

        // コンストラクタ
-       public Bullet(Vector2F position, Vector2F velocity)
+       public Bullet(MainNode mainNpde, Vector2F position, Vector2F velocity) : base(mainNpde, position)
        {
+           // 衝突判定を行わないように設定
+           doSurvey = false;

-           // 座標を設定
-           Position = position;

            // 弾速を設定
            this.velocity = velocity;

            // 表示位置をプレイヤーや敵より奥に設定
            ZOrder--;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 座標を速度分進める
            Position += velocity;

+           // CollidableObjectのOnUpdateを呼び出す
+           base.OnUpdate();

            // 画面外に出たら自身を削除
            RemoveMyselfIfOutOfWindow();
        }

-       private void RemoveMyselfIfOutOfWindow()
-       {
-           var halfSize = Texture.Size / 2;
-           if (Position.X &lt; -halfSize.X
-               || Position.X &gt; Engine.WindowSize.X + halfSize.X
-               || Position.Y &lt; -halfSize.Y
-               || Position.Y &gt; Engine.WindowSize.Y + halfSize.Y)
-           {
-               // 画面外に出たら自身を削除
-               Parent?.RemoveChildNode(this);
-           }
-       }
    }
}
</code></pre>
<p>ここでコンストラクタの後ろに<code>base</code>というキーワードが出てきました。これは親クラスのコンストラクタ呼び出しという意味です。今回だと<code>ColliderObject</code>のコンストラクタを呼び出します。<code>ColliderObject</code>のコンストラクタでは<code>MainNode</code>と<code>position</code>が必要なため<code>base</code>の後の引数で受け渡します。<code>base</code>についての詳しい解説はこちらを参照してください。</p>
<p><a href="https://ufcpp.net/study/csharp/oo_inherit.html#base_ctor">C# によるプログラミング入門 : 継承</a></p>
<p>また、<code>ColliderObject</code>のコンストラクタで座標を設定する処理があるので子クラスでは座標を設定するコードは消しています。</p>
<p><code>Bullet</code>の修正に併せて<code>EnemyBullet</code>と<code>PlayerBullet</code>のコードも修正していきましょう。</p>
<p>これらはコンストラクタの引数変更と半径を設定させるだけで大丈夫です</p>
<p><code>EnemyBullet</code> クラス</p>
<pre><code class="lang-diff" name="Main">+       public EnemyBullet(MainNode mainNode, Vector2F position, Vector2F velocity) : base(mainNode, position, velocity)
-       public EnemyBullet(Vector2F position, Vector2F velocity) : base(position, velocity)
        {
            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Red.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;

+           // 半径を設定
+           collider.Radius = Texture.Size.X / 2;
        }
</code></pre>
<p><code>PlayerBullet</code> クラス</p>
<pre><code class="lang-diff" name="Main">+       public PlayerBullet(MainNode mainNode, Vector2F position) : base(mainNode, position, new Vector2F(10f, 0.0f))
-       public PlayerBullet(Vector2F position) : base(position, new Vector2F(10f, 0.0f))
        {
            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;

+           // 半径を設定
+           collider.Radius = Texture.Size.X / 2;
        }
</code></pre>
<p>次に<code>Enemy</code>クラスの変更に併せてその派生クラスである<code>ChaseEnemy</code>クラスと<code>RadialShotEnemy</code>クラスと<code>StraightShotEnemy</code>クラスと<code>Meteor</code>クラスを書き換えていきます。先ほど<code>EnemyBullet</code>クラスの引数を変更したので<code>Shot</code>関数の<code>EnemyBullet</code>を生成するコードもついでに書き換えましょう。</p>
<p><code>ChaseEnemy</code> クラス</p>
<pre><code class="lang-diff" name="Main">        public ChaseEnemy(Player player, Vector2F position, float speed) : base(player, position)
        {
            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/UFO.png&quot;);

            // 中心座標を設定
            CenterPosition = ConentSize / 2;

+           // 半径を設定
+           collider.Radius = Texture.Size.X / 2;

            // 移動速度を設定
            this.speed = speed;

            // 自身が倒された時に加算されるスコアを設定
            score = 10;
        }
</code></pre>
<p><code>RadialShotEnemy</code> クラス</p>
<pre><code class="lang-diff" name="Main">        public RadialShotEnemy(Player player, Vector2F position, int shotAmount) : base(player, position)
        {
            // 撃ち出すショットの個数を設定
            this.shotAmount = shotAmount;

            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/UFO.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;

+           // 半径を設定
+           collider.Radius = Texture.Size.X / 2;

            // スコアを設定
            score = 30;
        }

        // 弾を撃つ
        private void Shot(Vector2F velocity)
        {
            // 敵弾を画面に追加
+            Parent.AddChildNode(new EnemyBullet(mainNode, Position, velocity));
-            Parent.AddChildNode(new EnemyBullet(Position, velocity));
        }
</code></pre>
<p><code>StraightShotEnemy</code> クラス</p>
<pre><code class="lang-diff" name="Main">        public StraightShotEnemy(Player player, Vector2F position) : base(player, position)
        {
            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/UFO.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;

+           // 半径を設定
+           collider.Radius = Texture.Size.X / 2;

            // 倒された時に加算されるスコアを設定
            score = 20;
        }

                // 弾を撃つ
        private void Shot(Vector2F velocity)
        {
            // 敵弾を画面に追加
+            Parent.AddChildNode(new EnemyBullet(mainNode, Position, velocity));
-            Parent.AddChildNode(new EnemyBullet(Position, velocity));
        }
</code></pre>
<p><code>Meteor</code> クラス</p>
<pre><code class="lang-diff" name="Main">        public Meteor(Player player, Vector2F position, Vector2F velocity) : base(player, position)
        {
            // 速度の設定
            this.velocity = velocity;

            // テクスチャの設定
            Texture = Texture2D.LoadStrict(&quot;Resources/Meteor.png&quot;);

            // 中心座標の設定
            CenterPosition = ContentSize / 2;

+           // 半径の設定
+           collider.Radius = Texture.Size.X / 2;

            // スコアの設定
            score = 1;
        }
</code></pre>
<p>さらに<code>Player</code>クラスで<code>PlayerBullet</code>を使用していたのでこちらも修正が必要になります。</p>
<p><code>Player</code> クラスの <code>Shot</code> 関数</p>
<pre><code class="lang-diff" name="Main">        // ショット
        private void Shot()
        {
            // Zキーでショットを放つ
            if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
            {
+               Parent.AddChildNode(new PlayerBullet(mainNode, Position));
-               Parent.AddChildNode(new PlayerBullet(Position));
            }
        }
</code></pre>
<p>最後に<code>MainNode</code>クラスを修正します。まず、<code>Player</code>クラスの呼び出しの変更が必要です。さらにもう一つ変更が必要です。もし<code>MainNode</code>が消去されてもコライダがコレクションに残っている場合、使われていないコライダがコレクションに保存され続けるとになります。この場合、ゲームのリトライなどを行うとリトライ前のコライダが残ってしまい、バグなどを引き起こす恐れがあるのでコライダの消去を行います。<code>HashSet</code>クラスの中身消去は<code>Clear</code>関数でできます。</p>
<p><code>MainNode</code> クラス</p>
<pre><code class="lang-diff" name="Main">        protected override void OnAdded()
        {
            // ================================================================
            // 省略
            // ================================================================    
                
            // プレイヤーを設定
+            player = new Player(this, new Vector2F(100, 360));
-            player = new Player(new Vector2F(100, 360));
                
            // ================================================================
            // 省略
            // ================================================================
        }

+       // エンジンから削除されたときに実行
+       protected override void OnRemoved()
+       {
+           // 衝突判定を全てリセット
+           CollidableObject.objects.Clear();
+       }
</code></pre>
<p>これでひと段落と思いきや、衝突時の処理をまだ書いていないので衝突してもまだ何も起こりません。次にそれぞれのクラスで衝突した時の処理を書いていきたいところですが、先に衝突したときのエフェクトを作りましょう。</p>
<h2 id="effectを作成するクラス">Effectを作成するクラス</h2>
<p>衝突したときに出すエフェクトである<code>DeathEffect</code>クラスを作ります。<br>
<code>DeathEffect</code>のコードは以下のようになります。</p>
<pre><code class="lang-csharp" name="Main">using Altseed2;

namespace Tutorial
{
    // 死亡時エフェクト
    public class DeathEffect : SpriteNode
    {
        // カウンタ
        private int count = 0;

        // コンストラクタ
        public DeathEffect(Vector2F position)
        {
            // 座標を設定
            Position = position;

            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Explosion.png&quot;);

            // 中心座標を設定
            CenterPosition = new Vector2F(32f, 32f);

            // 表示位置をプレイヤーや敵よりも手前に設定
            ZOrder++;

            // テクスチャの描画範囲を設定
            Src = new RectF(new Vector2F(), new Vector2F(Texture.Size.X / 9, Texture.Size.Y));
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 表示されるテクスチャのサイズを取得
            var size = new Vector2F(Texture.Size.X / 9, Texture.Size.Y);

            // 表示されるテクスチャの左上の座標を計算する
            var pos = new Vector2F(size.X * (count / 2 % 9), size.Y);

            // 描画範囲を設定
            Src = new RectF(pos, size);

            // カウントを進める
            count++;

            // カウントが18以上で自身を削除
            if (count &gt;= 18)
            {
                Parent.RemoveChildNode(this);
            }
        }
    }
}
</code></pre>
<p>どのように実装されているかというと以下のような画像の一部を表示して表示位置をずらしてあげることでアニメーションのような効果を出しています。</p>
<p><img src="Image/Explosion.png" alt="DeathEffect"></p>
<p>コード中で使われている<code>Src</code>について説明します。今までは<code>Texture</code>に設定された画像全てを描画していましたが、今回は画像の一部だけを切り取って描画する必要があります。
そこで、<code>Src</code> を使用します。<code>Src</code>は<code>SpriteNode</code>クラスの持つフィールドで、<code>Src</code>に値を設定すると画像の中で指定された範囲のみが描画されるようになります。<code>Src</code>に値を設定する方法ですが、第一引数は表示したい範囲の左上の座標を、第二引数はその座標から表示する範囲を指定します</p>
<pre><code class="lang-C#">// 描画範囲を設定
Src = new RectF(pos, size);
</code></pre>
<p>設定する変数<code>size</code>と<code>pos</code>は<code>count</code>という毎フレーム1ずつ増える整数の変数を作って計算します。今回は2フレームごとに画像をずらすような式にしてあります。上に示した画像は爆破の画像が横に9枚並んでいるもので、2フレーム×9=18なので<code>count</code>が18になった場合<code>Parent.RemoveChildNode(this);</code>により自身を削除してエフェクトの再生を終了します。</p>
<pre><code class="lang-cs" name="Main">// 表示されるテクスチャのサイズを取得
var size = new Vector2F(Texture.Size.X / 9, Texture.Size.Y);

// 表示されるテクスチャの左上の座標を計算する
var pos = new Vector2F(size.X * (count / 2 % 9), size.Y);

// 描画範囲を設定
Src = new RectF(pos, size);

// カウントを進める
count++;

// カウントが18以上で自身を削除
if (count &gt;= 18)
{
    Parent.RemoveChildNode(this);
}
</code></pre>
<p>爆破のエフェクトが完成したので衝突時の処理を書いていきましょう。</p>
<h2 id="oncollideの実装">OnCollideの実装</h2>
<p><code>CollidableObject</code>では衝突したときに<code>OnCollide</code>関数を呼び出すように実装しましたね。なので子クラスで<code>OnCollide</code>関数の中身を記述してあげればよいです。<br>
衝突時に処理するクラスは<code>Player</code>と<code>Enemy</code>と<code>PlayerBullet</code>と<code>EnemyBullet</code>の4クラスになります。<br>
これら4つの<code>OnCollide</code>関数を以下に載せます。</p>
<p><code>Player</code> クラス</p>
<pre><code class="lang-cs" name="Main">// 衝突時に実行
protected override void OnCollision(CollidableObject obj)
{
    // 衝突対象が敵か敵の弾だったら
    if (obj is Enemy || obj is EnemyBullet)
    {
        // 自身を親から削除
        Parent.RemoveChildNode(this);
    }
}
</code></pre>
<p><code>PlayerBullet</code> クラス</p>
<pre><code class="lang-cs" name="Main">// 衝突時に実行
protected override void OnCollision(CollidableObject obj)
{
    // 衝突対象が敵だったら自身を削除
    if (obj is Enemy)
    {
        Parent?.RemoveChildNode(this);
    }
}
</code></pre>
<p><code>Enemy</code> クラス</p>
<pre><code class="lang-cs" name="Main">// 衝突時に実行
protected override void OnCollision(CollidableObject obj)
{
    // 衝突対象が自機弾だったら
    if (obj is PlayerBullet)
    {
        // 死亡時エフェクトを再生
        Parent.AddChildNode(new DeathEffect(Position));

        // 自身を削除
        Parent.RemoveChildNode(this);
    }
}
</code></pre>
<p><code>EnemyBullet</code> クラス</p>
<pre><code class="lang-cs" name="Main">// 衝突時に実行
protected override void OnCollision(CollidableObject obj)
{
    // 衝突対象がプレイヤーだったらBulletのOnCollisionを実行して削除
    if (obj is Player)
    {
        Parent?.RemoveChildNode(this);
    }
}
</code></pre>
<p>ここで<code>is</code>というキーワードがありますね。これは<strong>is演算子</strong>と呼ばれるものです。この<code>is</code>というのは変数<code>obj</code>がどの型を継承しているのか判断するために使えます。一例ですが、<code>if (obj is Enemy)</code>と書けば、<code>obj</code>が<code>Enemy</code>クラスか、その派生クラスの時に処理をすることができます。<br>
余談ですが似たような機能に<strong>as演算子</strong>というものがあります。こちらは戻り値が<code>bool</code>ではなく型変換したものになります。
<strong>is演算子</strong>と<strong>as演算子</strong>について詳しく知りたい方は以下を参照してください。</p>
<p><a href="https://ufcpp.net/study/csharp/oo_polymorphism.html#downcast">C# によるプログラミング入門 : 多態性</a></p>
<h2 id="meteorクラス改変">Meteorクラス改変</h2>
<p>今、<code>Meteor</code>クラスの衝突処理は<code>Enemy</code>クラスの<code>OnCollide</code>が呼ばれるので、<code>Player</code>の弾に当たると消滅します。これで完成してもよいのですが、<code>Meteor</code>というからには岩石で硬いはずなので<code>Player</code>の弾ごとき3回くらいまでなら耐えると思います。 そのように改変しましょう。</p>
<p><code>Meteor</code> クラス</p>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // 隕石
    public class Meteor : Enemy
    {
        // フレーム毎の移動速度
        private Vector2F velocity;

+       // HP
+       private int HP = 3;

        // コンストラクタ、OnUpdate略

+        protected override void OnCollision(CollidableObject obj)
+        {
+           // 衝突したのが自機弾だったら
+           if (obj is PlayerBullet)
+           {
+               // HPを1減らす
+               HP--;
+               // HPが0になったらEnemyクラスのOnCollisionを呼び出して削除
+               if (HP == 0)
+               {
+                  base.OnCollision(obj);
+              }
+           }
+       }
+   }
}
</code></pre>
<p>HPというフィールドを追加して、プレイヤーの弾に当たる度にHPを1減らしていき、HPが0になったら消滅するというシンプルな処理です。<br>
このように<code>Enemy</code>クラスでオーバーライドした<code>OnCollision</code>をさらにオーバーライドすると親クラスの<code>OnCollision</code>は呼ばれなくなり、子クラスの処理に切り替わります。</p>
<p>長い工程を経て衝突判定と衝突時の処理が完成しました。実行してみると敵に衝突したり、自弾が敵に衝突したときにエフェクトが出て画面から消えることが確認できると思います。</p>
<h2 id="まとめ">まとめ</h2>
<p>今回は衝突判定をつけてみました。ようやくゲームらしさが増してきましたね。<br>
<code>Altseed2</code>では<code>CircleCollider</code>以外にも多角形のコライダである<code>PolygonCollier</code>クラスや四角形のコライダである<code>RectangleCollider</code>クラスがあります。もし、厳密さが必要な形のオブジェクトに衝突判定をつけたい場合はそちらを使ってみてください。</p>
<p>次章では音を鳴らしてみます。</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright &copy; 2020 Altseed .
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
