<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>9&#31456; : &#12479;&#12452;&#12488;&#12523;&#12539;&#12466;&#12540;&#12512;&#12458;&#12540;&#12496;&#12540;&#30011;&#38754;&#12434;&#20316;&#12387;&#12390;&#12415;&#12424;&#12358; | Altseed2 </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="9&#31456; : &#12479;&#12452;&#12488;&#12523;&#12539;&#12466;&#12540;&#12512;&#12458;&#12540;&#12496;&#12540;&#30011;&#38754;&#12434;&#20316;&#12387;&#12390;&#12415;&#12424;&#12358; | Altseed2 ">
    <meta name="generator" content="docfx 2.57.2.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link rel="stylesheet" href="../../styles/reference.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" src="../../Logo.png" alt="" style="height:100%;margin-right:15px;">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href="../../Tutorials/index.html" title="&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;">&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;</a>
                      </li>
                      <li>
                          <a href="../../Manual/index.html" title="&#27231;&#33021;&#35299;&#35500;">&#27231;&#33021;&#35299;&#35500;</a>
                      </li>
                      <li>
                          <a href="../../References/Altseed2.html" title="&#12522;&#12501;&#12449;&#12524;&#12531;&#12473;">&#12522;&#12501;&#12449;&#12524;&#12531;&#12473;</a>
                      </li>
                      <li>
                          <a href="../../First/index.html" title="&#21021;&#20195;Altseed&#12399;&#12467;&#12481;&#12521;">&#21021;&#20195;Altseed&#12399;&#12467;&#12481;&#12521;</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"> <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="data-prev=" data-next="data-last="></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle"></a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <a href="../index.html" title="&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;" class="">&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;</a>
                    </li>
                    <li class="">
                      <a href="../Chap0/index.html" title="0&#31456; : Altseed&#12434;&#21021;&#12417;&#12424;&#12358;" class="">0&#31456; : Altseed&#12434;&#21021;&#12417;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap1/index.html" title="1&#31456; : &#12454;&#12451;&#12531;&#12489;&#12454;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">1&#31456; : &#12454;&#12451;&#12531;&#12489;&#12454;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap2/index.html" title="2&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12434;&#25551;&#30011;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">2&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12434;&#25551;&#30011;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap3/index.html" title="3&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12395;&#24382;&#12434;&#25731;&#12383;&#12379;&#12390;&#12415;&#12424;&#12358;" class="">3&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12395;&#24382;&#12434;&#25731;&#12383;&#12379;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap4/index.html" title="4&#31456; : &#12463;&#12521;&#12473;&#12434;&#33258;&#20998;&#12391;&#35373;&#35336;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">4&#31456; : &#12463;&#12521;&#12473;&#12434;&#33258;&#20998;&#12391;&#35373;&#35336;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap5/index.html" title="5&#31456; : &#25973;&#12539;&#25973;&#12398;&#12471;&#12519;&#12483;&#12488;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">5&#31456; : &#25973;&#12539;&#25973;&#12398;&#12471;&#12519;&#12483;&#12488;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap6/index.html" title="6&#31456; : &#24403;&#12383;&#12426;&#21028;&#23450;&#12398;&#27231;&#33021;&#12434;&#20351;&#12387;&#12390;&#12415;&#12424;&#12358;" class="">6&#31456; : &#24403;&#12383;&#12426;&#21028;&#23450;&#12398;&#27231;&#33021;&#12434;&#20351;&#12387;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap7/index.html" title="7&#31456; : &#38899;&#12434;&#40180;&#12425;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">7&#31456; : &#38899;&#12434;&#40180;&#12425;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap8/index.html" title="8&#31456; : &#24471;&#28857;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">8&#31456; : &#24471;&#28857;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="active">
                      <a href="../Chap9/index.html" title="9&#31456; : &#12479;&#12452;&#12488;&#12523;&#12539;&#12466;&#12540;&#12512;&#12458;&#12540;&#12496;&#12540;&#30011;&#38754;&#12434;&#20316;&#12387;&#12390;&#12415;&#12424;&#12358;" class="active">9&#31456; : &#12479;&#12452;&#12488;&#12523;&#12539;&#12466;&#12540;&#12512;&#12458;&#12540;&#12496;&#12540;&#30011;&#38754;&#12434;&#20316;&#12387;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap10/index.html" title="10&#31456; : &#12356;&#12374;&#12289;&#20844;&#38283;&#28310;&#20633;" class="">10&#31456; : &#12356;&#12374;&#12289;&#20844;&#38283;&#28310;&#20633;</a>
                    </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="9章--タイトルゲームオーバー画面を作ってみよう">9章 : タイトル・ゲームオーバー画面を作ってみよう</h1>

<p>ここまでの実装でシューティングとしてほぼほぼ完成形になりました。<br>
あと一息，タイトル画面や死亡時のゲームオーバー画面を作ればもうゲームとして成立してしまいます。</p>
<h2 id="タイトル画面の追加">タイトル画面の追加</h2>
<h3 id="タイトルノードの実装">タイトルノードの実装</h3>
<p>まず以下のコードを追加してタイトル画面を作りましょう。</p>
<pre><code class="lang-diff" name="Main">+ using Altseed2;
+ 
+ namespace Tutorial
+ {
+   // タイトル画面
+   public class TitleNode : Node
+   {
+       // 画面が遷移中かどうか
+       private bool fading = false;
+
+       // エンジンに追加された時に実行
+       protected override void OnAdded()
+       {
+           // タイトル
+           var titleText = new TextNode();
+           // タイトルのフォントを読み込む
+           titleText.Font = Font.LoadDynamicFontStrict(&quot;Resources/GenYoMinJP-Bold.ttf&quot;);
+           // タイトルの文字のサイズを設定
+           titleText.FontSize = 100;
+           // タイトルの文字を設定
+           titleText.Text = &quot;Tutorial STG&quot;;
+           // タイトルの座標を設定
+           titleText.Position = new Vector2F(Engine.WindowSize.X / 2, 100f);
+           // タイトルの中心座標を設定
+           titleText.CenterPosition = titleText.ContentSize / 2;
+
+           // タイトルを追加
+           AddChildNode(titleText);
+
+           // 画面下に表示される案内
+           var announce = new TextNode();
+           // 案内のフォントを読み込む
+           announce.Font = Font.LoadDynamicFontStrict(&quot;Resources/GenYoMinJP-Bold.ttf&quot;);
+           // 案内の文字のサイズを設定
+           announce.FontSize = 50;
+           // 案内の文字を設定
+           announce.Text = &quot;Press Z to start&quot;;
+           // 案内の座標を設定
+           announce.Position = new Vector2F(Engine.WindowSize.X / 2, 600f);
+           // 案内の中心座標を設定
+           announce.CenterPosition = announce.ContentSize / 2;
+          
+           // 案内を追加
+           AddChildNode(announce);
+
+           // 背景のテクスチャ
+           var backTexture = new SpriteNode();
+           // 背景のテクスチャを読み込む
+           backTexture.Texture = Texture2D.LoadStrict(&quot;Resources/image.png&quot;);
+           // 背景の表示位置を奥に設定
+           backTexture.ZOrder = -1;
+
+           // 背景を追加
+           AddChildNode(backTexture);
+       }
+
+       // フレーム毎に実行
+       protected override void OnUpdate()
+       {
+           // 画面が遷移中でなく，Zキーが押された時に実行
+           if (!fading &amp;&amp; Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
+           {
+               // エンジンから自身を削除
+               Engine.RemoveNode(this);
+
+               // エンジンにメイン画面を追加
+               Engine.AddNode(new MainNode());
+
+               // 画面遷移中のフラグを立てる
+               fading = true;
+           }
+       }
+   }
+ }
</code></pre>
<p>基本的に実装は今迄行ってきたような，<code>SpriteNode</code>や<code>TextNode</code>を用いた画像/文字の描画です。</p>
<p>ここで注意する点が2つあります。</p>
<p>1つ目は</p>
<pre><code class="lang-cs">// エンジンから自身を削除
Engine.RemoveNode(this);

// エンジンにメイン画面を追加
Engine.AddNode(new MainNode());
</code></pre>
<p>の部分です。
第4章にて，<code>Program.cs</code>で<code>Engine.AddNode(Node)</code>は書きましたね。
ここでは，<strong>タイトル画面でZキーを押したときメインのシューティング画面に変更する処理</strong>を行っています。</p>
<p>タイトル画面にいるときは，ノードの親子関係はこのようになっています。</p>
<p><img src="Image/Pic1.png" alt="Pic1"></p>
<p>此処における<code>Root</code>は，<code>Engine</code>内で定義されている全てのノードの祖先となるノードです。
<code>TitleNode</code>の子ノードとして，タイトルのテキストや案内の文字，背景のテクスチャがあります。
この状態で<code>Engine.RemoveNode(TitleNode)</code>を行うとノードの親子関係はこのようになります。</p>
<p><img src="Image/Pic2.png" alt="Pic2"></p>
<p><code>Root</code>と<code>TitleNode</code>の親子関係が解消され，<code>TitleNode</code>に登録されているテキストやテクスチャがウィンドウに描画されなくなります。
<code>Root.RemoveNode(TitleNode)</code>とやっていることに違いはありません。</p>
<p>次に<code>Engine.AddNode(MainNode)</code>を行う事でノードの親子関係は次のようになります。</p>
<p><img src="Image/Pic3.png" alt="Pic3"></p>
<p><code>Root</code>の子に<code>MainNode</code>が追加され，<code>MainNode</code>での実装が実行されます。
前の章で実装してきたシューティングゲーム本体の内容ですね。</p>
<p>此処で大事なのは，<strong>Engine.Rootの子孫になったノードに描画や更新処理が適用される</strong>という事です。
描画や更新をしたくないノードは<code>Remove</code>して，描画や更新を実行したいノードを<code>Add</code>するようにしましょう。</p>
<p>2つ目は</p>
<pre><code class="lang-cs">// 画面が遷移中かどうか
private bool fading = false;
</code></pre>
<p>の部分です。</p>
<p>この変数は，タイトル画面でZキーを押したときに<code>true</code>に変更されます。</p>
<pre><code class="lang-cs">// 画面が遷移中でなく，Zキーが押された時に実行
if (!fading &amp;&amp; Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
{
</code></pre>
<p>そして，<code>true</code>になるとこのif文の条件の様に，もう一度Zキーを押してもif文の内容が実行されなくなります。
これは，Zキー連打によって<code>MainNode</code>が<code>Root</code>に複数追加されるのを防ぎたいという事です。</p>
<h3 id="タイトルノードへの遷移を追加">タイトルノードへの遷移を追加</h3>
<p>タイトルを実装したので，実際にゲームを始めた時に最初に表示されるようにしてみましょう。<br>
<code>Program.cs</code>のコードを次のように書き換えてみましょう。</p>
<pre><code class="lang-diff" name="Main">namespace Tutorial
{
    class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

+           // タイトル画面をエンジンに追加
+           Engine.AddNode(new TitleNode());
-           // メイン画面をエンジンに追加
-           Engine.AddNode(new MainNode());

            // メインループ
            while (Engine.DoEvents())
            {
                …以下略…
</code></pre>
<p>これで最初に表示されるノードが<code>MainNode</code>から<code>TitleNode</code>に変わりました。</p>
<h2 id="ゲームオーバー画面の追加">ゲームオーバー画面の追加</h2>
<p>次は死亡時にゲームオーバー画面を表示してみましょう。
<code>TitleNode</code>と同様に実装します。</p>
<pre><code class="lang-diff" name="Main">+ using Altseed2;
+
+ namespace Tutorial
+ {
+   // ゲームオーバー画面
+   public class GameOverNode : Node
+   {
+       // 画面が遷移中かどうか
+       private bool fading = false;
+
+       // エンジンに追加された時に実行
+       protected override void OnAdded()
+       {
+           // タイトル
+           var titleText = new TextNode();
+           // タイトルのフォントを読み込む
+           titleText.Font = Font.LoadDynamicFontStrict(&quot;Resources/GenYoMinJP-Bold.ttf&quot;);
+           // タイトルの文字のサイズを設定
+           titleText.FontSize = 100;
+           // タイトルの文字を設定
+           titleText.Text = &quot;Game Over&quot;;
+           // タイトルの座標を設定
+           titleText.Position = new Vector2F(Engine.WindowSize.X / 2, 100f);
+           // タイトルの中心座標を設定
+           titleText.CenterPosition = titleText.ContentSize / 2;
+           // タイトルを追加
+           AddChildNode(titleText);
+
+           // 画面下に表示される案内
+           var announce = new TextNode();
+           // 案内のフォントを読み込む
+           announce.Font = Font.LoadDynamicFontStrict(&quot;Resources/GenYoMinJP-Bold.ttf&quot;);
+           // 案内の文字のサイズを設定
+           announce.FontSize = 50;
+           // 案内の文字を設定
+           announce.Text = &quot;Press Z to go title&quot;;
+           // 案内の座標を設定
+           announce.Position = new Vector2F(Engine.WindowSize.X / 2, 600f);
+           // 案内の中心座標を設定
+           announce.CenterPosition = announce.ContentSize / 2;
+           // 案内を追加
+           AddChildNode(announce);
+       }
+
+       // フレーム毎に実行
+       protected override void OnUpdate()
+       {
+           // 画面が遷移中でなく，Zキーが押された時に実行
+           if (!fading &amp;&amp; Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
+           {
+               // エンジンから自身を削除
+               Engine.RemoveNode(this);
+
+               // エンジンにタイトル画面を追加
+               Engine.AddNode(new TitleNode());
+
+               // 画面遷移中のフラグを立てる
+               fading = true;
+           }
+       }
+   }
+ }
</code></pre>
<p>次に，<code>MainNode</code>に，ゲームオーバーへの遷移メソッドを実装します。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System.Collections.Generic;

namespace Tutorial
{
    // メインステージのクラス
    public class MainNode : Node
    {
        ...略...

        // スコアを表示するノード
        private TextNode scoreNode;

+       // 他画面へ遷移しているかどうか
+       private bool fading = false;

        // スコア
        public int score;

        ...略...

+       // ゲームオーバー画面に遷移
+       public void ToGameOver()
+       {
+           // BGMをフェードアウト
+           if (bgmID.HasValue)
+           {
+               Engine.Sound.FadeOut(bgmID.Value, 1.0f);
+
+               // BGMが止まったのでIDをnullに
+               bgmID = null;
+           }
+
+           // 画面遷移中でないなら遷移処理を実行
+           if (!fading)
+           {
+               // 自身をエンジンから削除
+               Engine.RemoveNode(this);
+
+               // エンジンにゲームオーバー画面を追加
+               Engine.AddNode(new GameOverNode());
+
+               // 遷移中フラグを縦立てる
+               fading = true;
+           }
+       }

        // 敵召還関連
        private void UpdateStage()
        ...略...
    }
}
</code></pre>
<p>これで，<code>ToGameOver()</code>メソッドを呼び出すことでゲームオーバー画面に遷移できるようになりました。
ゲームオーバーの呼び出しはプレイヤーが死亡したとき，つまりプレイヤーが敵/敵弾に衝突したときに呼び出せば良いですね。<br>
それでは，以下のように<code>Player.cs</code>にて呼び出してみましょう。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // プレイヤーのクラス
    public class Player : CollidableObject
    {
        ...略...

        // 衝突時に実行
        protected override void OnCollision(CollidableObject obj)
        {
            // 衝突対象が敵か敵の弾だったら
            if (obj is Enemy || obj is EnemyBullet)
            {
                // 死亡音を読み込む
                var deathSound = Sound.LoadStrict(&quot;Resources/Explosion.wav&quot;, true);

                // 死亡音を再生
                Engine.Sound.Play(deathSound);

                // 自身を親から削除
                Parent.RemoveChildNode(this);

+               // ゲームオーバーに遷移
+               mainNode.ToGameOver();
            }
        }

        ...略...
</code></pre>
<p>これでプレイヤーが敵/敵弾に衝突したときにゲームオーバー画面が呼び出されるようになりました。</p>
<pre><code class="lang-cs">// BGMをフェードアウト
if (bgmID.HasValue)
{
    Engine.Sound.FadeOut(bgmID.Value, 1.0f);

    // BGMが止まったのでIDをnullに
    bgmID = null;
}
</code></pre>
<p>この部分ではBGMのフェードアウトを行っています。
<code>SoundMixer.FadeOut(int id, float seconds)</code>は，指定した音を指定した秒数でフェードアウトするというものです。
BGMが再生中，つまり<code>bgmID</code>がnullじゃないとき(=<code>bgmID.HasValue</code>が<code>true</code>のとき)にフェードアウトを行い，<code>bgmID</code>を<code>null</code>にします。ここで<code>bgmID</code>を<code>null</code>にすることで<code>bgmID.HasValue</code>が<code>false</code>となるため，フェードアウト処理は一度だけしか行われません。</p>
<h2 id="クリア画面の追加">クリア画面の追加</h2>
<p>クリア画面も追加してみましょう。
<code>TitleNode</code>や<code>GameOverNode</code>と同じ要領でクリア画面も作ってみましょう。</p>
<pre><code class="lang-diff" name="Main">+ using Altseed2;
+
+ namespace Tutorial
+ {
+   // クリア画面
+   public class LevelCompletedNode : Node
+   {
+       // 画面遷移中かどうか
+       private bool fading = false;
+
+       // エンジンに追加された時に実行
+       protected override void OnAdded()
+       {
+           // タイトル
+           var titleText = new TextNode();
+           // タイトルのフォントを読み込む
+           titleText.Font = Font.LoadDynamicFontStrict(&quot;Resources/GenYoMinJP-Bold.ttf&quot;);
+           // タイトルの文字のサイズを設定
+           titleText.FontSize = 100;
+           // タイトルの文字を設定
+           titleText.Text = &quot;Clear!&quot;;
+           // タイトルの座標を設定
+           titleText.Position = new Vector2F(Engine.WindowSize.X / 2, 100f);
+           // タイトルの中心座標を設定
+           titleText.CenterPosition = titleText.ContentSize / 2;
+           // タイトルを追加
+           AddChildNode(titleText);
+
+           // 画面下の案内
+           var announce = new TextNode();
+           // 案内のフォントを読み込む
+           announce.Font = Font.LoadDynamicFontStrict(&quot;Resources/GenYoMinJP-Bold.ttf&quot;);
+           // タイトルの文字のサイズを設定
+           announce.FontSize = 50;
+           // 案内のテキストを設定
+           announce.Text = &quot;Press Z to go title&quot;;
+           // 案内の座標を設定
+           announce.Position = new Vector2F(Engine.WindowSize.X / 2, 600f);
+           // 案内の中心座標を設定
+           announce.CenterPosition = announce.ContentSize / 2;
+           //案内を追加
+           AddChildNode(announce);
+       }
+
+       // フレーム毎に実行
+       protected override void OnUpdate()
+       {
+           // 画面遷移中でなく，かつZキーが押された時に実行
+           if (!fading &amp;&amp; Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
+           {
+               // エンジンから自身を削除
+               Engine.RemoveNode(this);
+
+               // エンジンにタイトル画面を追加
+               Engine.AddNode(new TitleNode());
+
+               // 画面遷移中のフラグを立てる
+               fading = true;
+           }
+       }
+   }
+ }
</code></pre>
<p>同様に，<code>MainNode.cs</code>にもクリア画面への遷移を追加してみましょう。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System.Collections.Generic;

namespace Tutorial
{
    // メインステージのクラス
    public class MainNode : Node
    {
        ...略...

        // 敵召還関連
        private void UpdateStage()
        {
            // カウントが100の倍数だったら
            if (count % 100 == 0)
            {
                // 敵が残っていたら画面に追加
                if (enemies.Count &gt; 0)
                {
                    characterNode.AddChildNode(enemies.Dequeue());
                }
                else
                {
+                   // もし画面遷移中でなければ実行
+                   if (!fading)
+                   {
+                       // BGMをフェードアウト
+                       if (bgmID.HasValue)
+                       {
+                           Engine.Sound.FadeOut(bgmID.Value, 1.0f);
+
+                           // BGMが止まったのでIDをnullに
+                           bgmID = null;
+                       }
+
+                       // エンジンから自身を削除
+                       Engine.RemoveNode(this);
+
+                       // クリア画面をエンジンに追加
+                       Engine.AddNode(new LevelCompletedNode());
+
+                       // 画面遷移中フラグを立てる
+                       fading = true;
+                   }
                }
            }
        }
    }
}
</code></pre>
<p>これで，ウェーブをクリアしたときに自動的にBGMがフェードアウトされ，クリア画面に遷移します。</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top"></a>
            </span>
            Copyright &copy; 2020 Altseed .
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
