<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>4&#31456; : &#12463;&#12521;&#12473;&#12434;&#33258;&#20998;&#12391;&#35373;&#35336;&#12375;&#12390;&#12415;&#12424;&#12358; | Altseed2 </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="4&#31456; : &#12463;&#12521;&#12473;&#12434;&#33258;&#20998;&#12391;&#35373;&#35336;&#12375;&#12390;&#12415;&#12424;&#12358; | Altseed2 ">
    <meta name="generator" content="docfx 2.56.2.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link rel="stylesheet" href="../../styles/reference.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" src="../../Logo.png" alt="" style="height:100%;margin-right:15px;">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href="../../Tutorials/index.html" title="&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;">&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;</a>
                      </li>
                      <li>
                          <a href="../../Manual/index.html" title="&#27231;&#33021;&#35299;&#35500;">&#27231;&#33021;&#35299;&#35500;</a>
                      </li>
                      <li>
                          <a href="../../References/Altseed2.html" title="&#12522;&#12501;&#12449;&#12524;&#12531;&#12473;">&#12522;&#12501;&#12449;&#12524;&#12531;&#12473;</a>
                      </li>
                      <li>
                          <a href="../../First/index.html" title="&#21021;&#20195;Altseed&#12399;&#12467;&#12481;&#12521;">&#21021;&#20195;Altseed&#12399;&#12467;&#12481;&#12521;</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <a href="../index.html" title="&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;" class="">&#12481;&#12517;&#12540;&#12488;&#12522;&#12450;&#12523;</a>
                    </li>
                    <li class="">
                      <a href="../Chap0/index.html" title="0&#31456; : Altseed&#12434;&#21021;&#12417;&#12424;&#12358;" class="">0&#31456; : Altseed&#12434;&#21021;&#12417;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap1/index.html" title="1&#31456; : &#12454;&#12451;&#12531;&#12489;&#12454;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">1&#31456; : &#12454;&#12451;&#12531;&#12489;&#12454;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap2/index.html" title="2&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12434;&#25551;&#30011;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">2&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12434;&#25551;&#30011;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap3/index.html" title="3&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12395;&#24382;&#12434;&#25731;&#12383;&#12379;&#12390;&#12415;&#12424;&#12358;" class="">3&#31456; : &#12461;&#12515;&#12521;&#12463;&#12479;&#12540;&#12395;&#24382;&#12434;&#25731;&#12383;&#12379;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="active">
                      <a href="../Chap4/index.html" title="4&#31456; : &#12463;&#12521;&#12473;&#12434;&#33258;&#20998;&#12391;&#35373;&#35336;&#12375;&#12390;&#12415;&#12424;&#12358;" class="active">4&#31456; : &#12463;&#12521;&#12473;&#12434;&#33258;&#20998;&#12391;&#35373;&#35336;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap5/index.html" title="5&#31456; : &#25973;&#12539;&#25973;&#12398;&#12471;&#12519;&#12483;&#12488;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">5&#31456; : &#25973;&#12539;&#25973;&#12398;&#12471;&#12519;&#12483;&#12488;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap6/index.html" title="6&#31456; : &#24403;&#12383;&#12426;&#21028;&#23450;&#12398;&#27231;&#33021;&#12434;&#20351;&#12387;&#12390;&#12415;&#12424;&#12358;" class="">6&#31456; : &#24403;&#12383;&#12426;&#21028;&#23450;&#12398;&#27231;&#33021;&#12434;&#20351;&#12387;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap7/index.html" title="7&#31456; : &#38899;&#12434;&#40180;&#12425;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">7&#31456; : &#38899;&#12434;&#40180;&#12425;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap8/index.html" title="8&#31456; : &#24471;&#28857;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;" class="">8&#31456; : &#24471;&#28857;&#12434;&#34920;&#31034;&#12375;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap9/index.html" title="9&#31456; : &#12479;&#12452;&#12488;&#12523;&#12539;&#12466;&#12540;&#12512;&#12458;&#12540;&#12496;&#12540;&#30011;&#38754;&#12434;&#20316;&#12387;&#12390;&#12415;&#12424;&#12358;" class="">9&#31456; : &#12479;&#12452;&#12488;&#12523;&#12539;&#12466;&#12540;&#12512;&#12458;&#12540;&#12496;&#12540;&#30011;&#38754;&#12434;&#20316;&#12387;&#12390;&#12415;&#12424;&#12358;</a>
                    </li>
                    <li class="">
                      <a href="../Chap10/index.html" title="10&#31456; : &#12356;&#12374;&#12289;&#20844;&#38283;&#28310;&#20633;" class="">10&#31456; : &#12356;&#12374;&#12289;&#20844;&#38283;&#28310;&#20633;</a>
                    </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="4章--クラスを自分で設計してみよう">4章 : クラスを自分で設計してみよう</h1>

<p>前章ではキャラクターが弾を撃つようになりました。
しかし、このまま新しい要素を<code>Main</code>メソッドに書き込んでいくと、ソースコードは段々と長く、わかりにくくなっていきます。
そこで、今回はソースコードを整理して、キャラクターと弾の処理を個別に行えるようにしましょう。</p>
<h2 id="新たに導入する知識">新たに導入する知識</h2>
<ul>
<li><a href="https://ufcpp.net/study/csharp/st_function.html">C#によるプログラミング入門 : 関数</a></li>
<li><a href="https://ufcpp.net/study/csharp/oo_inherit.html">C#によるプログラミング入門 : 継承</a></li>
</ul>
<h2 id="プレイヤーを動かす処理をメソッドを使って整理する">プレイヤーを動かす処理をメソッドを使って整理する</h2>
<p>プレイヤーや弾を移動させるソースコードが<code>while</code>文の中に書き込まれていたため、<code>while</code>文の中の処理が長くなっていました。
今はまだプレイヤーの移動と弾の発射だけなので、そこまで読みにくく感じることはないかもしれません。
しかし、ここに敵の追加や移動などの処理を加えると、ソースコードはどんどん長く、わかりにくくなっていきます。
しまいには開発者本人でさえ読めなくなってしまいます。
そこでまずは、メソッドを使って一連の処理をまとめていきましょう。</p>
<p>手始めに、キャラクターの移動に関する処理をメソッドで表現します。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;
using System.Collections.Generic;

namespace Tutorial
{
    class Program
    {
+       // プレイヤーの移動を行う
+       static void MovePlayer(SpriteNode player)
+       {
+           // ↑キーでY座標を減少
+           if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
+           {
+               player.Position -= new Vector2F(0.0f, 2.5f);
+           }
+
+           // ↓キーでY座標を増加
+           if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
+           {
+               player.Position += new Vector2F(0.0f, 2.5f);
+           }
+
+           // →キーでX座標を増加
+           if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
+           {
+               player.Position += new Vector2F(2.5f, 0.0f);
+           }
+
+           // ←キーでX座標を減少
+           if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
+           {
+               player.Position -= new Vector2F(2.5f, 0.0f);
+           }
+       }

        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

            // 自機弾を格納するリスト
            var list = new List&lt;SpriteNode&gt;();

            // 自機
            var player = new SpriteNode();
            // 自機のテクスチャを読み込む
            player.Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);
            // 自機の座標を設定
            player.Position = new Vector2F(100, 360);
            // 自機の中心座標を設定
            player.CenterPosition = player.ContentSize / 2;

            // 自機をエンジンに追加
            Engine.AddNode(player);

            // メインループ
            while (Engine.DoEvents())
            {
                // エンジンを更新
                Engine.Update();

-               // ↑キーでY座標を減少
-               if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
-               {
-                   player.Position -= new Vector2F(0.0f, 2.5f);
-               }
-
-               // ↓キーでY座標を増加
-               if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
-               {
-                   player.Position += new Vector2F(0.0f, 2.5f);
-               }
-
-               // →キーでX座標を増加
-               if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
-               {
-                   player.Position += new Vector2F(2.5f, 0.0f);
-               }
-
-               // ←キーでX座標を減少
-               if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
-               {
-                   player.Position -= new Vector2F(2.5f, 0.0f);
-               }

+               // プレイヤーを動かす
+               MovePlayer(player);

                // Zキーが押された時に実行
                if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
                {
                    // 発射される自機弾
                    var bullet = new SpriteNode();
                    // 自機弾のテクスチャを読み込む
                    bullet.Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);
                    // 自機弾の座標を設定
                    bullet.Position = player.Position;
                    // 自機弾の中心座標を設定
                    bullet.CenterPosition = bullet.ContentSize / 2;
                    // 自機弾の表示位置を自機より奥に設定
                    bullet.ZOrder--;

                    // 自機弾をエンジンに追加
                    Engine.AddNode(bullet);
                    // 自機弾をリストに追加
                    list.Add(bullet);
                }

                // 自機弾を右に進める
                for (int i = 0; i &lt; list.Count; i++)
                {
                    list[i].Position += new Vector2F(10.0f, 0.0f);
                }

                // Escapeキーでゲーム終了
                if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push)
                {
                    break;
                }
            }

            // エンジンの終了処理を行う
            Engine.Terminate();
        }
    }
}
</code></pre>
<p>ソースコードでは、以下のようにメソッドを追加しました。</p>
<pre><code class="lang-C#">static void MovePlayer(SpriteNode player)
{
    ......
}
</code></pre>
<p><code>MovePlayer</code>メソッドは引数<code>player</code>の移動に関する処理を行います。
<code>MovePlayer</code>メソッドの中の処理は、以下のように記述することで呼び出されます。</p>
<pre><code class="lang-C#">MovePlayer(player);
</code></pre>
<p>このように変更して、作成したプログラムを実行してみてください。
挙動は全く変わらないはずです。</p>
<h2 id="プレイヤーを動かす処理を継承を使って整理する">プレイヤーを動かす処理を継承を使って整理する</h2>
<p><code>Main</code>メソッドの中身がある程度すっきりしましたね。
しかし、これだけでは C#の良さは活かしきれません。
C#の機能にクラスというものがあったことを思い出してください。
ここからは、そのクラスを自分で設計していきましょう。</p>
<p>まず、プレイヤーに相当するクラスを追加します。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;
using System.Collections.Generic;

namespace Tutorial
{
+   // プレイヤーのクラス
+   public class Player : SpriteNode
+   {
+   }

    class Program
    {
        // プレイヤーの移動を行う
-       static void MovePlayer(SpriteNode player)
+       static void MovePlayer(Player player)
        {
            // ↑キーでY座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
            {
                player.Position -= new Vector2F(0.0f, 2.5f);
            }

            // ↓キーでY座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
            {
                player.Position += new Vector2F(0.0f, 2.5f);
            }

            // →キーでX座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
            {
                player.Position += new Vector2F(2.5f, 0.0f);
            }

            // ←キーでX座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
            {
                player.Position -= new Vector2F(2.5f, 0.0f);
            }
        }

        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

            // 自機弾を格納するリスト
            var list = new List&lt;SpriteNode&gt;();

            // 自機
-           var player = new SpriteNode();
+           var player = new Player();
            // 自機のテクスチャを読み込む
            player.Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);
            // 自機の座標を設定
            player.Position = new Vector2F(100, 360);
            // 自機の中心座標を設定
            player.CenterPosition = player.ContentSize / 2;

            // 自機をエンジンに追加
            Engine.AddNode(player);

            // メインループ
            while (Engine.DoEvents())
            {
                // エンジンを更新
                Engine.Update();

                // プレイヤーを動かす
                MovePlayer(player);

                // Zキーが押された時に実行
                if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
                {
                    // 発射される自機弾
                    var bullet = new SpriteNode();
                    // 自機弾のテクスチャを読み込む
                    bullet.Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);
                    // 自機弾の座標を設定
                    bullet.Position = player.Position;
                    // 自機弾の中心座標を設定
                    bullet.CenterPosition = bullet.ContentSize / 2;
                    // 自機弾の表示位置を自機より奥に設定
                    bullet.ZOrder--;

                    // 自機弾をエンジンに追加
                    Engine.AddNode(bullet);
                    // 自機弾をリストに追加
                    list.Add(bullet);
                }

                // 自機弾を右に進める
                for (int i = 0; i &lt; list.Count; i++)
                {
                    list[i].Position += new Vector2F(10.0f, 0.0f);
                }

                // Escapeキーでゲーム終了
                if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push)
                {
                    break;
                }
            }

            // エンジンの終了処理を行う
            Engine.Terminate();
        }
    }
}
</code></pre>
<p>ソースコードでは、以下のようにクラスを追加しました。</p>
<pre><code class="lang-C#">class Player : SpriteNode
{
    ......
}
</code></pre>
<p>第2章で、<code>SpriteNode</code>は設計図であると述べました。
この変更では、<code>SpriteNode</code>という設計図を利用して、<code>Player</code>という新たな設計図を作成しています。
この機能を「継承」と呼びます。</p>
<p>また、<code>var player = new SpriteNode();</code>の部分が<code>var player = new Player();</code>に変化しています。
このようにすることで、<code>player</code>は<code>Player</code>クラスのインスタンスになります。</p>
<p>この<code>Player</code>クラスには、新たな機能が何も追加されていません。
そこで、プレイヤーを動かす処理を<code>Player</code>クラスの内部に持っていきます。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;
using System.Collections.Generic;

namespace Tutorial
{
    // プレイヤーのクラス
    public class Player : SpriteNode
    {
+       // 移動を行う
+       public void Move()
+       {
+           // ↑キーでY座標を減少
+           if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
+           {
+               Position -= new Vector2F(0.0f, 2.5f);
+           }
+
+           // ↓キーでY座標を増加
+           if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
+           {
+               Position += new Vector2F(0.0f, 2.5f);
+           }
+
+           // →キーでX座標を増加
+           if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
+           {
+               Position += new Vector2F(2.5f, 0.0f);
+           }
+
+           // ←キーでX座標を減少
+           if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
+           {
+               Position -= new Vector2F(2.5f, 0.0f);
+           }
+       }
    }

    class Program
    {
-       // プレイヤーの移動を行う
-       static void MovePlayer(Player player)
-       {
-           // ↑キーでY座標を減少
-           if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
-           {
-               player.Position -= new Vector2F(0.0f, 2.5f);
-           }
-
-           // ↓キーでY座標を増加
-           if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
-           {
-               player.Position += new Vector2F(0.0f, 2.5f);
-           }
-
-           // →キーでX座標を増加
-           if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
-           {
-               player.Position += new Vector2F(2.5f, 0.0f);
-           }
-
-           // ←キーでX座標を減少
-           if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
-           {
-               player.Position -= new Vector2F(2.5f, 0.0f);
-           }
-       }

        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

            // 自機弾を格納するリスト
            var list = new List&lt;SpriteNode&gt;();

            // 自機
            var player = new Player();
            // 自機のテクスチャを読み込む
            player.Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);
            // 自機の座標を設定
            player.Position = new Vector2F(100, 360);
            // 自機の中心座標を設定
            player.CenterPosition = player.ContentSize / 2;

            // 自機をエンジンに追加
            Engine.AddNode(player);

            // メインループ
            while (Engine.DoEvents())
            {
                // エンジンを更新
                Engine.Update();

                // プレイヤーを動かす
-               MovePlayer(player);
+               player.Move();

                // Zキーが押された時に実行
                if (Engine.Keyboard.GetKeyState(Keys.Z) == ButtonState.Push)
                {
                    // 発射される自機弾
                    var bullet = new SpriteNode();
                    // 自機弾のテクスチャを読み込む
                    bullet.Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);
                    // 自機弾の座標を設定
                    bullet.Position = player.Position;
                    // 自機弾の中心座標を設定
                    bullet.CenterPosition = bullet.ContentSize / 2;
                    // 自機弾の表示位置を自機より奥に設定
                    bullet.ZOrder--;

                    // 自機弾をエンジンに追加
                    Engine.AddNode(bullet);
                    // 自機弾をリストに追加
                    list.Add(bullet);
                }

                // 自機弾を右に進める
                for (int i = 0; i &lt; list.Count; i++)
                {
                    list[i].Position += new Vector2F(10.0f, 0.0f);
                }

                // Escapeキーでゲーム終了
                if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push)
                {
                    break;
                }
            }

            // エンジンの終了処理を行う
            Engine.Terminate();
        }
    }
}
</code></pre>
<p><code>MovePlayer</code>メソッドの処理を、<code>Player</code>クラスの<code>Move</code>メソッドに移動させました。
<code>Player</code>クラスは、継承元である<code>SpriteNode</code>クラスの情報を持っているため、<code>Position</code>や<code>Texture</code>が自身の情報となります。
したがって<code>Move</code>メソッドの中では、たとえば<code>player.Position</code>とはせずに、単に<code>Position</code>と記述します。
また、<code>Main</code>メソッドからの呼び出し方が変わり、<code>player.Move()</code>とします。</p>
<p>続いて、Altseed2のUpdate機能を使って、<code>Player</code>クラスの更新を<code>Player</code>クラスの内部で行えるようにしましょう。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;
using System.Collections.Generic;

namespace Tutorial
{
    // プレイヤーのクラス
    public class Player : SpriteNode
    {
+       // フレーム毎に実行
+       protected override void OnUpdate()
+       {
+           // 移動を実行
+           Move();
+       }

        // 移動を行う
-       public void Move()
+       void Move()
        {
            // ↑キーでY座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
            {
                Position -= new Vector2F(0.0f, 2.5f);
            }

            // ↓キーでY座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
            {
                Position += new Vector2F(0.0f, 2.5f);
            }

            // →キーでX座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
            {
                Position += new Vector2F(2.5f, 0.0f);
            }

            // ←キーでX座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
            {
                Position -= new Vector2F(2.5f, 0.0f);
            }
        }
    }

    class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

            // 自機弾を格納するリスト
            var list = new List&lt;SpriteNode&gt;();

            // 自機
            var player = new Player();
            // 自機のテクスチャを読み込む
            player.Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);
            // 自機の座標を設定
            player.Position = new Vector2F(100, 360);
            // 自機の中心座標を設定
            player.CenterPosition = player.ContentSize / 2;

            // 自機をエンジンに追加
            Engine.AddNode(player);

            // メインループ
            while (Engine.DoEvents())
            {
                // エンジンを更新
                Engine.Update();

-               // プレイヤーを動かす
-               player.Move();

                // Zキーが押された時に実行
                if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
                {
                    // 発射される自機弾
                    var bullet = new SpriteNode();
                    // 自機弾のテクスチャを読み込む
                    bullet.Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);
                    // 自機弾の座標を設定
                    bullet.Position = player.Position;
                    // 自機弾の中心座標を設定
                    bullet.CenterPosition = bullet.ContentSize / 2;
                    // 自機弾の表示位置を自機より奥に設定
                    bullet.ZOrder--;

                    // 自機弾をエンジンに追加
                    Engine.AddNode(bullet);
                    // 自機弾をリストに追加
                    list.Add(bullet);
                }

                // 自機弾を右に進める
                for (int i = 0; i &lt; list.Count; i++)
                {
                    list[i].Position += new Vector2F(10.0f, 0.0f);
                }

                // Escapeキーでゲーム終了
                if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push)
                {
                    break;
                }
            }

            // エンジンの終了処理を行う
            Engine.Terminate();
        }
    }
}
</code></pre>
<p><code>OnUpdate</code>は、Altseed2が更新されるたびに実行されるメソッドです。
この中に<code>Move</code>メソッドを加えることで、今までと同じように<code>Move</code>メソッドがAltseed2が更新されるたびに実行されます。</p>
<pre><code class="lang-C#">protected override void OnUpdate()
{
    ......
}
</code></pre>
<p><code>override</code>は、継承元のメソッドの名前を使って処理を上書きするための機能です。
単に<code>OnUpdate</code>と記述するだけでなく、<code>override</code>も併せて記述しなければ、正しい動作は望めません。</p>
<p>なお、<code>public void Move()</code>の部分が<code>void Move()</code>に変化していることが見て取れます。
<code>public</code>や<code>protected</code>の説明は次の章にて行います。</p>
<h2 id="弾を動かす処理を継承を使って整理する">弾を動かす処理を継承を使って整理する</h2>
<p>今度は、先ほどと同じようにして弾のソースコードを整理していきます。
弾に相当するクラスを追加しましょう。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;
using System.Collections.Generic;

namespace Tutorial
{
    // プレイヤーのクラス
    public class Player : SpriteNode
    {
        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 移動を実行
            Move();
        }

        // 移動を行う
        void Move()
        {
            // ↑キーでY座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
            {
                Position -= new Vector2F(0.0f, 2.5f);
            }

            // ↓キーでY座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
            {
                Position += new Vector2F(0.0f, 2.5f);
            }

            // →キーでX座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
            {
                Position += new Vector2F(2.5f, 0.0f);
            }

            // ←キーでX座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
            {
                Position -= new Vector2F(2.5f, 0.0f);
            }
        }
    }
+    // 弾のクラス
+    public class Bullet : SpriteNode
+    {
+        // フレーム毎に実行
+        protected override void OnUpdate()
+        {
+            // 座標を速度分進める
+            Position += new Vector2F(10.0f, 0.0f);
+        }
+    }

    class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

-           // 自機弾を格納するリスト
-           var list = new List&lt;SpriteNode&gt;();

            // 自機
            var player = new Player();
            // 自機のテクスチャを読み込む
            player.Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);
            // 自機の座標を設定
            player.Position = new Vector2F(100, 360);
            // 自機の中心座標を設定
            player.CenterPosition = player.ContentSize / 2;

            // 自機をエンジンに追加
            Engine.AddNode(player);

            // メインループ
            while (Engine.DoEvents())
            {
                // エンジンを更新
                Engine.Update();

                // Zキーが押された時に実行
                if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
                {
                    // 発射される自機弾
-                   var bullet = new SpriteNode();
+                   var bullet = new Bullet();
                    // 自機弾のテクスチャを読み込む
                    bullet.Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);
                    // 自機弾の座標を設定
                    bullet.Position = player.Position;
                    // 自機弾の中心座標を設定
                    bullet.CenterPosition = bullet.ContentSize / 2;
                    // 自機弾の表示位置を自機より奥に設定
                    bullet.ZOrder--;

                    // 自機弾をエンジンに追加
                    Engine.AddNode(bullet);
-                   // 自機弾をリストに追加
-                   list.Add(bullet);
                }

-               // 自機弾を右に進める
-               for (int i = 0; i &lt; list.Count; i++)
-               {
-                   list[i].Position += new Vector2F(10.0f, 0.0f);
-               }

                // Escapeキーでゲーム終了
                if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push)
                {
                    break;
                }
            }

            // エンジンの終了処理を行う
            Engine.Terminate();
        }
    }
}
</code></pre>
<p><code>Bullet</code>クラスを追加しました。</p>
<pre><code class="lang-C#">public class Bullet : SpriteNode
{
    ...
}
</code></pre>
<p>また、<code>var bullet = new SpriteNode();</code>の部分が<code>var bullet = new Bullet();</code>に変化しています。
このようにすることで、<code>bullet</code>は<code>Bullet</code>クラスのインスタンスになります。
更新処理が<code>Bullet</code>クラスに記述されていることで、更新するたびに弾自身が自分で移動するようになります。
そのため、<code>List</code>による管理が必要なくなります。</p>
<h2 id="弾を撃つ処理をプレイヤーに移動する">弾を撃つ処理をプレイヤーに移動する</h2>
<p>弾を撃っているのはプレイヤーなので、弾を撃つ処理をプレイヤーに移動してみましょう。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;
using System.Collections.Generic;

namespace Tutorial
{
    // プレイヤーのクラス
    public class Player : SpriteNode
    {
        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 移動を実行
            Move();

+           // ショットを実行
+           Shot();
        }

        // 移動を行う
        void Move()
        {
            // ↑キーでY座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
            {
                Position -= new Vector2F(0.0f, 2.5f);
            }

            // ↓キーでY座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
            {
                Position += new Vector2F(0.0f, 2.5f);
            }

            // →キーでX座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
            {
                Position += new Vector2F(2.5f, 0.0f);
            }

            // ←キーでX座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
            {
                Position -= new Vector2F(2.5f, 0.0f);
            }
        }

+       // ショット
+       private void Shot()
+       {
+           // Zキーでショットを放つ
+           if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
+           {
+               // 発射される自機弾
+               var bullet = new Bullet();
+
+               // 自機弾のテクスチャを読み込む
+               bullet.Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);
+               // 自機弾の座標を設定
+               bullet.Position = Position;
+               // 自機弾の中心座標を設定
+               bullet.CenterPosition = bullet.ContentSize / 2;
+               // 自機弾の表示位置を自機より奥に設定
+               bullet.ZOrder--;
+
+               // 自機弾をエンジンに追加
+               Engine.AddNode(bullet);
+           }
+       }
    }

    // 弾のクラス
    public class Bullet : SpriteNode
    {
        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 座標を速度分進める
            Position += new Vector2F(10.0f, 0.0f);
        }
    }

    class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

            // 自機
            var player = new Player();
            // 自機のテクスチャを読み込む
            player.Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);
            // 自機の座標を設定
            player.Position = new Vector2F(100, 360);
            // 自機の中心座標を設定
            player.CenterPosition = player.ContentSize / 2;

            // 自機をエンジンに追加
            Engine.AddNode(player);

            // メインループ
            while (Engine.DoEvents())
            {
                // エンジンを更新
                Engine.Update();

-               // Zキーが押された時に実行
-               if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
-               {
-                   // 発射される自機弾
-                   var bullet = new Bullet();
-
-                   // 自機弾のテクスチャを読み込む
-                   bullet.Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);
-                   // 自機弾の座標を設定
-                   bullet.Position = player.Position;
-                   // 自機弾の中心座標を設定
-                   bullet.CenterPosition = bullet.ContentSize / 2;
-                   // 自機弾の表示位置を自機より奥に設定
-                   bullet.ZOrder--;
-
-                   // 自機弾をエンジンに追加
-                   Engine.AddNode(bullet);
-               }

                // Escapeキーでゲーム終了
                if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push)
                {
                    break;
                }
            }

            // エンジンの終了処理を行う
            Engine.Terminate();
        }
    }
}
</code></pre>
<p>プレイヤーに関する処理のほとんどが<code>Player</code>クラスに移動しましたね。
<code>Main</code>メソッドの<code>while</code>文の中身がAltseed2の更新処理だけになりました。
ここまで変更したプログラムを実行してみてください。
挙動は全く変わらないはずです。</p>
<h2 id="コンストラクタを使って初期値を設定する">コンストラクタを使って初期値を設定する</h2>
<p>大分、処理がクラスにまとまってきました。
しかし、画像と最初の位置の指定がクラスの外で行われています。
これら初期値の設定も、クラスの中で行いたいものです。
そこで登場するのが「コンストラクタ」です。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;
using System.Collections.Generic;

namespace Tutorial
{
    // プレイヤーのクラス
    public class Player : SpriteNode
    {
+       // コンストラクタ
+       public Player(Vector2F position)
+       {
+           // 座標を設定
+           Position = position;
+
+           // テクスチャを読み込む
+           Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);
+
+           // 中心座標を設定
+           CenterPosition = ContentSize / 2;
+       }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 移動を実行
            Move();

            // ショットを実行
            Shot();
        }

        // 移動を行う
        void Move()
        {
            // ↑キーでY座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
            {
                Position -= new Vector2F(0.0f, 2.5f);
            }

            // ↓キーでY座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
            {
                Position += new Vector2F(0.0f, 2.5f);
            }

            // →キーでX座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
            {
                Position += new Vector2F(2.5f, 0.0f);
            }

            // ←キーでX座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
            {
                Position -= new Vector2F(2.5f, 0.0f);
            }
        }

        // ショット
        private void Shot()
        {
            // Zキーでショットを放つ
            if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
            {
                // 発射される自機弾
-               var bullet = new Bullet();
+               var bullet = new Bullet(Position);

-               // 自機弾のテクスチャを読み込む
-               bullet.Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);
-               // 自機弾の座標を設定
-               bullet.Position = Position;
-               // 自機弾の中心座標を設定
-               bullet.CenterPosition = bullet.ContentSize / 2;
-               // 自機弾の表示位置を自機より奥に設定
-               bullet.ZOrder--;

                // 自機弾をエンジンに追加
                Engine.AddNode(bullet);
            }
        }
    }

    // 弾のクラス
    public class Bullet : SpriteNode
    {
+       // コンストラクタ
+       public Bullet(Vector2F position)
+       {
+           // 座標を設定
+           Position = position;
+
+           // テクスチャを読み込む
+           Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);
+
+           // 中心座標を設定
+           CenterPosition = ContentSize / 2;
+
+           // 表示位置をプレイヤーや敵より奥に設定
+           ZOrder--;
+       }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 座標を速度分進める
            Position += new Vector2F(10.0f, 0.0f);
        }
    }

    class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

            // 自機
-           var player = new Player();
+           var player = new Player(new Vector2F(100, 360));
-           // 自機のテクスチャを読み込む
-           player.Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);
-           // 自機の座標を設定
-           player.Position = new Vector2F(100, 360);
-           // 自機の中心座標を設定
-           player.CenterPosition = player.ContentSize / 2;

            // 自機をエンジンに追加
            Engine.AddNode(player);

            // メインループ
            while (Engine.DoEvents())
            {
                // エンジンを更新
                Engine.Update();

                // Escapeキーでゲーム終了
                if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push)
                {
                    break;
                }
            }

            // エンジンの終了処理を行う
            Engine.Terminate();
        }
    }
}
</code></pre>
<p>コンストラクタは、インスタンスが生成されたときに実行されるメソッドの一種です。
インスタンス生成と同時に画像を読み込むには、このコンストラクタにその処理を記述します。
また、コンストラクタはメソッドであり、引数を持つことができます。
ソースコードでは、<code>Player</code>クラスと<code>Bullet</code>クラスのコンストラクタに、引数　<code>position</code>を持たせています。
このようにすることで、プレイヤーや弾の最初の位置を外部から設定できるようになります。</p>
<p>次に、コンストラクタで弾の速度を設定できるようにしましょう。
<code>Bullet</code>クラスのコンストラクタに速度を引数として設定してそこからいじれるようにします。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;
using System.Collections.Generic;

namespace Tutorial
{
    // プレイヤーのクラス
    public class Player : SpriteNode
    {
        // コンストラクタ
        public Player(Vector2F position)
        {
            // 座標を設定
            Position = position;

            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 移動を実行
            Move();

            // ショットを実行
            Shot();
        }

        // 移動を行う
        void Move()
        {
            // ↑キーでY座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
            {
                Position -= new Vector2F(0.0f, 2.5f);
            }

            // ↓キーでY座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
            {
                Position += new Vector2F(0.0f, 2.5f);
            }

            // →キーでX座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
            {
                Position += new Vector2F(2.5f, 0.0f);
            }

            // ←キーでX座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
            {
                Position -= new Vector2F(2.5f, 0.0f);
            }
        }

        // ショット
        private void Shot()
        {
            // Zキーでショットを放つ
            if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
            {
                // 発射される自機弾
                var bullet = new Bullet(Position);

                // 自機弾をエンジンに追加
                Engine.AddNode(bullet);
            }
        }
    }

    // 弾のクラス
    public class Bullet : SpriteNode
    {
+       // フレーム毎に進む距離
+       private Vector2F velocity;

        // コンストラクタ
-       public Bullet(Vector2F position)
+       public Bullet(Vector2F position, Vector2F velocity)
        {
            // 座標を設定
            Position = position;
 
            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);
 
            // 中心座標を設定
            CenterPosition = ContentSize / 2;

+           // 弾速を設定
+           this.velocity = velocity;
 
            // 表示位置をプレイヤーや敵より奥に設定
            ZOrder--;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 座標を速度分進める
-           Position += new Vector2F(10.0f, 0.0f);
+           Position += velocity;
        }
    }

    class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

            // 自機
            var player = new Player(new Vector2F(100, 360));

            // 自機をエンジンに追加
            Engine.AddNode(player);

            // メインループ
            while (Engine.DoEvents())
            {
                // エンジンを更新
                Engine.Update();

                // Escapeキーでゲーム終了
                if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push)
                {
                    break;
                }
            }

            // エンジンの終了処理を行う
            Engine.Terminate();
        }
    }
}
</code></pre>
<p><code>Bullet</code>クラスのコンストラクタの引数を変えたので、それを呼び出すコードを修正しましょう。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;
using System.Collections.Generic;

namespace Tutorial
{
    // プレイヤーのクラス
    public class Player : SpriteNode
    {
        // コンストラクタ
        public Player(Vector2F position)
        {
            // 座標を設定
            Position = position;

            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 移動を実行
            Move();

            // ショットを実行
            Shot();
        }

        // 移動を行う
        void Move()
        {
            // ↑キーでY座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
            {
                Position -= new Vector2F(0.0f, 2.5f);
            }

            // ↓キーでY座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
            {
                Position += new Vector2F(0.0f, 2.5f);
            }

            // →キーでX座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
            {
                Position += new Vector2F(2.5f, 0.0f);
            }

            // ←キーでX座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
            {
                Position -= new Vector2F(2.5f, 0.0f);
            }
        }

        // ショット
        private void Shot()
        {
            // Zキーでショットを放つ
            if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
            {
                // 発射される自機弾
-               var bullet = new Bullet(Position);
+               var bullet = new Bullet(Position, new Vector2F(10f, 0f));

                // 自機弾をエンジンに追加
                Engine.AddNode(bullet);
            }
        }
    }

    // 弾のクラス
    public class Bullet : SpriteNode
    {
        // フレーム毎に進む距離
        private Vector2F velocity;

        // コンストラクタ
        public Bullet(Vector2F position, Vector2F velocity)
        {
            // 座標を設定
            Position = position;
 
            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);
 
            // 中心座標を設定
            CenterPosition = ContentSize / 2;

            // 弾速を設定
            this.velocity = velocity;
 
            // 表示位置をプレイヤーや敵より奥に設定
            ZOrder--;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 座標を速度分進める
            Position += velocity;
        }
    }

    class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

            // 自機
            var player = new Player(new Vector2F(100, 360));

            // 自機をエンジンに追加
            Engine.AddNode(player);

            // メインループ
            while (Engine.DoEvents())
            {
                // エンジンを更新
                Engine.Update();

                // Escapeキーでゲーム終了
                if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push)
                {
                    break;
                }
            }

            // エンジンの終了処理を行う
            Engine.Terminate();
        }
    }
}
</code></pre><h2 id="プレイヤーが画面外に出ないようにする">プレイヤーが画面外に出ないようにする</h2>
<p>ここまででできたプログラムを実行してわかると思いますが、方向キーを押しっぱなしにしていると、プレイヤーが画面外に出てしまいます。
そこで、プレイヤーが画面外に出ないように、処理を追加する必要があります。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;
using System.Collections.Generic;

namespace Tutorial
{
    // プレイヤーのクラス
    public class Player : SpriteNode
    {
        // コンストラクタ
        public Player(Vector2F position)
        {
            // 座標を設定
            Position = position;

            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 移動を実行
            Move();

            // ショットを実行
            Shot();
        }

        // 移動を行う
        void Move()
        {
+           // 現在のX座標を取得する
+           var x = Position.X;
+           // 現在のY座標を取得する
+           var y = Position.Y;

            // ↑キーでY座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
            {
-               Position -= new Vector2F(0.0f, 2.5f);
+               y -= 2.5f;
            }

            // ↓キーでY座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
            {
-               Position += new Vector2F(0.0f, 2.5f);
+               y += 2.5f;
            }

            // →キーでX座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
            {
-               Position += new Vector2F(2.5f, 0.0f);
+               x += 2.5f;
            }

            // ←キーでX座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
            {
-               Position -= new Vector2F(2.5f, 0.0f);
+               x -= 2.5f;
            }

+           // テクスチャのサイズの半分を取得する
+           var halfSize = ContentSize / 2;
+
+           // X座標が画面外に行かないように調整
+           x = MathHelper.Clamp(x, Engine.WindowSize.X - halfSize.X, halfSize.X);
+           // Y座標が画面外に行かないように調整
+           y = MathHelper.Clamp(y, Engine.WindowSize.Y - halfSize.Y, halfSize.Y);
+
+           // 調整された座標を設定
+           Position = new Vector2F(x, y);
        }

        // ショット
        private void Shot()
        {
            // Zキーでショットを放つ
            if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
            {
                // 発射される自機弾
                var bullet = new Bullet(Position, new Vector2F(10f, 0f));

                // 自機弾をエンジンに追加
                Engine.AddNode(bullet);
            }
        }
    }

    // 弾のクラス
    public class Bullet : SpriteNode
    {
        // フレーム毎に進む距離
        private Vector2F velocity;

        // コンストラクタ
        public Bullet(Vector2F position, Vector2F velocity)
        {
            // 座標を設定
            Position = position;

            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;

            // 弾速を設定
            this.velocity = velocity;

            // 表示位置をプレイヤーや敵より奥に設定
            ZOrder--;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 座標を速度分進める
            Position += velocity;
        }
    }

    class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

            // 自機
            var player = new Player(new Vector2F(100, 360));

            // 自機をエンジンに追加
            Engine.AddNode(player);

            // メインループ
            while (Engine.DoEvents())
            {
                // エンジンを更新
                Engine.Update();

                // Escapeキーでゲーム終了
                if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push)
                {
                    break;
                }
            }

            // エンジンの終了処理を行う
            Engine.Terminate();
        }
    }
}
</code></pre>
<p>追加した処理では、変更後の x 座標と y 座標について、画面に表示される範囲に収まるように数値を設定しています。
このようにすることで、プレイヤーが画面外に出ることはなくなります。</p>
<h2 id="弾が画面外に出たら消える処理を追加する">弾が画面外に出たら消える処理を追加する</h2>
<p>弾はいずれ画面外に出ていきます。
しかし、画面外に出た弾を削除せずに、エンジンに弾を追加していくと、エンジンの処理が重くなっていきます。
そのため、弾が画面外に出て行ったら削除する処理を追加する必要があります。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;
using System.Collections.Generic;

namespace Tutorial
{
    // プレイヤーのクラス
    public class Player : SpriteNode
    {
        // コンストラクタ
        public Player(Vector2F position)
        {
            // 座標を設定
            Position = position;

            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 移動を実行
            Move();

            // ショットを実行
            Shot();
        }

        // 移動を行う
        void Move()
        {
            // 現在のX座標を取得する
            var x = Position.X;
            // 現在のY座標を取得する
            var y = Position.Y;

            // ↑キーでY座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
            {
                y -= 2.5f;
            }

            // ↓キーでY座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
            {
                y += 2.5f;
            }

            // →キーでX座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
            {
                x += 2.5f;
            }

            // ←キーでX座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
            {
                x -= 2.5f;
            }

            // テクスチャのサイズの半分を取得する
            var halfSize = ContentSize / 2;

            // X座標が画面外に行かないように調整
            x = MathHelper.Clamp(x, Engine.WindowSize.X - halfSize.X, halfSize.X);
            // Y座標が画面外に行かないように調整
            y = MathHelper.Clamp(y, Engine.WindowSize.Y - halfSize.Y, halfSize.Y);

            // 調整された座標を設定
            Position = new Vector2F(x, y);
        }

        // ショット
        private void Shot()
        {
            // Zキーでショットを放つ
            if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
            {
                // 発射される自機弾
                var bullet = new Bullet(Position, new Vector2F(10f, 0f));

                // 自機弾をエンジンに追加
                Engine.AddNode(bullet);
            }
        }
    }

    // 弾のクラス
    public class Bullet : SpriteNode
    {
        // フレーム毎に進む距離
        private Vector2F velocity;

        // コンストラクタ
        public Bullet(Vector2F position, Vector2F velocity)
        {
            // 座標を設定
            Position = position;

            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Bullet_Blue.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;

            // 弾速を設定
            this.velocity = velocity;

            // 表示位置をプレイヤーや敵より奥に設定
            ZOrder--;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 座標を速度分進める
            Position += velocity;

+           // 画面外に出たら自身を削除
+           RemoveMyselfIfOutOfWindow();
        }

+       // 画面外に出た時自身を消去
+       private void RemoveMyselfIfOutOfWindow()
+       {
+           var halfSize = Texture.Size / 2;
+           if (Position.X &lt; -halfSize.X
+               || Position.X &gt; Engine.WindowSize.X + halfSize.X
+               || Position.Y &lt; -halfSize.Y
+               || Position.Y &gt; Engine.WindowSize.Y + halfSize.Y)
+           {
+               // 自身を削除
+               Parent?.RemoveChildNode(this);
+           }
+       }
    }

    class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

            // 自機
            var player = new Player(new Vector2F(100, 360));

            // 自機をエンジンに追加
            Engine.AddNode(player);

            // メインループ
            while (Engine.DoEvents())
            {
                // エンジンを更新
                Engine.Update();

                // Escapeキーでゲーム終了
                if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push)
                {
                    break;
                }
            }

            // エンジンの終了処理を行う
            Engine.Terminate();
        }
    }
}
</code></pre>
<p>弾が画面外に出たら、親ノードを取得して<code>RemoveChildNode</code>メソッドを実行します。
このメソッドを実行すると、弾のインスタンスはAltseed2の管理対象から除外されます。
すなわち、画面外に出た弾は管理されなくなるということです。
これにて、画面外の弾が消えないも解決です。</p>
<h2 id="クラスごとにファイルを分ける">クラスごとにファイルを分ける</h2>
<p>さて、ここまでソースコードをProgram.csに書き込んできたわけですが、行数が多くなり、見通しも悪くなってきました。
そこで、新しい C#のソースファイルを追加して、ソースコードを切り分けていきましょう。</p>
<h3 id="windows-の場合">Windows の場合</h3>
<p>まず、下図に示すように、「ShootingGame」の青く示された部分を右クリックしてください。
その後、選択肢のウィンドウが出てくるので、「追加」、「新しい項目」の順にクリックしてください。</p>
<p><img src="Image/newfile_win_1.png" alt="newfile_win_1">
<img src="Image/newfile_win_2.png" alt="newfile_win_2"></p>
<p>すると、「新しい項目の追加 - ShootingGame」というウィンドウが表示されます。
ウィンドウが表示されたら、画面左側の選択肢から「コード」を選択し、その後、画面中央の選択肢から「クラス」を選択します。
次に、画面下側の入力ボックスに、ファイル名を入力します。
今回は<code>Player</code>クラスを別のファイルに移動したいため、ファイル名を「Player.cs」とします。
入力が終わったら、「追加」をクリックします。</p>
<p><img src="Image/newfile_win_3.png" alt="newfile_win_3"></p>
<p>ここまで終わったら、「ソリューション」のところに「Player.cs」が追加されているはずです。
あとは、Program.csに記述されている<code>Player</code>クラスの部分を切り取って、Player.csに貼り付けるだけです。
ただし、ただ切り貼りしただけではエラーが発生します。
これは、ソースファイルに<code>Altseed</code>という名前空間が知らされていないことが原因です。
Player.csの頭に「<code>using Altseed2;</code>」と記述しましょう。</p>
<p><img src="Image/newfile_win_4.png" alt="newfile_win_4">
<img src="Image/newfile_win_5.png" alt="newfile_win_5"></p>
<p>これと同様の手順を踏んで、Bullet.csを追加し、<code>Bullet</code>クラスを移してみてください。</p>
<h3 id="mac-の場合">Mac の場合</h3>
<p>まず、下図に示すように、「ShootingGame」の青く示された部分を右クリックしてください。
その後、選択肢のウィンドウが出てくるので、「追加」、「新しいファイル」の順にクリックしてください。</p>
<p><img src="Image/newfile_mac_1.png" alt="newfile_mac_1"></p>
<p>すると、「新しいファイル」というウィンドウが表示されます。
ウィンドウが表示されたら、画面左側の選択肢から「General」を選択し、その後、画面中央の選択肢から「空のクラス」を選択します。
次に、画面下側の入力ボックスに、ファイル名を入力します。
今回は<code>Player</code>クラスを別のファイルに移動したいため、ファイル名を「Player」とします。
入力が終わったら、「新規」をクリックします。</p>
<p><img src="Image/newfile_mac_2.png" alt="newfile_mac_2"></p>
<p>ここまで終わったら、「ソリューション」のところに「Player.cs」が追加されているはずです。
あとは、Program.csに記述されている<code>Player</code>クラスの部分を切り取って、Player.csに貼り付けるだけです。
ただし、ただ切り貼りしただけではエラーが発生します。
これは、ソースファイルに<code>Altseed</code>という名前空間が知らされていないことが原因です。
Player.csの頭に「<code>using Altseed;</code>」と記述しましょう。</p>
<p><img src="Image/newfile_mac_3.png" alt="newfile_mac_3">
<img src="Image/newfile_mac_4.png" alt="newfile_mac_4"></p>
<p>これと同様の手順を踏んで、Bullet.csを追加し、<code>Bullet</code>クラスを移してみてください。</p>
<h2 id="プレイヤーや弾をまとめて管理できるようにする">プレイヤーや弾をまとめて管理できるようにする</h2>
<p>ソースコードが複数のファイルに振り分けられたことで、Program.csの内容がこれだけになりました。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;
using System.Collections.Generic;

namespace Tutorial
{
    class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

            // 自機
            var player = new Player(new Vector2F(100, 360));

            // 自機をエンジンに追加
            Engine.AddNode(player);

            // メインループ
            while (Engine.DoEvents())
            {
                // エンジンを更新
                Engine.Update();

                // Escapeキーでゲーム終了
                if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push)
                {
                    break;
                }
            }

            // エンジンの終了処理を行う
            Engine.Terminate();
        }
    }
}
</code></pre>
<p>しかし、このソースコードでは、プレイヤーや弾を、エンジンに直接登録してしまっています。
このままでは、何か別の画面に切り替えようとした場合に、エンジンに直接登録されたオブジェクトをいちいち登録解除するのが面倒です。
そこで、プレイヤーや弾をまとめて管理できる、すなわちメインステージを追加しておきましょう。</p>
<p>まず、新しくMainNode.csを作成します。
手順は、先ほどソースコードを振り分ける時に行ったものと同じです。</p>
<p>ファイルを新規作成できたら、メインステージを表す<code>MainNode</code>クラスに処理を書き込んでいきます。
MainNode.csに以下のように書いてください。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // メインステージのクラス
    public class MainNode : Node
    {
        // キャラクターを表示するノード
        private Node characterNode = new Node();
        
        // プレイヤーの参照
        private Player player;

        // エンジンに追加された時に実行
        protected override void OnAdded()
        {
            // キャラクターノードを追加
            AddChildNode(characterNode);

            // UIを表示するノード
            var uiNode = new Node();

            // UIノードを追加
            AddChildNode(uiNode);

            // プレイヤーを設定
            player = new Player(new Vector2F(100, 360));

            // キャラクターノードにプレイヤーを追加
            characterNode.AddChildNode(player);
        }
    }
}
</code></pre>
<p><code>OnAdded</code>は、このノードがエンジンに登録されたときに実行されるメソッドです。
ノードの初期状態を設定するには、このメソッドを使います。</p>
<pre><code class="lang-C#">protected override void OnAdded()
{
    ......
}
</code></pre>
<p>さて、<code>MainNode</code>クラスは、ノードを表す<code>Node</code>クラスを継承しています。
こうすることで、<code>MainNode</code>クラスのインスタンスは、エンジンに登録されるノードとして作用します。
このノードにプレイヤーや弾を登録することで、これらをまとめて管理できるというわけです。</p>
<p>また、<code>MainNode</code>の中にも、<code>characterNode</code>や<code>uiNode</code>のような、<code>Node</code>クラスのインスタンスがあります。
同じ画面の中でも、プレイヤーや弾といったゲーム中のオブジェクトと、残機や得点といった UI に関わるオブジェクトを、それぞれまとめて管理したいものです。
このように、<code>Node</code>クラスのインスタンスをうまく利用することで、系統ごとにオブジェクトをまとめて管理することができます。</p>
<p>では、<code>MainNode</code>クラスのインスタンスを作成し、それをエンジンに登録してみましょう。
Program.csに移って、以下のようにソースコードを書き換えてください。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;
using System;
using System.Collections.Generic;

namespace Tutorial
{
    class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            // エンジンを初期化
            Engine.Initialize(&quot;Tutorial&quot;, 960, 720);

-           // 自機
-           var player = new Player(new Vector2F(100, 360));
-
-           // 自機をエンジンに追加
-           Engine.AddNode(player);
+           // メイン画面をエンジンに追加
+           Engine.AddNode(new MainNode());

            // メインループ
            while (Engine.DoEvents())
            {
                // エンジンを更新
                Engine.Update();

                // Escapeキーでゲーム終了
                if (Engine.Keyboard.GetKeyState(Key.Escape) == ButtonState.Push)
                {
                    break;
                }
            }

            // エンジンの終了処理を行う
            Engine.Terminate();
        }
    }
}
</code></pre>
<p>このようにすると、<code>MainNode</code>の子ノードとして登録されているオブジェクト群が更新され、先ほどと同じ挙動をします。</p>
<p>また、ゲームシーンとして<code>MainNode</code>を定義したため、<code>Player</code>クラスで行っている自機弾の追加先をエンジンから、<code>MainNode</code>にある<code>characterNode</code>に変更しましょう。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // プレイヤーのクラス
    public class Player : SpriteNode
    {
        // コンストラクタ
        public Player(Vector2F position)
        {
            // 座標を設定
            Position = position;

            // テクスチャを読み込む
            Texture = Texture2D.LoadStrict(&quot;Resources/Player.png&quot;);

            // 中心座標を設定
            CenterPosition = ContentSize / 2;
        }

        // フレーム毎に実行
        protected override void OnUpdate()
        {
            // 移動を実行
            Move();

            // ショットを実行
            Shot();
        }

        // 移動を行う
        void Move()
        {
            // 現在のX座標を取得する
            var x = Position.X;
            // 現在のY座標を取得する
            var y = Position.Y;

            // ↑キーでY座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Up) == ButtonState.Hold)
            {
                y -= 2.5f;
            }

            // ↓キーでY座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Down) == ButtonState.Hold)
            {
                y += 2.5f;
            }

            // →キーでX座標を増加
            if (Engine.Keyboard.GetKeyState(Key.Right) == ButtonState.Hold)
            {
                x += 2.5f;
            }

            // ←キーでX座標を減少
            if (Engine.Keyboard.GetKeyState(Key.Left) == ButtonState.Hold)
            {
                x -= 2.5f;
            }

            // テクスチャのサイズの半分を取得する
            var halfSize = ContentSize / 2;

            // X座標が画面外に行かないように調整
            x = MathHelper.Clamp(x, Engine.WindowSize.X - halfSize.X, halfSize.X);
            // Y座標が画面外に行かないように調整
            y = MathHelper.Clamp(y, Engine.WindowSize.Y - halfSize.Y, halfSize.Y);

            // 調整された座標を設定
            Position = new Vector2F(x, y);
        }

        // ショット
        private void Shot()
        {
            // Zキーでショットを放つ
            if (Engine.Keyboard.GetKeyState(Key.Z) == ButtonState.Push)
            {
-               // 発射される自機弾
-               var bullet = new Bullet(Position, new Vector2F(10f, 0f));
-
-               // 自機弾をエンジンに追加
-               Engine.AddNode(bullet);

+               // Zキーでショットを放つ
+               Parent.AddChildNode(new Bullet(Position , new Vector2F(10f, 0f)));
            }
        }
    }
}
</code></pre>
<p>ここで，<code>MainNode.characterNode</code>がないではないかと思うかもしれませんが、<code>Parent</code>が<code>MainNode.characterNode</code>を表しています。
MainNode.csにて、</p>
<pre><code class="lang-cs">// キャラクターノードを追加
AddChildNode(characterNode);

......

// キャラクターノードにプレイヤーを追加
characterNode.AddChildNode(player);
</code></pre>
<p>という記述があります。これは、
<code>エンジン-MainNode-characterNode-Player</code>
という親子関係を示しています。
ここで<code>MainNode.characterNode</code>の参照が欲しいとなったときは<code>Player</code>から<code>Parent</code>を呼び出すことで解決できます。</p>
<h2 id="背景を追加する">背景を追加する</h2>
<p>ソースコードが整理できたので、ここから敵を追加していっても良い頃合いです。
しかしその前に、プレーンな背景で繰り広げられるゲームは、いまいち面白みに欠けますよね。
それっぽい背景が欲しいものです。
ということで、<code>MainNode</code>に背景を追加する機能を追加しておきましょう。</p>
<pre><code class="lang-diff" name="Main">using Altseed2;

namespace Tutorial
{
    // メインステージのクラス
    public class MainNode : Node
    {
        // キャラクターを表示するノード
        private Node characterNode = new Node();
        
        // プレイヤーの参照
        private Player player;

        // エンジンに追加された時に実行
        protected override void OnAdded()
        {
            // キャラクターノードを追加
            AddChildNode(characterNode);

            // UIを表示するノード
            var uiNode = new Node();

            // UIノードを追加
            AddChildNode(uiNode);

+           // 背景に使用するテクスチャ
+           var backTexture = new SpriteNode();
+           // 背景のテクスチャを読み込む
+           backTexture.Texture = Texture2D.LoadStrict(&quot;Resources/Background.png&quot;);
+           // 表示位置を奥に設定
+           backTexture.ZOrder = -100;
+
+           // 背景テクスチャを追加
+           AddChildNode(backTexture);

            // プレイヤーを設定
            player = new Player(new Vector2F(100, 360));

            // キャラクターノードにプレイヤーを追加
            characterNode.AddChildNode(player);
        }
    }
}
</code></pre>
<p>シューティングゲームらしい絵面になりました。</p>
<h2 id="まとめと次回予告">まとめと次回予告</h2>
<p>今回は、C#のオブジェクト指向の機能を活用して、ソースコードを整理し、その過程で新たな機能を追加してきました。
このように、機能ごとにクラスを分けておくことで、ソースコードが読みやすくなります。
それによって、プログラムが落ちるなど、予期しない挙動が発生したとき、その原因となっている箇所を見つけやすくもなります。
クラスを自分で設計するということは、初めのうちは難しいかもしれません。
しかし、慣れていくと、自由自在にクラスを設計することができるようになります。</p>
<p>次回からやっと、敵機・敵弾を追加していきます。</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright &copy; 2020 Altseed .
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
